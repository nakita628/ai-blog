---
date: 2026-02-25
title: TanStack Query v5 実践ガイド ― サーバー状態管理の決定版
description: TanStack Query v5 の主要フック（useQuery・useMutation・useSuspenseQuery）の使い方、v4 からの破壊的変更、queryOptions による型安全な設計パターンをコード例とともに解説する。
tags:
  - react
  - typescript
  - tanstack-query
  - javascript
prev:
  text: 'React 19 Hooks 実践ガイド ― 何を解決し、どこで躓くのか'
  link: '/posts/2026/02/24'
next:
  text: 'Phoenix Framework と LiveView 実践ガイド ― Elixir によるリアルタイム Web 開発'
  link: '/posts/2026/02/27'
---

# TanStack Query v5 実践ガイド ― サーバー状態管理の決定版

React アプリケーションにおけるサーバー状態管理は、`useState` + `useEffect` の組み合わせでは煩雑になりがちである。TanStack Query（旧 React Query）は、データの取得・キャッシュ・同期・更新を宣言的に扱えるライブラリであり、v5 では API の統一、Suspense の正式サポート、バンドルサイズの 20% 削減など大幅な改善が行われた。

## TanStack Query のアーキテクチャ

```mermaid
flowchart TD
    A[コンポーネント] -->|useQuery| B[Query Observer]
    A -->|useMutation| C[Mutation Observer]
    B --> D[Query Cache]
    C --> D
    D -->|staleTime 経過| E[バックグラウンド再取得]
    D -->|gcTime 経過| F[ガベージコレクション]
    E --> D

    style A fill:#4a90d9,color:#fff
    style D fill:#e67e22,color:#fff
    style E fill:#2ecc71,color:#fff
```

QueryClient が管理するキャッシュを中心に、各コンポーネントの Observer がデータの変更を購読する。`staleTime` を超えたデータはバックグラウンドで再取得され、`gcTime` を超えた未使用データはガベージコレクションされる。

## セットアップ

```bash
npm install @tanstack/react-query
```

```typescript
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			staleTime: 60 * 1000,
			gcTime: 5 * 60 * 1000,
			retry: 3,
			refetchOnWindowFocus: false,
		},
	},
})

function App() {
	return (
		<QueryClientProvider client={queryClient}>
			<MyApp />
		</QueryClientProvider>
	)
}
```

## 主要フックの使い方

### useQuery ― データ取得の基本

```typescript
import { useQuery } from '@tanstack/react-query'

interface Todo {
	id: number
	title: string
	completed: boolean
}

function TodoList() {
	const { data, isPending, isError, error } = useQuery({
		queryKey: ['todos'],
		queryFn: async (): Promise<Todo[]> => {
			const res = await fetch('/api/todos')
			if (!res.ok) throw new Error('Failed to fetch')
			return res.json()
		},
		staleTime: 5 * 60 * 1000,
	})

	if (isPending) return <p>読み込み中...</p>
	if (isError) return <p>エラー: {error.message}</p>

	return (
		<ul>
			{data.map((todo) => (
				<li key={todo.id}>{todo.title}</li>
			))}
		</ul>
	)
}
```

v5 では引数がすべて**単一オブジェクト形式**に統一された。また `status: 'loading'` は `status: 'pending'` に、`isLoading` は `isPending` にリネームされている。

### useMutation ― データ更新

```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query'

function AddTodo() {
	const queryClient = useQueryClient()

	const mutation = useMutation({
		mutationFn: async (newTodo: { title: string }) => {
			const res = await fetch('/api/todos', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(newTodo),
			})
			return res.json()
		},
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ['todos'] })
		},
	})

	const handleSubmit = (title: string) => {
		mutation.mutate({ title })
	}

	return (
		<div>
			<button
				onClick={() => handleSubmit('新しいタスク')}
				disabled={mutation.isPending}
			>
				{mutation.isPending ? '送信中...' : '追加'}
			</button>
			{mutation.isError && <p>エラー: {mutation.error.message}</p>}
		</div>
	)
}
```

`onSuccess` コールバックは `useQuery` からは削除されたが、`useMutation` では引き続き利用できる。

### useSuspenseQuery ― Suspense 対応

v5 で正式サポートされた Suspense 用フックである。`data` が `undefined` にならないことが型レベルで保証される。

```typescript
import { useSuspenseQuery } from '@tanstack/react-query'
import { Suspense } from 'react'
import { ErrorBoundary } from 'react-error-boundary'

function TodoListContent() {
	const { data } = useSuspenseQuery({
		queryKey: ['todos'],
		queryFn: fetchTodos,
	})

	// data は Todo[] 型（Todo[] | undefined ではない）
	return (
		<ul>
			{data.map((todo) => (
				<li key={todo.id}>{todo.title}</li>
			))}
		</ul>
	)
}

function TodoPage() {
	return (
		<ErrorBoundary fallback={<p>エラーが発生した</p>}>
			<Suspense fallback={<p>読み込み中...</p>}>
				<TodoListContent />
			</Suspense>
		</ErrorBoundary>
	)
}
```

## v4 → v5 主要な変更点

```mermaid
flowchart LR
    subgraph v4["v4（旧）"]
        A1["cacheTime"]
        A2["isLoading"]
        A3["onSuccess / onError"]
        A4["keepPreviousData"]
    end

    subgraph v5["v5（新）"]
        B1["gcTime"]
        B2["isPending"]
        B3["グローバルキャッシュハンドラ"]
        B4["placeholderData"]
    end

    A1 -->|リネーム| B1
    A2 -->|リネーム| B2
    A3 -->|削除→移行| B3
    A4 -->|削除→移行| B4

    style v4 fill:#e74c3c,color:#fff
    style v5 fill:#2ecc71,color:#fff
```

| v4                      | v5                    | 変更理由                                   |
| ----------------------- | --------------------- | ------------------------------------------ |
| `cacheTime`             | `gcTime`              | ガベージコレクション時間であることを明確化 |
| `isLoading`             | `isPending`           | ステータス名 `pending` との統一            |
| `onSuccess` / `onError` | 削除（useQuery のみ） | グローバルキャッシュハンドラへ移行         |
| `keepPreviousData`      | `placeholderData`     | `(prev) => prev` パターンで代替            |
| 複数引数オーバーロード  | 単一オブジェクト      | 型推論の改善・API の統一                   |

## queryOptions による型安全な共有

v5 で追加された `queryOptions` を使うと、`useQuery` と `queryClient` のメソッド間でクエリ定義を型安全に共有できる。

```typescript
import { queryOptions, useQuery, useQueryClient } from '@tanstack/react-query'

function todosQueryOptions(status?: string) {
  return queryOptions({
    queryKey: ['todos', { status }] as const,
    queryFn: () => fetchTodos(status),
    staleTime: 5 * 60 * 1000,
  })
}

// コンポーネントでの使用
function TodoList() {
  const { data } = useQuery(todosQueryOptions('active'))
  // ...
}

// プリフェッチでの使用
function usePrefetchTodos() {
  const queryClient = useQueryClient()
  return () => queryClient.prefetchQuery(todosQueryOptions())
}
```

## データフローの全体像

```mermaid
sequenceDiagram
    participant C as コンポーネント
    participant Q as QueryCache
    participant S as サーバー

    C->>Q: useQuery({ queryKey, queryFn })
    alt キャッシュヒット（fresh）
        Q-->>C: キャッシュデータを返却
    else キャッシュヒット（stale）
        Q-->>C: キャッシュデータを返却
        Q->>S: バックグラウンド再取得
        S-->>Q: 最新データ
        Q-->>C: 再レンダリング
    else キャッシュミス
        Q->>S: データ取得
        S-->>Q: レスポンス
        Q-->>C: データを返却
    end
```

キャッシュの状態（fresh / stale / inactive）に応じて自動的に最適な戦略が選択される。`staleTime` と `gcTime` の設定により、ネットワークリクエストの頻度とメモリ消費のバランスを制御できる。

## useMutationState ― コンポーネント横断の状態共有

v5 で新たに追加された `useMutationState` を使うと、特定の Mutation の状態を別のコンポーネントから参照できる。

```typescript
import { useMutationState } from '@tanstack/react-query'

function GlobalSaveIndicator() {
	const pendingMutations = useMutationState({
		filters: { status: 'pending' },
		select: (mutation) => mutation.state.variables,
	})

	if (pendingMutations.length === 0) return null

	return <div>保存中... ({pendingMutations.length} 件)</div>
}
```

## まとめ

TanStack Query v5 は、API の統一（単一オブジェクト形式）、Suspense の正式サポート、`queryOptions` による型安全な設計パターンにより、サーバー状態管理のベストプラクティスをさらに推し進めたライブラリである。`useState` + `useEffect` でのデータ取得に限界を感じているなら、導入を検討する価値は十分にある。

## 参考

- [TanStack Query 公式ドキュメント](https://tanstack.com/query/latest/docs/overview)
- [Announcing TanStack Query v5（公式ブログ）](https://tanstack.com/blog/announcing-tanstack-query-v5)
- [Migrating to TanStack Query v5（公式移行ガイド）](https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-v5)
- [GitHub - TanStack/query](https://github.com/TanStack/query)
- [Zenn - Next.jsでTanStack Queryを使ってみた](https://zenn.dev/devtatsu/articles/tanstack-query)
