---
date: 2026-01-29
title: Effect入門 - TypeScriptで型安全なエラーハンドリングを実現する
description: Effectは堅牢なTypeScriptアプリケーション構築のためのライブラリである。Effect型の基本構造、型安全なエラーハンドリング、依存性注入など、初心者にもわかりやすく解説する。
tags:
  - typescript
  - effect
  - error-handling
  - functional-programming
prev:
  text: '2026年1月 AIツール・モデル最新動向まとめ'
  link: '/posts/2026/01/28'
next:
  text: 'Atlas入門 - モダンなデータベーススキーマ管理とマイグレーション'
  link: '/posts/2026/01/30'
---

# Effect入門 - TypeScriptで型安全なエラーハンドリングを実現する

TypeScriptでアプリケーションを開発していると、エラーハンドリングや非同期処理の管理が複雑になりがちである。`try-catch`のネストが深くなったり、エラーの型が`unknown`になって何が起きるかわからなかったりする経験は、多くの開発者が持っているだろう。

[Effect](https://effect.website/)は、こうした問題を解決するTypeScriptライブラリである。「The best way to build robust apps in TypeScript」というスローガンの通り、堅牢で予測可能なコードを書くための仕組みを提供している。

## Effectを使うと何が良いのか

Effectの主なメリットは以下の3点である。

```mermaid
flowchart LR
    subgraph Benefits["Effectの3大メリット"]
        A["型安全な<br/>エラーハンドリング"]
        B["依存性の<br/>明示化"]
        C["関数の<br/>組み合わせやすさ"]
    end

    A --> D["コンパイル時に<br/>エラー漏れを検出"]
    B --> E["テストしやすい<br/>コード"]
    C --> F["複雑な処理を<br/>シンプルに記述"]

    style A fill:#4a90d9,color:#fff
    style B fill:#2ecc71,color:#fff
    style C fill:#9b59b6,color:#fff
```

### 1. 型安全なエラーハンドリング

従来のTypeScriptでは、`catch`ブロックで受け取るエラーは`unknown`型になる。どんなエラーが発生するか、型システムでは追跡できない。

```typescript
// 従来の方法：エラーの型がわからない
async function fetchUser(id: string) {
  try {
    const response = await fetch(`/api/users/${id}`)
    if (!response.ok) {
      throw new Error('Not found')
    }
    return await response.json()
  } catch (error) {
    // errorはunknown型。何が来るかわからない
    console.error(error)
    throw error
  }
}
```

Effectでは、発生しうるエラーが型として明示される。

### 2. 依存性の明示化

外部サービスやデータベースへの依存が型に現れるため、コードを読むだけで「この関数は何に依存しているか」がわかる。テスト時にモックを注入するのも容易になる。

### 3. 関数の組み合わせやすさ

小さな関数を`pipe`で組み合わせて、複雑な処理を構築できる。各ステップが独立しているため、テストやデバッグがしやすい。

## Effect型の基本構造

Effectの中心となるのは`Effect`型である。3つの型パラメータを持つ。

```typescript
Effect<Success, Error, Requirements>
```

```mermaid
flowchart TB
    subgraph EffectType["Effect<Success, Error, Requirements>"]
        S["Success<br/>成功時の値の型"]
        E["Error<br/>失敗時のエラーの型"]
        R["Requirements<br/>必要な依存の型"]
    end

    S --> S1["number, string, User など"]
    E --> E1["NotFoundError, NetworkError など"]
    R --> R1["DatabaseService, LoggerService など"]

    style S fill:#2ecc71,color:#fff
    style E fill:#e74c3c,color:#fff
    style R fill:#3498db,color:#fff
```

| パラメータ   | 説明                   | 例                                     |
| ------------ | ---------------------- | -------------------------------------- |
| Success      | 成功時に返される値の型 | `User`, `string`, `void`               |
| Error        | 発生しうるエラーの型   | `NotFoundError`, `NetworkError`        |
| Requirements | 実行に必要な依存の型   | `DatabaseService`, `never`（依存なし） |

この型シグネチャを見るだけで、「この処理は何を返すか」「どんなエラーが起きるか」「何に依存しているか」がすべてわかる。これが「予測可能なコード」の正体である。

## はじめてのEffect

### インストール

```bash
npm install effect
```

### 基本的な使い方

Effectは「遅延評価」される。つまり、Effectを作成しただけでは処理は実行されない。明示的に実行関数を呼ぶまで、処理の「設計図」として存在する。

```typescript
import { Effect } from 'effect'

// Effectを作成（まだ実行されない）
const program = Effect.succeed(42)

// 実行する
const result = Effect.runSync(program)
console.log(result) // 42
```

### 非同期処理をEffectに変換

`Effect.tryPromise`を使うと、Promiseを返す関数をEffectに変換できる。

```typescript
import { Effect } from 'effect'

type Todo = {
  userId: number
  id: number
  title: string
  completed: boolean
}

// 非同期処理をEffectに変換
const fetchTodo = (id: number): Effect.Effect<Todo, Error> =>
  Effect.tryPromise({
    try: async () => {
      const response = await fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`)
      }
      return (await response.json()) as Todo
    },
    catch: (reason) => new Error(`Fetch failed: ${reason}`),
  })

// 実行
const main = async () => {
  const todo = await Effect.runPromise(fetchTodo(1))
  console.log(todo.title)
}

main()
```

## 型付きエラーハンドリング

Effectの真価が発揮されるのは、エラーハンドリングである。エラーごとに型を定義し、すべてのエラーケースを網羅的に処理できる。

```typescript
import { Effect, pipe } from 'effect'

// エラー型を定義
class NotFoundError {
  readonly _tag = 'NotFoundError' as const
  constructor(readonly id: number) {}
}

class NetworkError {
  readonly _tag = 'NetworkError' as const
  constructor(readonly message: string) {}
}

type Todo = {
  id: number
  title: string
  completed: boolean
}

// 発生しうるエラーが型に現れる
const fetchTodo = (id: number): Effect.Effect<Todo, NotFoundError | NetworkError> =>
  Effect.tryPromise({
    try: async () => {
      const response = await fetch(`/api/todos/${id}`)
      if (response.status === 404) {
        throw new NotFoundError(id)
      }
      if (!response.ok) {
        throw new NetworkError(`HTTP ${response.status}`)
      }
      return (await response.json()) as Todo
    },
    catch: (error) => {
      if (error instanceof NotFoundError) return error
      return new NetworkError(String(error))
    },
  })

// catchTagsで各エラーを処理
const program = pipe(
  fetchTodo(1),
  Effect.catchTags({
    NotFoundError: ({ id }) => Effect.succeed({ id, title: 'Default', completed: false }),
    NetworkError: ({ message }) => Effect.fail(new Error(`Network issue: ${message}`)),
  }),
)
```

```mermaid
flowchart TB
    A["fetchTodo(1)"] --> B{成功?}
    B -->|Yes| C["Todo取得成功"]
    B -->|No| D{エラー種別}
    D -->|NotFoundError| E["デフォルト値を返す"]
    D -->|NetworkError| F["エラーを伝播"]

    style A fill:#4a90d9,color:#fff
    style C fill:#2ecc71,color:#fff
    style E fill:#f39c12,color:#fff
    style F fill:#e74c3c,color:#fff
```

`_tag`プロパティによるタグ付きユニオンを使うことで、TypeScriptのコンパイラが「すべてのエラーケースを処理したか」をチェックしてくれる。エラーの処理漏れがあればコンパイルエラーになる。

## pipeによる関数合成

`pipe`を使うと、複数の処理を連結してデータを流すように記述できる。

```typescript
import { Effect, pipe } from 'effect'

const program = pipe(
  // 1. Todoを取得
  fetchTodo(1),
  // 2. タイトルを抽出
  Effect.map((todo) => todo.title),
  // 3. 大文字に変換
  Effect.map((title) => title.toUpperCase()),
  // 4. ログ出力
  Effect.tap((title) => Effect.sync(() => console.log(title))),
)
```

各ステップが独立した関数になっているため、テストや再利用がしやすい。

## 依存性注入（Context）

Effectでは、外部サービスへの依存を`Context`として明示できる。これにより、テスト時にモックを注入するのが容易になる。

```typescript
import { Effect, Context, Layer } from 'effect'

// サービスの型を定義
type UserService = {
  getUser: (id: string) => Effect.Effect<User, NotFoundError>
}

// Contextタグを作成
const UserService = Context.GenericTag<UserService>('UserService')

// サービスを使う関数
const getUserName = (id: string): Effect.Effect<string, NotFoundError, UserService> =>
  pipe(
    UserService,
    Effect.flatMap((service) => service.getUser(id)),
    Effect.map((user) => user.name),
  )

// 実際の実装
const UserServiceLive = Layer.succeed(UserService, {
  getUser: (id) =>
    Effect.tryPromise({
      try: () => fetch(`/api/users/${id}`).then((r) => r.json()),
      catch: () => new NotFoundError(id),
    }),
})

// テスト用のモック実装
const UserServiceMock = Layer.succeed(UserService, {
  getUser: (id) => Effect.succeed({ id, name: 'Test User', email: 'test@example.com' }),
})

// 実行時に依存を注入
const program = pipe(
  getUserName('user-123'),
  Effect.provide(UserServiceLive), // または UserServiceMock
)
```

`getUserName`関数のシグネチャを見ると、第3型パラメータに`UserService`があることから、「この関数はUserServiceに依存している」ことが一目でわかる。

## Effectを導入するメリットまとめ

```mermaid
flowchart TB
    subgraph Before["従来のTypeScript"]
        B1["try-catchのネスト"]
        B2["エラー型がunknown"]
        B3["依存関係が不透明"]
    end

    subgraph After["Effectを使用"]
        A1["フラットな<br/>エラーハンドリング"]
        A2["エラー型が明示"]
        A3["依存関係が型に現れる"]
    end

    B1 --> A1
    B2 --> A2
    B3 --> A3

    style B1 fill:#e74c3c,color:#fff
    style B2 fill:#e74c3c,color:#fff
    style B3 fill:#e74c3c,color:#fff
    style A1 fill:#2ecc71,color:#fff
    style A2 fill:#2ecc71,color:#fff
    style A3 fill:#2ecc71,color:#fff
```

| 観点           | 従来のTypeScript   | Effect                |
| -------------- | ------------------ | --------------------- |
| エラーの型     | `unknown`          | 明示的な型            |
| 処理漏れの検出 | 実行時             | コンパイル時          |
| 依存関係       | コード内部に隠れる | 型シグネチャに現れる  |
| テスタビリティ | モック注入が複雑   | Layerで簡単に差し替え |

## 学習リソース

Effectは機能が豊富なため、学習曲線はやや急である。しかし、TypeScriptを学んだときと同様に、基本を押さえれば段階的に使いこなせるようになる。

まずは以下の順序で学ぶことをおすすめする。

1. Effect型の基本（Success, Error, Requirements）
2. `Effect.tryPromise`による非同期処理の変換
3. `pipe`と`Effect.map`/`Effect.flatMap`
4. `catchTags`によるエラーハンドリング
5. `Context`と`Layer`による依存性注入

## まとめ

Effectは「シグネチャを見るだけで、その処理が何を返し、どんなエラーが起き、何に依存しているかがわかる」という予測可能なコードを実現するライブラリである。

従来の`try-catch`では実行時まで見えなかったエラーを、コンパイル時に検出できる。依存関係も型システムで管理できるため、テストしやすく保守性の高いコードが書ける。

すべてのプロジェクトに必要というわけではないが、エラーハンドリングが複雑になりがちな中〜大規模アプリケーションでは、導入を検討する価値がある。

## 参考

- [Effect - 公式サイト](https://effect.website/)
- [Effect Documentation - Getting Started](https://effect.website/docs/getting-started/introduction)
- [Effectを使って予測可能なコードを書こう - Zenn](https://zenn.dev/hololab/articles/e6f8828faac5ca)
- [エラーや非同期処理をより安全に扱うためのTypeScriptライブラリ Effect-TS - azukiazusa.dev](https://azukiazusa.dev/blog/typescript-library-for-safer-error-handling-and-async-operations-effect-ts/)
- [effect-ts かなり使えそう - Zenn](https://zenn.dev/shuent/articles/7d3ab3e1a204b3)
- [Effect GitHub Repository](https://github.com/Effect-TS/effect)
