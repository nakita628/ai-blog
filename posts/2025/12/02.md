---
date: 2025-12-02
title: SWRでthrow Errorしない型安全なエラーハンドリング
description: SWRを使用する際に、throw Errorせずに型安全にエラーをハンドリングする方法を解説します。Orvalが生成するコードスタイルを参考に、シンプルな実装例を紹介します。
tags:
  - swr
  - react
  - typescript
  - error-handling
  - orval
prev:
  text: 'Better Auth：TypeScript向け認証フレームワークの決定版'
  link: '/posts/2025/12/01'
next:
  text: 'Hono RPC parseResponseとSWRでシンプルなデータフェッチ'
  link: '/posts/2025/12/04'
---

# SWRでthrow Errorしない型安全なエラーハンドリング

[SWR](https://swr.vercel.app/ja)でエラーハンドリングする際、`throw Error`せずに型安全に処理する方法を解説する。[Orval](https://orval.dev/)が生成するコードスタイルを参考にしている。

## Orvalスタイルのポイント

Orvalが生成するコードは、以下の特徴を持つ。

- **throwしない**：fetcherはエラー時も`{ data, status, headers }`を返す
- **ステータスごとの型定義**：200、401、500などそれぞれに型を定義
- **Union型で合成**：全レスポンス型をUnionにまとめる

## 型定義

まず、APIのレスポンス型を定義する。

```ts
// 成功時のレスポンス
type GetUser200 = {
  id: string
  name: string
  email: string
}

// 認証エラー
type GetUser401 = {
  message: 'Unauthorized'
}

// サーバーエラー
type GetUser500 = {
  message: string
}
```

次に、ステータスコードごとのレスポンス型を定義する。

```ts
type GetUserResponse200 = {
  data: GetUser200
  status: 200
}

type GetUserResponse401 = {
  data: GetUser401
  status: 401
}

type GetUserResponse500 = {
  data: GetUser500
  status: 500
}

// Union型で合成
type GetUserResponseComposite = GetUserResponse200 | GetUserResponse401 | GetUserResponse500

// 最終的なレスポンス型
type GetUserResponse = GetUserResponseComposite & {
  headers: Headers
}
```

## fetcher

throwしないfetcherを実装する。

```ts
const getUser = async (): Promise<GetUserResponse> => {
  const res = await fetch('/api/user')
  const data = await res.json()

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as GetUserResponse
}
```

ポイントは、**成功時もエラー時も同じ構造で返す**ことである。throwは一切しない。

## カスタムフック

SWRを使ったカスタムフックを作成する。

```ts
import useSWR from 'swr'

const useGetUser = () => {
  const { data, isLoading, mutate } = useSWR('/api/user', getUser)

  return {
    data,
    isLoading,
    mutate,
  }
}
```

## コンポーネントでの使用

`status`で分岐してレスポンスを処理する。

```tsx
function UserProfile() {
  const { data, isLoading } = useGetUser()

  if (isLoading) return <div>loading...</div>
  if (!data) return null

  // ステータスで分岐
  if (data.status === 200) {
    return <div>hello {data.data.name}!</div>
  }

  if (data.status === 401) {
    return <div>{data.data.message}</div>
  }

  if (data.status === 500) {
    return <div>サーバーエラー: {data.data.message}</div>
  }

  return null
}
```

TypeScriptは`data.status`の値に応じて`data.data`の型を自動で絞り込む。

## switch文での分岐

switch文を使えば、より明確に分岐できる。

```tsx
function UserProfile() {
  const { data, isLoading } = useGetUser()

  if (isLoading || !data) return <div>loading...</div>

  switch (data.status) {
    case 200:
      return <div>hello {data.data.name}!</div>
    case 401:
      return <div>{data.data.message}</div>
    case 500:
      return <div>サーバーエラー: {data.data.message}</div>
  }
}
```

## まとめ

- **throwしない**：fetcherは`{ data, status, headers }`を返す
- **ステータスごとの型**：200、401、500それぞれに型を定義
- **Union型で合成**：`GetUserResponse200 | GetUserResponse401 | GetUserResponse500`
- **statusで分岐**：TypeScriptが型を自動で絞り込む

[Orval](https://orval.dev/)を使えば、OpenAPI仕様からこの形式のコードを自動生成できる。
