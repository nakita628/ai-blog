---
date: 2025-07-20
title: neverthrowで実現する型安全なエラーハンドリング：Result型の実践的活用法
description: TypeScriptでの堅牢なエラーハンドリングを実現するneverthrowライブラリの使い方を解説。Result型を活用した関数型プログラミングアプローチから、実践的なユースケースまで、型安全なエラー処理の実装パターンを紹介します。
tags:
  - typescript
  - error-handling
  - functional-programming
  - neverthrow
  - type-safety
  - node-js
prev:
  text: 'RemixでTypeScriptベースのフルスタック開発：効率的なバックエンド実装ガイド'
  link: '/posts/2025/07/19'
next:
  text: 'ORPCで実現する型安全なAPI開発：実践的な実装パターンとベストプラクティス'
  link: '/posts/2025/07/21'
---

# neverthrowで実現する型安全なエラーハンドリング：Result型の実践的活用法

TypeScriptでエラー処理を行う際、try-catchによる例外処理は必ずしも最適な選択とは限りません。neverthrowは、関数型プログラミングのアプローチを取り入れ、Result型を通じて型安全なエラーハンドリングを実現するライブラリです。本記事では、neverthrowの基本的な使い方から実践的なユースケースまでを解説します。

## Result型の基本概念

neverthrowの核となるのは`Result`型です。これは成功（`ok`）または失敗（`err`）のいずれかの状態を表現します。

```ts
import { Result, ok, err } from 'neverthrow'

function divide(a: number, b: number): Result<number, string> {
  if (b === 0) {
    return err('Division by zero')
  }
  return ok(a / b)
}

const result = divide(10, 2)
const errorResult = divide(10, 0)

result.match(
  (value) => console.log(`Result: ${value}`),
  (error) => console.log(`Error: ${error}`),
)
```

## 高度なエラー型の定義

複雑なアプリケーションでは、より詳細なエラー型の定義が必要になります。

```ts
type ValidationError = {
  type: 'VALIDATION'
  field: string
  message: string
}

type NetworkError = {
  type: 'NETWORK'
  statusCode: number
  message: string
}

type AppError = ValidationError | NetworkError

function validateUser(user: { name: string; email: string }): Result<true, ValidationError> {
  if (user.name.length < 2) {
    return err({
      type: 'VALIDATION',
      field: 'name',
      message: 'Name must be at least 2 characters',
    })
  }
  if (!user.email.includes('@')) {
    return err({
      type: 'VALIDATION',
      field: 'email',
      message: 'Invalid email format',
    })
  }
  return ok(true)
}
```

## 結果の連鎖と変換

neverthrowは、`map`、`mapErr`、`andThen`などのメソッドを提供し、Result型の値を柔軟に変換できます。

```ts
interface User {
  id: string
  email: string
}

function findUser(email: string): Result<User, NetworkError> {
  // データベース検索のシミュレーション
  return ok({ id: '123', email })
}

function sendEmail(user: User): Result<string, NetworkError> {
  // メール送信のシミュレーション
  return ok(`Email sent to ${user.email}`)
}

// 結果の連鎖
const emailResult = findUser('user@example.com')
  .andThen((user) => sendEmail(user))
  .map((message) => `Success: ${message}`)
  .mapErr((error) => ({
    ...error,
    message: `Failed: ${error.message}`,
  }))
```

## 複数の結果の組み合わせ

`combine`や`combineWithAllErrors`を使用して、複数のResult型の値を組み合わせることができます。

```ts
interface UserProfile {
  userId: string
  preferences: string[]
  settings: Record<string, boolean>
}

function fetchUserProfile(userId: string): Result<UserProfile, NetworkError> {
  // ...
  return ok({
    userId,
    preferences: ['dark-mode', 'notifications-on'],
    settings: { newsletter: true },
  })
}

function validateSettings(settings: Record<string, boolean>): Result<true, ValidationError> {
  // ...
  return ok(true)
}

function validatePreferences(prefs: string[]): Result<true, ValidationError> {
  // ...
  return ok(true)
}

// 複数の検証を組み合わせる
function validateUserProfile(profile: UserProfile): Result<true, ValidationError> {
  return Result.combine([
    validateSettings(profile.settings),
    validatePreferences(profile.preferences),
  ]).map(() => true)
}
```

## 非同期処理との統合

neverthrowは非同期処理もサポートしており、`ResultAsync`型を提供します。

```ts
import { ResultAsync } from 'neverthrow'

function fetchData(url: string): ResultAsync<Response, NetworkError> {
  return ResultAsync.fromPromise(fetch(url), (error) => ({
    type: 'NETWORK',
    statusCode: 500,
    message: error instanceof Error ? error.message : 'Unknown error',
  }))
}

function parseResponse(response: Response): ResultAsync<User[], ValidationError> {
  return ResultAsync.fromPromise(response.json(), () => ({
    type: 'VALIDATION',
    field: 'response',
    message: 'Invalid JSON response',
  }))
}

// 非同期処理の連鎖
const usersResult = fetchData('https://api.example.com/users')
  .andThen(parseResponse)
  .map((users) => users.map((user) => user.email))
```

## パフォーマンスとエラーロギング

neverthrowを使用する際は、エラーのロギングと監視も重要です。

```ts
interface ErrorLogger {
  log(error: AppError): void
}

class ProductionErrorLogger implements ErrorLogger {
  log(error: AppError): void {
    // エラー監視サービスへの送信
    const errorContext = {
      timestamp: new Date().toISOString(),
      errorType: error.type,
      details: error,
    }
    console.error('Error occurred:', errorContext)
  }
}

// エラーロギングの統合
function handleResult<T>(result: Result<T, AppError>, logger: ErrorLogger): T | null {
  return result.match(
    (value) => value,
    (error) => {
      logger.log(error)
      return null
    },
  )
}
```

## まとめ

neverthrowを使用したエラーハンドリングの利点は以下の通りです：

- 型安全性の向上
- 明示的なエラー処理
- 関数型プログラミングパターンの活用
- 可読性の高いエラーフロー
- 非同期処理との統合のしやすさ

特に大規模なアプリケーションでは、neverthrowによる体系的なエラーハンドリングが、コードの保守性と信頼性を大きく向上させます。try-catchに頼るアプローチと比べて、より予測可能で堅牢なエラー処理が実現できます。
