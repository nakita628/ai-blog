---
date: 2025-07-29
title: 有名アルゴリズム徹底解説：TypeScriptで学ぶ基本と実践
description: ソート・探索・グラフ・動的計画法など、代表的なアルゴリズムをTypeScript例とともに解説。アルゴリズムの特徴や使いどころ、実装のポイントをわかりやすく紹介します。
tags:
  - algorithm
  - typescript
  - sort
  - search
  - graph
  - dynamic-programming
  - web-development
prev:
  text: 'Terraformの基本とベストプラクティス：インフラ自動化のはじめ方'
  link: '/posts/2025/07/28'
next:
  text: 'Pythonで学ぶバリデーションの基本と実践：型・値・構造チェックのベストプラクティス'
  link: '/posts/2025/07/30'
---

# 有名アルゴリズム徹底解説：TypeScriptで学ぶ基本と実践

アルゴリズムはプログラミングの基礎力を高める上で欠かせません。本記事では、代表的なアルゴリズムをTypeScriptの実装例とともに解説します。

## ソートアルゴリズム

### バブルソート

- 隣り合う要素を比較しながら繰り返し並べ替えるシンプルな手法

```ts
function bubbleSort(arr: number[]): number[] {
  const a = [...arr]
  for (let i = 0; i < a.length; i++) {
    for (let j = 0; j < a.length - i - 1; j++) {
      if (a[j] > a[j + 1]) {
        ;[a[j], a[j + 1]] = [a[j + 1], a[j]]
      }
    }
  }
  return a
}
```

### クイックソート

- 分割統治法で高速に並べ替える代表的なアルゴリズム

```ts
function quickSort(arr: number[]): number[] {
  if (arr.length <= 1) return arr
  const pivot = arr[0]
  const left = arr.slice(1).filter((x) => x < pivot)
  const right = arr.slice(1).filter((x) => x >= pivot)
  return [...quickSort(left), pivot, ...quickSort(right)]
}
```

## 探索アルゴリズム

### 二分探索

- ソート済み配列から高速に値を探す

```ts
function binarySearch(arr: number[], target: number): number {
  let left = 0,
    right = arr.length - 1
  while (left <= right) {
    const mid = Math.floor((left + right) / 2)
    if (arr[mid] === target) return mid
    if (arr[mid] < target) left = mid + 1
    else right = mid - 1
  }
  return -1
}
```

## グラフアルゴリズム

### 幅優先探索（BFS）

- 最短経路や到達判定に使われる基本手法

```ts
function bfs(graph: Record<string, string[]>, start: string): string[] {
  const visited = new Set<string>()
  const queue: string[] = [start]
  const order: string[] = []
  while (queue.length) {
    const node = queue.shift()!
    if (!visited.has(node)) {
      visited.add(node)
      order.push(node)
      queue.push(...(graph[node] || []))
    }
  }
  return order
}
```

## 動的計画法

### フィボナッチ数列（メモ化）

- 再帰＋メモ化で計算量を削減

```ts
function fib(n: number, memo: Record<number, number> = {}): number {
  if (n <= 1) return n
  if (memo[n] !== undefined) return memo[n]
  return (memo[n] = fib(n - 1, memo) + fib(n - 2, memo))
}
```

## まとめ

- ソート・探索・グラフ・動的計画法はアルゴリズム学習の基本
- TypeScriptで実装することで型安全かつ実践的に理解できる
- 問題解決力やパフォーマンス改善の基礎として役立つので、ぜひ手を動かして学んでみましょう
