---
date: 2025-07-15
title: SQLiteとExpress + TypeScriptで作る堅牢な2段階認証システム
description: SQLiteデータベースとExpress.js + TypeScriptを組み合わせた、スケーラブルな2段階認証システムの実装方法を解説。Prisma ORMを活用したデータモデリングから、セキュアなセッション管理まで、ベストプラクティスに基づいた実装手順を紹介します。
tags:
  - typescript
  - express
  - sqlite
  - authentication
  - prisma
  - two-factor-auth
  - security
prev:
  text: 'Express.jsで実装する2段階認証：セキュアな認証システムの構築手順'
  link: '/posts/2025/07/14'
next:
  text: '2段階認証フローの可視化：MermaidとTypeScriptで理解する認証プロセス'
  link: '/posts/2025/07/16'
---

# SQLiteとExpress + TypeScriptで作る堅牢な2段階認証システム

SQLiteは軽量で高性能なデータベースとして人気があり、特に開発環境やプロトタイピングに適しています。本記事では、Express.jsとTypeScript、そしてSQLiteを組み合わせて、セキュアな2段階認証システムを構築する方法を解説します。

## データベース設計とPrismaの活用

### スキーマ設計

```ts
// schema.prisma
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                 String    @id @default(cuid())
  email              String    @unique
  password           String
  twoFactorSecret    String?
  twoFactorEnabled   Boolean   @default(false)
  backupCodes        String?   // JSON形式で保存
  sessions           Session[]
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
}
```

## アプリケーションの基本設定

### 1. 必要なパッケージの設定

```ts
import express from 'express'
import { PrismaClient } from '@prisma/client'
import * as bcrypt from 'bcrypt'
import * as speakeasy from 'speakeasy'
import * as QRCode from 'qrcode'
import session from 'express-session'
import SQLiteStore from 'connect-sqlite3'

const prisma = new PrismaClient()
const SQLiteStoreSession = SQLiteStore(session)

const app = express()

// セッション設定
app.use(
  session({
    store: new SQLiteStoreSession({
      db: 'sessions.db',
      dir: './db',
    }),
    secret: process.env.SESSION_SECRET!,
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: process.env.NODE_ENV === 'production',
      httpOnly: true,
      maxAge: 24 * 60 * 60 * 1000, // 24時間
    },
  }),
)
```

### 2. ユーザー認証の基本クラス

```ts
class AuthService {
  private readonly prisma: PrismaClient

  constructor() {
    this.prisma = new PrismaClient()
  }

  // ユーザー登録
  async register(email: string, password: string): Promise<User> {
    const hashedPassword = await bcrypt.hash(password, 12)

    return this.prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        twoFactorEnabled: false,
      },
    })
  }

  // 2FA有効化
  async setupTwoFactor(userId: string): Promise<{ secret: string; qrCode: string }> {
    const secret = speakeasy.generateSecret({
      name: `MyApp:${userId}`,
    })

    const backupCodes = this.generateBackupCodes()

    await this.prisma.user.update({
      where: { id: userId },
      data: {
        twoFactorSecret: secret.base32,
        backupCodes: JSON.stringify(backupCodes),
      },
    })

    const qrCode = await QRCode.toDataURL(secret.otpauth_url!)

    return { secret: secret.base32, qrCode }
  }
}
```

## セキュアなセッション管理

### 1. セッションストアの最適化

SQLiteを使用したセッション管理では、以下の点に注意が必要です：

- 定期的なセッションクリーンアップ
- セッションテーブルのインデックス最適化
- トランザクション管理

```ts
class SessionManager {
  // 期限切れセッションの削除
  async cleanupExpiredSessions(): Promise<void> {
    await prisma.session.deleteMany({
      where: {
        expiresAt: {
          lt: new Date(),
        },
      },
    })
  }

  // セッションの作成
  async createSession(userId: string): Promise<Session> {
    const token = crypto.randomBytes(32).toString('hex')
    const expiresAt = new Date()
    expiresAt.setHours(expiresAt.getHours() + 24)

    return prisma.session.create({
      data: {
        userId,
        token,
        expiresAt,
      },
    })
  }
}
```

### 2. 2FAの検証フロー

```ts
interface TwoFactorVerification {
  verify(token: string): Promise<boolean>
  validateBackupCode(code: string): Promise<boolean>
  rotateSecret(): Promise<void>
}

class TwoFactorService implements TwoFactorVerification {
  async verify(userId: string, token: string): Promise<boolean> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
    })

    if (!user?.twoFactorSecret) {
      return false
    }

    return speakeasy.totp.verify({
      secret: user.twoFactorSecret,
      encoding: 'base32',
      token,
      window: 1,
    })
  }
}
```

## エラーハンドリングとセキュリティ強化

### 1. カスタムエラー定義

```ts
class AuthenticationError extends Error {
  constructor(
    public readonly code: string,
    message: string,
    public readonly status: number = 401,
  ) {
    super(message)
    this.name = 'AuthenticationError'
  }
}
```

### 2. レート制限の実装

SQLiteを使用したレート制限の実装例：

```ts
class RateLimiter {
  async checkLimit(ip: string, action: string): Promise<boolean> {
    const key = `${ip}:${action}`
    const now = Date.now()
    const windowMs = 15 * 60 * 1000 // 15分

    const attempts = await prisma.$queryRaw`
      SELECT COUNT(*) as count
      FROM rate_limit
      WHERE key = ${key}
      AND timestamp > ${now - windowMs}
    `

    return attempts[0].count < 5
  }
}
```

## パフォーマンス最適化

### 1. インデックス設計

SQLiteでの効率的なインデックス設計：

```sql
-- migrations/001_create_indices.sql
CREATE INDEX idx_sessions_token ON sessions(token);
CREATE INDEX idx_sessions_expires ON sessions(expiresAt);
CREATE INDEX idx_users_email ON users(email);
```

### 2. クエリ最適化

Prismaを使用した効率的なクエリ例：

```ts
// BADパターン
const user = await prisma.user.findUnique({
  where: { id: userId },
  include: { sessions: true },
})

// GOODパターン
const user = await prisma.user.findUnique({
  where: { id: userId },
  select: {
    id: true,
    email: true,
    twoFactorEnabled: true,
    sessions: {
      select: {
        id: true,
        expiresAt: true,
      },
    },
  },
})
```

## まとめ

SQLiteとExpress + TypeScriptを組み合わせた2段階認証システムは、適切な設計と実装により、セキュアで高性能なソリューションとなります。特に重要なポイントは：

- Prisma ORMを活用した型安全なデータアクセス
- SQLiteの特性を活かしたセッション管理
- 適切なインデックス設計によるパフォーマンス最適化

これらの要素を組み合わせることで、開発環境から小規模な本番環境まで、幅広い用途に対応できる認証システムを構築することができます。
