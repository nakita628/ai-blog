---
date: 2025-07-17
title: PrismaとNeverthrowで実現する型安全な関数型プログラミング
description: PrismaとNeverthrowライブラリを組み合わせて、型安全で堅牢なデータアクセス層を実装する方法を解説。Result型を活用したエラーハンドリングと、関数型プログラミングのベストプラクティスを実践的に学びます。
tags:
    - typescript
    - prisma
    - functional-programming
    - neverthrow
    - error-handling
    - orm
    - type-safety
prev:
    text: "2段階認証フローの可視化：MermaidとTypeScriptで理解する認証プロセス"
    link: "/posts/2025/07/16"
next:
    text: "ReactでのCookie管理：セキュアで効率的な実装パターン"
    link: "/posts/2025/07/18"
---

# PrismaとNeverthrowで実現する型安全な関数型プログラミング

関数型プログラミングの考え方を取り入れることで、より堅牢で保守性の高いコードを書くことができます。本記事では、PrismaとNeverthrowライブラリを組み合わせて、型安全で関数型アプローチに基づいたデータアクセス層を実装する方法を解説します。

## Neverthrowによる Result型の活用

まず、基本的なResult型の使い方を見ていきましょう。

```ts
import { Result, ok, err } from 'neverthrow';
import { PrismaClient, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

type UserError = 
  | { type: 'NOT_FOUND'; message: string }
  | { type: 'VALIDATION_ERROR'; message: string }
  | { type: 'DATABASE_ERROR'; message: string };

interface UserRepository {
  findById(id: string): Promise<Result<User, UserError>>;
  create(data: UserCreateInput): Promise<Result<User, UserError>>;
  update(id: string, data: UserUpdateInput): Promise<Result<User, UserError>>;
}
```

## リポジトリパターンの実装

Prismaの操作をResult型でラップし、エラーハンドリングを統一的に行います。

```ts
class UserRepositoryImpl implements UserRepository {
  constructor(private readonly prisma: PrismaClient) {}

  async findById(id: string): Promise<Result<User, UserError>> {
    try {
      const user = await this.prisma.user.findUnique({
        where: { id }
      });

      if (!user) {
        return err({ 
          type: 'NOT_FOUND', 
          message: `User with id ${id} not found`
        });
      }

      return ok(user);
    } catch (error) {
      return err({
        type: 'DATABASE_ERROR',
        message: error instanceof Error ? error.message : 'Unknown error occurred'
      });
    }
  }

  async create(data: UserCreateInput): Promise<Result<User, UserError>> {
    const validationResult = validateUserInput(data);
    if (validationResult.isErr()) {
      return err({
        type: 'VALIDATION_ERROR',
        message: validationResult.error.message
      });
    }

    try {
      const user = await this.prisma.user.create({
        data: validationResult.value
      });
      return ok(user);
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          return err({
            type: 'VALIDATION_ERROR',
            message: 'Email already exists'
          });
        }
      }
      return err({
        type: 'DATABASE_ERROR',
        message: 'Failed to create user'
      });
    }
  }
}
```

## サービス層での活用

Result型を使用することで、エラーハンドリングがより明示的になります。

```ts
class UserService {
  constructor(private readonly userRepo: UserRepository) {}

  async updateUserProfile(
    userId: string,
    profile: UserProfileUpdate
  ): Promise<Result<User, UserError>> {
    return (await this.userRepo.findById(userId))
      .andThen(user => 
        this.validateProfileUpdate(user, profile)
          .mapErr(error => ({
            type: 'VALIDATION_ERROR',
            message: error
          }))
      )
      .asyncAndThen(async validProfile =>
        this.userRepo.update(userId, {
          profile: validProfile
        })
      );
  }

  private validateProfileUpdate(
    user: User,
    profile: UserProfileUpdate
  ): Result<ValidatedProfile, string> {
    return validateProfile(profile)
      .andThen(validated => 
        checkProfileUpdatePermissions(user, validated)
      );
  }
}
```

## トランザクション処理の改善

Prismaのトランザクションも関数型アプローチで扱うことができます。

```ts
class TransactionManager {
  async withTransaction<T>(
    operation: (tx: Prisma.TransactionClient) => Promise<Result<T, UserError>>
  ): Promise<Result<T, UserError>> {
    try {
      return await prisma.$transaction(async tx => {
        const result = await operation(tx);
        if (result.isErr()) {
          throw result.error;
        }
        return result;
      });
    } catch (error) {
      if (error instanceof UserError) {
        return err(error);
      }
      return err({
        type: 'DATABASE_ERROR',
        message: 'Transaction failed'
      });
    }
  }
}
```

## エラーハンドリングのベストプラクティス

1. **型の階層化**
   - 具体的なエラー型の定義
   - ドメイン固有のエラー分類
   - エラーメッセージの標準化

```ts
type DomainError = {
  type: string;
  message: string;
  context?: Record<string, unknown>;
};

class ValidationError implements DomainError {
  readonly type = 'VALIDATION_ERROR';
  constructor(
    readonly message: string,
    readonly context?: Record<string, unknown>
  ) {}
}
```

2. **Result型の組み合わせ**

```ts
async function complexOperation(): Promise<Result<Output, DomainError>> {
  return (await stepOne())
    .andThen(resultOne => stepTwo(resultOne))
    .map(resultTwo => transformOutput(resultTwo))
    .mapErr(error => enrichError(error));
}
```

## テスト容易性の向上

関数型アプローチを採用することで、テストがより書きやすくなります。

```ts
describe('UserService', () => {
  it('should handle user update successfully', async () => {
    const mockRepo = {
      findById: jest.fn().mockResolvedValue(ok(mockUser)),
      update: jest.fn().mockResolvedValue(ok(updatedMockUser))
    };

    const service = new UserService(mockRepo);
    const result = await service.updateUserProfile(userId, mockProfile);

    expect(result.isOk()).toBe(true);
    expect(result._unsafeUnwrap()).toEqual(updatedMockUser);
  });

  it('should handle user not found error', async () => {
    const mockRepo = {
      findById: jest.fn().mockResolvedValue(err({
        type: 'NOT_FOUND',
        message: 'User not found'
      }))
    };

    const service = new UserService(mockRepo);
    const result = await service.updateUserProfile(userId, mockProfile);

    expect(result.isErr()).toBe(true);
    expect(result._unsafeUnwrapErr().type).toBe('NOT_FOUND');
  });
});
```

## まとめ

PrismaとNeverthrowを組み合わせることで、以下のメリットが得られます：

- 型安全なエラーハンドリング
- 関数型プログラミングの恩恵
- テストの容易性向上
- コードの可読性と保守性の向上

これらの手法を適切に活用することで、より堅牢で信頼性の高いアプリケーションを構築することができます。
