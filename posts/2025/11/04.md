---
date: 2025-11-04
title: SWR初心者完全ガイド：Reactデータ取得を劇的に改善する実践的な使い方
description: React初心者向けにSWRの使い方を詳しく解説。基本的な使い方から、エラーハンドリング、キャッシュ管理、再検証、楽観的更新まで、豊富な具体例とコードサンプルで実践的に学べる完全ガイド。
tags:
  - swr
  - react
  - data-fetching
  - caching
  - hooks
  - typescript
  - frontend
  - beginner
prev:
  text: 'よく使うLinuxコマンド完全ガイド：日常業務を効率化する実践的なコマンド集'
  link: '/posts/2025/11/01'
next:
  text: 'Piniaを使うとVue.jsアプリの状態管理が何倍も楽になる理由'
  link: '/posts/2025/11/06'
---

# SWR初心者完全ガイド：Reactデータ取得を劇的に改善する実践的な使い方

Reactアプリケーションでデータを取得する際、`useState`と`useEffect`を使った従来の方法では、ローディング状態の管理やエラーハンドリング、キャッシュの管理などが複雑になりがちです。SWR（stale-while-revalidate）を使うことで、これらの問題を簡単に解決できます。この記事では、React初心者の方にも分かりやすく、SWRの基本的な使い方から実践的なパターンまで、豊富な具体例と共に詳しく解説します。

## SWRとは

SWRは、Vercelが開発したReact用のデータフェッチングライブラリです。`stale-while-revalidate`という戦略を採用し、キャッシュされたデータを即座に表示しながら、バックグラウンドで最新のデータを取得します。

### SWRを使うメリット

- **コード量の削減**: ローディング状態やエラーハンドリングのコードが大幅に減る
- **自動的なキャッシュ管理**: 同じデータの重複リクエストを自動的に防ぐ
- **自動再検証**: フォーカス時やネットワーク再接続時に自動的に最新データを取得
- **型安全性**: TypeScriptと完全に統合されている
- **シンプルなAPI**: 1行のコードでデータ取得ができる

## インストール

まず、SWRをプロジェクトにインストールします。

```bash
npm install swr
# または
yarn add swr
# または
pnpm add swr
```

## 基本的な使い方

### 最小限の例

最もシンプルな使い方から始めましょう。

```typescript
import useSWR from 'swr';

// fetcher関数を定義
const fetcher = (url: string) => fetch(url).then(res => res.json());

function UserProfile({ userId }: { userId: number }) {
  const { data, error, isLoading } = useSWR(
    `/api/users/${userId}`,
    fetcher
  );

  if (isLoading) return <div>読み込み中...</div>;
  if (error) return <div>エラーが発生しました</div>;
  if (!data) return <div>データがありません</div>;

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
    </div>
  );
}
```

### コードの説明

1. **`useSWR`**: SWRのメインフックです
2. **第一引数**: データを取得するためのキー（通常はURL）
3. **第二引数**: データを取得する関数（fetcher）
4. **戻り値**: `{ data, error, isLoading }` というオブジェクト

## 実際のプロジェクトでの使い方

### 1. fetcher関数の共通化

複数のコンポーネントで同じfetcherを使う場合、共通のfetcher関数を作成します。

```typescript
// utils/fetcher.ts
export const fetcher = async (url: string) => {
  const response = await fetch(url);

  if (!response.ok) {
    throw new Error('データの取得に失敗しました');
  }

  return response.json();
};

// components/UserProfile.tsx
import useSWR from 'swr';
import { fetcher } from '../utils/fetcher';

function UserProfile({ userId }: { userId: number }) {
  const { data, error, isLoading } = useSWR(
    `/api/users/${userId}`,
    fetcher
  );

  if (isLoading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error.message}</div>;
  if (!data) return null;

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
      <p>登録日: {new Date(data.createdAt).toLocaleDateString()}</p>
    </div>
  );
}
```

### 2. グローバル設定

アプリケーション全体でSWRの設定を統一するには、`SWRConfig`を使います。

```typescript
// App.tsx
import { SWRConfig } from 'swr';
import { fetcher } from './utils/fetcher';

function App() {
  return (
    <SWRConfig
      value={{
        fetcher,
        revalidateOnFocus: true,      // ウィンドウフォーカス時に再検証
        revalidateOnReconnect: true,  // ネットワーク再接続時に再検証
        refreshInterval: 0,           // 自動再検証の間隔（0 = 無効）
      }}
    >
      <UserProfile userId={1} />
    </SWRConfig>
  );
}
```

これにより、各コンポーネントで`fetcher`を指定する必要がなくなります。

```typescript
// fetcherを指定しなくてもOK
const { data } = useSWR('/api/users/1')
```

## エラーハンドリング

SWRでは、エラーを簡単に処理できます。

### 基本的なエラーハンドリング

```typescript
function UserProfile({ userId }: { userId: number }) {
  const { data, error, isLoading } = useSWR(
    `/api/users/${userId}`,
    fetcher
  );

  if (error) {
    return (
      <div className="error">
        <h2>エラーが発生しました</h2>
        <p>{error.message}</p>
        <button onClick={() => window.location.reload()}>
          再読み込み
        </button>
      </div>
    );
  }

  if (isLoading) return <div>読み込み中...</div>;
  if (!data) return null;

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
    </div>
  );
}
```

### カスタムエラーハンドラー

グローバルにエラーハンドリングを設定することもできます。

```typescript
// App.tsx
import { SWRConfig } from 'swr';

function App() {
  return (
    <SWRConfig
      value={{
        fetcher,
        onError: (error, key) => {
          console.error('SWR Error:', error, key);

          // エラー通知サービスに送信（例: Sentry）
          // errorTrackingService.log(error);

          // 特定のエラーに対して特別な処理
          if (error.status === 401) {
            // 認証エラー: ログイン画面にリダイレクト
            window.location.href = '/login';
          }
        },
      }}
    >
      <UserProfile userId={1} />
    </SWRConfig>
  );
}
```

## 条件付きフェッチ

特定の条件下でのみデータを取得したい場合、キーを`null`に設定します。

```typescript
function UserProfile({ userId }: { userId: number | null }) {
  // userIdがnullの場合はフェッチしない
  const { data, error, isLoading } = useSWR(
    userId ? `/api/users/${userId}` : null,
    fetcher
  );

  if (!userId) return <div>ユーザーIDを選択してください</div>;
  if (isLoading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error.message}</div>;
  if (!data) return null;

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
    </div>
  );
}
```

## データの更新（ミューテーション）

SWRでデータを更新するには、`mutate`関数を使います。

### 基本的な更新

```typescript
import useSWR, { mutate } from 'swr';

function UserProfile({ userId }: { userId: number }) {
  const { data, error, isLoading } = useSWR(
    `/api/users/${userId}`,
    fetcher
  );

  const updateUser = async (newName: string) => {
    // APIを呼び出して更新
    await fetch(`/api/users/${userId}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: newName }),
    });

    // キャッシュを更新
    mutate(`/api/users/${userId}`);
  };

  if (isLoading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error.message}</div>;
  if (!data) return null;

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
      <button onClick={() => updateUser('新しい名前')}>
        名前を更新
      </button>
    </div>
  );
}
```

### 楽観的更新（Optimistic Update）

ユーザー体験を向上させるために、楽観的更新を使うことができます。

```typescript
function UserProfile({ userId }: { userId: number }) {
  const { data, mutate } = useSWR(
    `/api/users/${userId}`,
    fetcher
  );

  const updateUser = async (newName: string) => {
    // 楽観的更新: UIを即座に更新
    const optimisticData = { ...data, name: newName };
    mutate(optimisticData, false); // false = 再検証しない

    try {
      // APIを呼び出して更新
      const response = await fetch(`/api/users/${userId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: newName }),
      });

      const updatedUser = await response.json();

      // サーバーからの最新データで更新
      mutate(updatedUser);
    } catch (error) {
      // エラー時は元のデータに戻す
      mutate(data);
      alert('更新に失敗しました');
    }
  };

  if (!data) return <div>読み込み中...</div>;

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
      <button onClick={() => updateUser('新しい名前')}>
        名前を更新
      </button>
    </div>
  );
}
```

## ページネーション

リストデータをページネーションで表示する場合。

```typescript
import { useState } from 'react';
import useSWR from 'swr';

function UserList() {
  const [page, setPage] = useState(1);
  const { data, error, isLoading } = useSWR(
    `/api/users?page=${page}&limit=10`,
    fetcher
  );

  if (isLoading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error.message}</div>;
  if (!data) return null;

  return (
    <div>
      <ul>
        {data.users.map((user: any) => (
          <li key={user.id}>
            {user.name} - {user.email}
          </li>
        ))}
      </ul>

      <div>
        <button
          onClick={() => setPage(page - 1)}
          disabled={page === 1}
        >
          前へ
        </button>
        <span>ページ {page} / {data.totalPages}</span>
        <button
          onClick={() => setPage(page + 1)}
          disabled={page >= data.totalPages}
        >
          次へ
        </button>
      </div>
    </div>
  );
}
```

## 無限スクロール

`useSWRInfinite`を使うと、無限スクロールを実装できます。

```typescript
import useSWRInfinite from 'swr/infinite';

function InfiniteUserList() {
  const {
    data,
    error,
    isLoading,
    size,
    setSize,
    isValidating
  } = useSWRInfinite(
    (index) => `/api/users?page=${index + 1}&limit=10`,
    fetcher
  );

  const users = data ? data.flat() : [];
  const isLoadingMore = isLoading || (size > 0 && data && typeof data[size - 1] === 'undefined');
  const isEmpty = data?.[0]?.length === 0;
  const isReachingEnd = isEmpty || (data && data[data.length - 1]?.length < 10);

  if (error) return <div>エラー: {error.message}</div>;

  return (
    <div>
      <ul>
        {users.map((user: any) => (
          <li key={user.id}>
            {user.name} - {user.email}
          </li>
        ))}
      </ul>

      <button
        onClick={() => setSize(size + 1)}
        disabled={isLoadingMore || isReachingEnd}
      >
        {isLoadingMore
          ? '読み込み中...'
          : isReachingEnd
          ? 'これ以上ありません'
          : 'もっと見る'}
      </button>
    </div>
  );
}
```

## 複数のデータを同時に取得

複数のデータを同時に取得する場合。

```typescript
function Dashboard() {
  const { data: user } = useSWR('/api/user', fetcher);
  const { data: posts } = useSWR('/api/posts', fetcher);
  const { data: notifications } = useSWR('/api/notifications', fetcher);

  if (!user || !posts || !notifications) {
    return <div>読み込み中...</div>;
  }

  return (
    <div>
      <h1>こんにちは、{user.name}さん</h1>
      <div>
        <h2>投稿 ({posts.length})</h2>
        {posts.map((post: any) => (
          <div key={post.id}>{post.title}</div>
        ))}
      </div>
      <div>
        <h2>通知 ({notifications.length})</h2>
        {notifications.map((notification: any) => (
          <div key={notification.id}>{notification.message}</div>
        ))}
      </div>
    </div>
  );
}
```

## 自動再検証の設定

SWRは自動的にデータを再検証しますが、設定をカスタマイズできます。

```typescript
function UserProfile({ userId }: { userId: number }) {
  const { data, error, isLoading } = useSWR(
    `/api/users/${userId}`,
    fetcher,
    {
      revalidateOnFocus: true,        // フォーカス時に再検証
      revalidateOnReconnect: true,     // 再接続時に再検証
      refreshInterval: 5000,            // 5秒ごとに自動再検証
      dedupingInterval: 2000,          // 2秒以内の重複リクエストを無視
      revalidateIfStale: true,         // 古いデータがある場合に再検証
    }
  );

  if (isLoading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error.message}</div>;
  if (!data) return null;

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
    </div>
  );
}
```

## エラーのリトライ

SWRは自動的にエラーをリトライしますが、カスタマイズできます。

```typescript
function UserProfile({ userId }: { userId: number }) {
  const { data, error, isLoading } = useSWR(
    `/api/users/${userId}`,
    fetcher,
    {
      onErrorRetry: (error, key, config, revalidate, { retryCount }) => {
        // 404エラーはリトライしない
        if (error.status === 404) return;

        // 最大5回までリトライ
        if (retryCount >= 5) return;

        // 指数バックオフでリトライ（5秒、10秒、20秒...）
        setTimeout(() => revalidate({ retryCount }), 5000 * 2 ** retryCount);
      }
    }
  );

  if (isLoading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error.message}</div>;
  if (!data) return null;

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
    </div>
  );
}
```

## TypeScriptでの型安全性

SWRはTypeScriptと完全に統合されています。

```typescript
// types/user.ts
export interface User {
  id: number;
  name: string;
  email: string;
  createdAt: string;
}

// components/UserProfile.tsx
import useSWR from 'swr';
import type { User } from '../types/user';

function UserProfile({ userId }: { userId: number }) {
  const { data, error, isLoading } = useSWR<User>(
    `/api/users/${userId}`,
    fetcher
  );

  if (isLoading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error.message}</div>;
  if (!data) return null;

  // dataは自動的にUser型として推論される
  return (
    <div>
      <h1>{data.name}</h1>  {/* 型安全 */}
      <p>{data.email}</p>    {/* 型安全 */}
    </div>
  );
}
```

## 実践的な例：タスク管理アプリ

実際のアプリケーション例として、タスク管理アプリを作成します。

```typescript
// types/task.ts
export interface Task {
  id: number;
  title: string;
  completed: boolean;
  createdAt: string;
}

// components/TaskList.tsx
import useSWR from 'swr';
import type { Task } from '../types/task';

function TaskList() {
  const { data: tasks, error, isLoading, mutate } = useSWR<Task[]>(
    '/api/tasks',
    fetcher
  );

  const toggleTask = async (taskId: number) => {
    const task = tasks?.find(t => t.id === taskId);
    if (!task) return;

    // 楽観的更新
    const updatedTasks = tasks.map(t =>
      t.id === taskId ? { ...t, completed: !t.completed } : t
    );
    mutate(updatedTasks, false);

    try {
      await fetch(`/api/tasks/${taskId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ completed: !task.completed }),
      });
      mutate(); // 再検証
    } catch (error) {
      mutate(tasks); // エラー時は元に戻す
      alert('更新に失敗しました');
    }
  };

  const addTask = async (title: string) => {
    try {
      const response = await fetch('/api/tasks', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title }),
      });
      const newTask = await response.json();

      // 新しいタスクをリストに追加
      mutate([...tasks || [], newTask]);
    } catch (error) {
      alert('タスクの追加に失敗しました');
    }
  };

  if (isLoading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error.message}</div>;

  return (
    <div>
      <h1>タスク一覧</h1>
      <ul>
        {tasks?.map(task => (
          <li key={task.id}>
            <input
              type="checkbox"
              checked={task.completed}
              onChange={() => toggleTask(task.id)}
            />
            <span style={{
              textDecoration: task.completed ? 'line-through' : 'none'
            }}>
              {task.title}
            </span>
          </li>
        ))}
      </ul>
      <button onClick={() => addTask('新しいタスク')}>
        タスクを追加
      </button>
    </div>
  );
}
```

## よくある質問（FAQ）

### Q: SWRとReact Queryの違いは？

A: SWRは軽量でシンプル、React Queryはより多機能です。小規模なプロジェクトにはSWR、大規模なプロジェクトにはReact Queryが適しています。

### Q: キャッシュはどのように管理されますか？

A: SWRは自動的にキー（URL）ごとにキャッシュを管理します。同じキーで複数のコンポーネントがデータを取得しても、1回のリクエストだけが実行されます。

### Q: サーバーサイドレンダリング（SSR）で使えますか？

A: はい、Next.jsなどでSSRと組み合わせて使えます。`fallbackData`を使って初期データを渡すことができます。

```typescript
// Next.jsでの例
export async function getServerSideProps() {
  const user = await fetchUser();
  return {
    props: {
      fallback: {
        '/api/user': user
      }
    }
  };
}

function App({ fallback }: { fallback: any }) {
  return (
    <SWRConfig value={{ fallback }}>
      <UserProfile />
    </SWRConfig>
  );
}
```

## まとめ

SWRを使うことで、Reactアプリケーションでのデータ取得が劇的に簡単になります。

**主なポイント:**

- **シンプルなAPI**: 1行のコードでデータ取得が可能
- **自動キャッシュ**: 重複リクエストを自動的に防ぐ
- **自動再検証**: フォーカス時や再接続時に自動的に最新データを取得
- **楽観的更新**: ユーザー体験を向上させる楽観的更新が簡単に実装できる
- **型安全性**: TypeScriptと完全に統合されている

**初心者向けの学習ステップ:**

1. 基本的な`useSWR`の使い方を覚える
2. エラーハンドリングを実装する
3. データの更新（ミューテーション）を学ぶ
4. 楽観的更新を実装する
5. ページネーションや無限スクロールを実装する

これらの手法を組み合わせることで、堅牢で使いやすいReactアプリケーションを構築できます。SWRは、モダンなReact開発において不可欠なライブラリの一つです。

**参考資料:**

- [SWR公式ドキュメント](https://swr.vercel.app/ja)
