---
date: 2025-11-07
title: フロントエンドでCookieを扱うベストプラクティス
description: フロントエンド開発でCookieを安全かつ効率的に扱うための実践的なガイド。セキュリティ対策、SameSite属性、HttpOnly、Secureフラグ、JavaScriptでの操作、ライブラリの選び方まで、実際のコード例と共に詳しく解説します。
tags:
  - cookie
  - frontend
  - javascript
  - typescript
  - security
  - best-practices
  - web-development
prev:
  text: 'Piniaを使うとVue.jsアプリの状態管理が何倍も楽になる理由'
  link: '/posts/2025/11/06'
next:
  text: 'TypeScriptのOpenAPIエコシステム完全ガイド：型安全なAPI開発の実践'
  link: '/posts/2025/11/09'
---

# フロントエンドでCookieを扱うベストプラクティス

Webアプリケーション開発において、Cookieは認証情報の保持やユーザー設定の保存など、重要な役割を担っています。しかし、適切に扱わないとセキュリティリスクやパフォーマンスの問題を引き起こす可能性があります。

この記事では、フロントエンドでCookieを安全かつ効率的に扱うためのベストプラクティスを、実際のコード例と共に詳しく解説します。

## Cookieの基本

Cookieは、サーバーからクライアント（ブラウザ）に送信され、ブラウザに保存される小さなデータです。同じドメインへの後続のリクエストで自動的に送信されます。

### Cookieの構造

Cookieは以下の形式で設定されます：

```
name=value; expires=date; path=/; domain=example.com; secure; httponly; samesite=strict
```

各属性の意味：

- **name=value**: Cookieの名前と値
- **expires**: 有効期限（GMT形式）
- **max-age**: 有効期限（秒単位）
- **path**: Cookieが送信されるパス
- **domain**: Cookieが送信されるドメイン
- **secure**: HTTPS接続でのみ送信
- **httponly**: JavaScriptからアクセス不可
- **samesite**: クロスサイトリクエストでの送信制御

## JavaScriptでCookieを操作する

### 基本的な読み書き

ブラウザの`document.cookie`を使用してCookieを操作できます。

```typescript
// Cookieを設定する関数
function setCookie(name: string, value: string, days: number = 7): void {
  const expires = new Date()
  expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000)

  document.cookie = `${name}=${value}; expires=${expires.toUTCString()}; path=/`
}

// Cookieを取得する関数
function getCookie(name: string): string | null {
  const nameEQ = `${name}=`
  const cookies = document.cookie.split(';')

  for (let cookie of cookies) {
    cookie = cookie.trim()
    if (cookie.indexOf(nameEQ) === 0) {
      return cookie.substring(nameEQ.length)
    }
  }

  return null
}

// Cookieを削除する関数
function deleteCookie(name: string): void {
  document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`
}
```

### より堅牢な実装

型安全性とエラーハンドリングを考慮した実装例：

```typescript
type CookieOptions = {
  expires?: number // 日数
  path?: string
  domain?: string
  secure?: boolean
  sameSite?: 'strict' | 'lax' | 'none'
}

class CookieManager {
  /**
   * Cookieを設定する
   */
  static set(name: string, value: string, options: CookieOptions = {}): void {
    const { expires = 7, path = '/', domain, secure = true, sameSite = 'lax' } = options

    let cookieString = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`

    // 有効期限
    if (expires) {
      const date = new Date()
      date.setTime(date.getTime() + expires * 24 * 60 * 60 * 1000)
      cookieString += `; expires=${date.toUTCString()}`
    }

    // パス
    cookieString += `; path=${path}`

    // ドメイン
    if (domain) {
      cookieString += `; domain=${domain}`
    }

    // Secure
    if (secure) {
      cookieString += '; secure'
    }

    // SameSite
    cookieString += `; samesite=${sameSite}`

    document.cookie = cookieString
  }

  /**
   * Cookieを取得する
   */
  static get(name: string): string | null {
    const nameEQ = `${encodeURIComponent(name)}=`
    const cookies = document.cookie.split(';')

    for (let cookie of cookies) {
      cookie = cookie.trim()
      if (cookie.indexOf(nameEQ) === 0) {
        return decodeURIComponent(cookie.substring(nameEQ.length))
      }
    }

    return null
  }

  /**
   * Cookieを削除する
   */
  static delete(name: string, path: string = '/'): void {
    document.cookie = `${encodeURIComponent(name)}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path};`
  }

  /**
   * すべてのCookieを取得する
   */
  static getAll(): Record<string, string> {
    const cookies: Record<string, string> = {}
    const cookieArray = document.cookie.split(';')

    for (let cookie of cookieArray) {
      cookie = cookie.trim()
      const [name, value] = cookie.split('=')
      if (name && value) {
        cookies[decodeURIComponent(name)] = decodeURIComponent(value)
      }
    }

    return cookies
  }
}

// 使用例
CookieManager.set('theme', 'dark', { expires: 30, sameSite: 'lax' })
const theme = CookieManager.get('theme')
CookieManager.delete('theme')
```

## セキュリティのベストプラクティス

### 1. HttpOnlyフラグの使用

機密情報（認証トークンなど）を含むCookieには、必ず`HttpOnly`フラグを設定します。これにより、JavaScriptからのアクセスを防ぎ、XSS攻撃のリスクを軽減できます。

**重要**: `HttpOnly`フラグはサーバー側でのみ設定可能です。フロントエンドのJavaScriptからは設定できません。

```typescript
// ❌ 悪い例: HttpOnlyはJavaScriptから設定できない
// document.cookie = "token=abc123; httponly"; // これは無視される

// ✅ 良い例: サーバー側で設定
// Set-Cookie: token=abc123; HttpOnly; Secure; SameSite=Strict
```

### 2. Secureフラグの使用

HTTPS接続でのみCookieを送信するように`Secure`フラグを設定します。これにより、中間者攻撃（MITM）のリスクを軽減できます。

```typescript
// ✅ 本番環境では常にSecureを使用
CookieManager.set('sessionId', 'abc123', {
  secure: true, // HTTPS接続でのみ送信
  sameSite: 'strict',
})
```

### 3. SameSite属性の適切な設定

`SameSite`属性は、クロスサイトリクエストでのCookie送信を制御します。

- **`strict`**: クロスサイトリクエストでは一切送信しない（最も安全）
- **`lax`**: GETリクエストのみクロスサイトで送信（推奨）
- **`none`**: すべてのクロスサイトリクエストで送信（`Secure`必須）

```typescript
// ✅ 認証トークンにはstrictを使用
CookieManager.set('authToken', 'token123', {
  secure: true,
  sameSite: 'strict',
})

// ✅ ユーザー設定などにはlaxを使用
CookieManager.set('theme', 'dark', {
  sameSite: 'lax',
})
```

### 4. 値のエンコード

Cookieの値には特殊文字が含まれる可能性があるため、必ずエンコード/デコードを行います。

```typescript
// ✅ エンコード/デコードを実装
const value = encodeURIComponent('value with spaces & special chars')
const decoded = decodeURIComponent(value)
```

### 5. サイズ制限の考慮

Cookieは1つあたり最大4KB、ドメインごとに合計で約4KB〜10KBの制限があります。大きなデータを保存する場合は、`localStorage`や`sessionStorage`を検討します。

```typescript
// ❌ 悪い例: 大きなデータをCookieに保存
CookieManager.set('largeData', JSON.stringify(hugeObject)) // サイズ制限に引っかかる可能性

// ✅ 良い例: 大きなデータはlocalStorageに保存
localStorage.setItem('largeData', JSON.stringify(hugeObject))
```

## 実践的な使用例

### 認証トークンの管理

```typescript
class AuthTokenManager {
  private static readonly TOKEN_KEY = 'auth_token'
  private static readonly REFRESH_TOKEN_KEY = 'refresh_token'

  /**
   * 認証トークンを保存（サーバー側でHttpOnlyとして設定される想定）
   * フロントエンドでは一時的なトークンやリフレッシュトークンのみを扱う
   */
  static saveRefreshToken(token: string): void {
    CookieManager.set(this.REFRESH_TOKEN_KEY, token, {
      expires: 30, // 30日間有効
      secure: true,
      sameSite: 'strict',
    })
  }

  static getRefreshToken(): string | null {
    return CookieManager.get(this.REFRESH_TOKEN_KEY)
  }

  static clearTokens(): void {
    CookieManager.delete(this.REFRESH_TOKEN_KEY)
  }
}
```

### ユーザー設定の保存

```typescript
type UserPreferences = {
  theme: 'light' | 'dark'
  language: 'ja' | 'en'
  notifications: boolean
}

class UserPreferencesManager {
  private static readonly PREFERENCES_KEY = 'user_preferences'

  static save(preferences: UserPreferences): void {
    const json = JSON.stringify(preferences)
    CookieManager.set(this.PREFERENCES_KEY, json, {
      expires: 365, // 1年間有効
      sameSite: 'lax',
    })
  }

  static load(): UserPreferences | null {
    const json = CookieManager.get(this.PREFERENCES_KEY)
    if (!json) return null

    try {
      return JSON.parse(json) as UserPreferences
    } catch {
      return null
    }
  }

  static update(updates: Partial<UserPreferences>): void {
    const current = this.load() || this.getDefaults()
    this.save({ ...current, ...updates })
  }

  private static getDefaults(): UserPreferences {
    return {
      theme: 'light',
      language: 'ja',
      notifications: true,
    }
  }
}
```

### セッション管理

```typescript
class SessionManager {
  private static readonly SESSION_KEY = 'session_id'

  static createSession(sessionId: string): void {
    CookieManager.set(this.SESSION_KEY, sessionId, {
      expires: 1, // 1日間有効
      secure: true,
      sameSite: 'strict',
    })
  }

  static getSessionId(): string | null {
    return CookieManager.get(this.SESSION_KEY)
  }

  static clearSession(): void {
    CookieManager.delete(this.SESSION_KEY)
  }

  static isSessionActive(): boolean {
    return this.getSessionId() !== null
  }
}
```

## ライブラリの活用

### js-cookie

人気のあるCookie操作ライブラリです。

```bash
npm install js-cookie
npm install --save-dev @types/js-cookie
```

```typescript
import Cookies from 'js-cookie'

// Cookieを設定
Cookies.set('name', 'value', {
  expires: 7,
  secure: true,
  sameSite: 'strict',
})

// Cookieを取得
const value = Cookies.get('name')

// Cookieを削除
Cookies.remove('name')
```

### universal-cookie

サーバーサイドレンダリング（SSR）にも対応したライブラリです。

```bash
npm install universal-cookie
```

```typescript
import Cookies from 'universal-cookie'

const cookies = new Cookies()

// Cookieを設定
cookies.set('name', 'value', {
  path: '/',
  expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
  secure: true,
  sameSite: 'strict',
})

// Cookieを取得
const value = cookies.get('name')

// Cookieを削除
cookies.remove('name')
```

## よくある問題と解決策

### 問題1: Cookieが設定されない

**原因**: `Secure`フラグが設定されているのに、HTTP接続でアクセスしている。

**解決策**: 開発環境では`Secure`を`false`に設定するか、HTTPSを使用する。

```typescript
const isProduction = process.env.NODE_ENV === 'production'

CookieManager.set('token', 'value', {
  secure: isProduction, // 本番環境のみSecure
  sameSite: 'lax',
})
```

### 問題2: クロスドメインでCookieが送信されない

**原因**: `SameSite`が`strict`に設定されている。

**解決策**: クロスドメインで送信が必要な場合は`lax`または`none`を使用（`none`の場合は`Secure`必須）。

```typescript
// クロスドメインで送信が必要な場合
CookieManager.set('token', 'value', {
  secure: true, // noneを使用する場合は必須
  sameSite: 'none', // クロスドメインで送信
})
```

### 問題3: Cookieの値が正しく取得できない

**原因**: エンコード/デコードが適切に行われていない。

**解決策**: 必ず`encodeURIComponent`と`decodeURIComponent`を使用する。

```typescript
// ✅ 正しい実装
const value = encodeURIComponent('value with spaces')
CookieManager.set('key', value)
const retrieved = CookieManager.get('key') // 自動的にデコードされる
```

## まとめ

フロントエンドでCookieを扱う際のベストプラクティスをまとめます：

### セキュリティ

- **機密情報にはHttpOnlyを使用**: サーバー側で設定し、JavaScriptからアクセス不可にする
- **Secureフラグを設定**: HTTPS接続でのみ送信する
- **SameSite属性を適切に設定**: クロスサイトリクエストのリスクを軽減
- **値のエンコード**: 特殊文字を適切に処理する

### 実装

- **型安全性**: TypeScriptで型定義を行う
- **エラーハンドリング**: 不正な値や取得失敗に対応する
- **サイズ制限**: 大きなデータは`localStorage`を使用する
- **ライブラリの活用**: `js-cookie`や`universal-cookie`を検討する

### 運用

- **環境ごとの設定**: 開発環境と本番環境で適切に設定を切り替える
- **有効期限の管理**: 適切な有効期限を設定する
- **定期的なクリーンアップ**: 不要なCookieを削除する

これらのベストプラクティスを守ることで、セキュアで保守性の高いCookie管理を実現できます。
