---
date: 2025-11-17
title: Effect入門：TypeScriptの次世代ライブラリで型安全な非同期処理を実現
description: EffectはTypeScriptの次世代ライブラリで、型安全な非同期処理、エラーハンドリング、合成処理を実現します。初心者にもわかりやすく、Effectの基本概念、合成処理、実践的なコード例を詳しく解説します。
tags:
  - typescript
  - effect
  - functional-programming
  - type-safety
  - error-handling
  - async-programming
  - composition
prev:
  text: 'ogenでOpenAPIからGoコードを生成：型安全で高速なAPI開発の実践'
  link: '/posts/2025/11/11'
next:
  text: 'Ruby on Rails と OpenAPI で構築する型安全な REST API'
  link: '/posts/2025/11/22'
---

# Effect入門：TypeScriptの次世代ライブラリで型安全な非同期処理を実現

[Effect](https://effect.website/)は、TypeScriptの次世代ライブラリとして注目を集めています。型安全な非同期処理、エラーハンドリング、合成処理を実現し、複雑なアプリケーションをシンプルに保つことができます。この記事では、Effectの基本概念から実践的な使い方まで、初心者にもわかりやすく解説します。

## Effectとは

Effectは、TypeScriptで関数型プログラミングの原則を活用し、型安全で合成可能なコードを書くためのライブラリです。非同期処理、エラーハンドリング、依存性注入、リトライ、トレーシングなどを統一的に扱えます。

### Effectの主な特徴

- **型安全性**: TypeScriptの型システムを最大限に活用
- **合成可能性**: 小さな処理を組み合わせて複雑な処理を構築
- **エラーハンドリング**: エラーを値として扱い、型安全に処理
- **非同期処理**: Promiseよりも強力で型安全な非同期処理
- **依存性注入**: テスト容易性を高める依存性注入の仕組み
- **トレーシング**: 組み込みのトレーシングとメトリクス

## インストール

Effectはnpmからインストールできます。

```bash
npm install effect
```

## 基本的な使い方

### Hello, World!

Effectの基本的な使い方から始めましょう。

```typescript
import { Console, Effect } from 'effect'

const main = Console.log('Hello, World!')

Effect.runSync(main)
```

このコードは、`Console.log`で「Hello, World!」を出力するEffectを作成し、`Effect.runSync`で実行します。

### Effectの基本構造

Effectは、以下の3つの型パラメータを持ちます：

```typescript
Effect<A, E, R>
```

- `A`: 成功時の値の型（Success Value）
- `E`: エラーの型（Error）
- `R`: 必要な依存関係の型（Requirements）

### 基本的なEffectの作成

```typescript
import { Effect } from 'effect'

// 成功するEffect
const success = Effect.succeed(42)

// エラーを返すEffect
const failure = Effect.fail('Something went wrong')

// 非同期処理を表すEffect
const async = Effect.promise(() => fetch('https://api.example.com/data').then((res) => res.json()))
```

## 合成処理（Composition）

Effectの最大の強みは、小さな処理を組み合わせて複雑な処理を構築できることです。

### pipeによる合成

`pipe`関数を使用して、複数のEffectを順番に実行できます。

```typescript
import { Effect, pipe } from 'effect'

const add = (a: number) => (b: number) => a + b
const multiply = (a: number) => (b: number) => a * b

const result = pipe(
  Effect.succeed(10),
  Effect.map(add(5)), // 10 + 5 = 15
  Effect.map(multiply(2)), // 15 * 2 = 30
)

Effect.runSync(result) // 30
```

### 複数のEffectを順番に実行

`Effect.andThen`（または`flatMap`）を使用して、前のEffectの結果を使って次のEffectを実行できます。

```typescript
import { Effect, pipe } from 'effect'

const getUser = (id: number) => Effect.succeed({ id, name: `User ${id}` })

const getProfile = (user: { id: number; name: string }) =>
  Effect.succeed({ ...user, email: `${user.name}@example.com` })

const result = pipe(getUser(1), Effect.andThen(getProfile))

Effect.runSync(result) // { id: 1, name: 'User 1', email: 'User 1@example.com' }
```

### エラーハンドリングを含む合成

Effectでは、エラーも型安全に扱えます。

```typescript
import { Effect, pipe } from 'effect'

type UserError = { _tag: 'UserNotFound'; id: number } | { _tag: 'InvalidEmail'; email: string }

const getUser = (id: number): Effect.Effect<{ id: number; name: string }, UserError> => {
  if (id <= 0) {
    return Effect.fail({ _tag: 'UserNotFound', id })
  }
  return Effect.succeed({ id, name: `User ${id}` })
}

const validateEmail = (user: {
  id: number
  name: string
}): Effect.Effect<{ id: number; name: string; email: string }, UserError> => {
  const email = `${user.name}@example.com`
  if (!email.includes('@')) {
    return Effect.fail({ _tag: 'InvalidEmail', email })
  }
  return Effect.succeed({ ...user, email })
}

const result = pipe(
  getUser(1),
  Effect.andThen(validateEmail),
  Effect.catchAll((error) => {
    switch (error._tag) {
      case 'UserNotFound':
        return Effect.succeed({ id: error.id, name: 'Guest', email: 'guest@example.com' })
      case 'InvalidEmail':
        return Effect.fail(error)
    }
  }),
)

Effect.runSync(result)
```

## 非同期処理

Effectは、非同期処理を型安全に扱えます。

### HTTPリクエストの例

```typescript
import { Effect, pipe } from 'effect'

type HttpError = { _tag: 'NetworkError'; message: string } | { _tag: 'ParseError'; message: string }

const fetchUser = (id: number): Effect.Effect<{ id: number; name: string }, HttpError> =>
  Effect.gen(function* (_) {
    const response = yield* _(
      Effect.tryPromise({
        try: () => fetch(`https://api.example.com/users/${id}`),
        catch: (error) => ({ _tag: 'NetworkError' as const, message: String(error) }),
      }),
    )

    if (!response.ok) {
      return yield* _(
        Effect.fail({ _tag: 'NetworkError' as const, message: `HTTP ${response.status}` }),
      )
    }

    const data = yield* _(
      Effect.tryPromise({
        try: () => response.json(),
        catch: (error) => ({ _tag: 'ParseError' as const, message: String(error) }),
      }),
    )

    return data as { id: number; name: string }
  })

// 使用例
const program = pipe(
  fetchUser(1),
  Effect.tap((user) => Effect.log(`User: ${user.name}`)),
)

Effect.runPromise(program)
```

### Effect.genによる合成

`Effect.gen`を使用すると、非同期処理を同期的に書くような感覚で記述できます。

```typescript
import { Effect } from 'effect'

const program = Effect.gen(function* (_) {
  const user1 = yield* _(fetchUser(1))
  const user2 = yield* _(fetchUser(2))
  const user3 = yield* _(fetchUser(3))

  return [user1, user2, user3]
})

Effect.runPromise(program)
```

## エラーハンドリング

Effectでは、エラーを型安全に扱えます。

### エラーの型定義

```typescript
import { Effect } from 'effect'

type AppError =
  | { _tag: 'ValidationError'; field: string; message: string }
  | { _tag: 'NotFoundError'; resource: string }
  | { _tag: 'ServerError'; code: number }

const validateUser = (name: string): Effect.Effect<string, AppError> => {
  if (name.length < 3) {
    return Effect.fail({
      _tag: 'ValidationError',
      field: 'name',
      message: 'Name must be at least 3 characters',
    })
  }
  return Effect.succeed(name)
}
```

### エラーの回復

`Effect.catchAll`や`Effect.catchTag`を使用して、エラーを処理できます。

```typescript
import { Effect, pipe } from 'effect'

const program = pipe(
  validateUser('ab'),
  Effect.catchTag('ValidationError', (error) =>
    Effect.log(`Validation failed: ${error.message}`).pipe(
      Effect.andThen(() => Effect.succeed('Guest')),
    ),
  ),
  Effect.catchTag('NotFoundError', (error) =>
    Effect.fail({ _tag: 'ServerError' as const, code: 404 }),
  ),
)
```

## リトライとタイムアウト

Effectには、リトライとタイムアウトの機能が組み込まれています。

### リトライ

```typescript
import { Effect, Schedule } from 'effect'

const fetchWithRetry = pipe(
  fetchUser(1),
  Effect.retry(Schedule.exponential('100 millis').pipe(Schedule.compose(Schedule.recurs(3)))),
)
```

### タイムアウト

```typescript
import { Effect } from 'effect'

const fetchWithTimeout = pipe(fetchUser(1), Effect.timeout('5 seconds'))
```

## 依存性注入

Effectでは、依存性注入を型安全に実現できます。

### サービスの定義

```typescript
import { Context, Effect } from 'effect'

interface UserService {
  getUser: (id: number) => Effect.Effect<{ id: number; name: string }, never>
}

const UserService = Context.GenericTag<UserService>('UserService')
```

### サービスの実装

```typescript
const UserServiceLive = UserService.of({
  getUser: (id: number) => Effect.succeed({ id, name: `User ${id}` }),
})
```

### サービスの使用

```typescript
const program = Effect.gen(function* (_) {
  const userService = yield* _(UserService)
  return yield* _(userService.getUser(1))
})

const result = Effect.provide(program, UserServiceLive)
Effect.runSync(result)
```

## 実践的な例：APIクライアント

Effectを使用して、型安全なAPIクライアントを実装してみましょう。

```typescript
import { Effect, pipe } from 'effect'

type ApiError =
  | { _tag: 'NetworkError'; message: string }
  | { _tag: 'ParseError'; message: string }
  | { _tag: 'NotFoundError'; resource: string }

const apiClient = {
  get: <T>(url: string): Effect.Effect<T, ApiError> =>
    Effect.gen(function* (_) {
      const response = yield* _(
        Effect.tryPromise({
          try: () => fetch(url),
          catch: (error) => ({ _tag: 'NetworkError' as const, message: String(error) }),
        }),
      )

      if (response.status === 404) {
        return yield* _(Effect.fail({ _tag: 'NotFoundError' as const, resource: url }))
      }

      if (!response.ok) {
        return yield* _(
          Effect.fail({
            _tag: 'NetworkError' as const,
            message: `HTTP ${response.status}`,
          }),
        )
      }

      const data = yield* _(
        Effect.tryPromise({
          try: () => response.json(),
          catch: (error) => ({ _tag: 'ParseError' as const, message: String(error) }),
        }),
      )

      return data as T
    }),
}

// 使用例
const getUser = (id: number) => apiClient.get<{ id: number; name: string }>(`/api/users/${id}`)

const program = pipe(
  getUser(1),
  Effect.tap((user) => Effect.log(`User: ${user.name}`)),
  Effect.catchTag('NotFoundError', () => Effect.succeed({ id: 0, name: 'Guest' })),
)

Effect.runPromise(program)
```

## まとめ

Effectは、TypeScriptで型安全な非同期処理、エラーハンドリング、合成処理を実現する強力なライブラリです。

**主要なポイント**:

- **型安全性**: TypeScriptの型システムを最大限に活用
- **合成処理**: 小さな処理を組み合わせて複雑な処理を構築
- **エラーハンドリング**: エラーを値として扱い、型安全に処理
- **非同期処理**: Promiseよりも強力で型安全な非同期処理
- **依存性注入**: テスト容易性を高める依存性注入の仕組み
- **リトライとタイムアウト**: 組み込みのリトライとタイムアウト機能

**実装時の推奨事項**:

- 小さなEffectから始めて、徐々に複雑な処理を構築
- エラー型を明確に定義し、型安全にエラーハンドリング
- `Effect.gen`を使用して、読みやすいコードを書く
- 依存性注入を活用して、テスト容易性を高める

Effectを活用することで、型安全で保守性の高いコードを書くことができます。詳細は[Effect公式サイト](https://effect.website/)を参照してください。
