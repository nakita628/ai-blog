---
date: 2025-11-10
title: APIリクエストを型安全にする実践的手法：TypeScriptで堅牢なAPI通信を実現
description: TypeScriptでAPIリクエストを型安全に実装する手法を詳しく解説。型定義の自動生成、ランタイムバリデーション、エラーハンドリング、openapi-typescript、zod、tRPCなど、実践的なコード例と共に型安全なAPI通信の実装方法を紹介します。
tags:
  - typescript
  - type-safety
  - api-development
  - openapi
  - zod
  - trpc
  - rest-api
prev:
  text: 'TypeScriptのOpenAPIエコシステム完全ガイド：型安全なAPI開発の実践'
  link: '/posts/2025/11/09'
next:
  text: 'ogenでOpenAPIからGoコードを生成：型安全で高速なAPI開発の実践'
  link: '/posts/2025/11/11'
---

# APIリクエストを型安全にする実践的手法：TypeScriptで堅牢なAPI通信を実現

API通信において型安全性を確保することは、バグの早期発見と開発効率の向上に不可欠です。TypeScriptを活用することで、コンパイル時に型チェックを行い、ランタイムエラーを防ぐことができます。この記事では、APIリクエストを型安全に実装するための実践的な手法を、コード例と共に詳しく解説します。

## なぜ型安全なAPI通信が重要なのか

型安全なAPI通信を実現することで、以下のメリットが得られます。

- **コンパイル時のエラー検出**: リクエスト/レスポンスの型ミスを早期に発見
- **IDEの補完機能**: 自動補完により開発効率が向上
- **リファクタリングの安全性**: API仕様変更時の影響範囲を明確化
- **ドキュメントとしての役割**: 型定義がAPI仕様のドキュメントになる

## 1. OpenAPI定義から型を自動生成

OpenAPI定義からTypeScriptの型定義を自動生成することで、API仕様と型定義を一元管理できます。

### openapi-typescriptの使用

```typescript
// schema.yamlから型定義を生成
// npx openapi-typescript schema.yaml -o types/api.d.ts

import type { paths } from './types/api'

type GetUsersResponse = paths['/users']['get']['responses']['200']['content']['application/json']
type CreateUserRequest = paths['/users']['post']['requestBody']['content']['application/json']
type CreateUserResponse = paths['/users']['post']['responses']['201']['content']['application/json']

class ApiClient {
  private baseUrl: string

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl
  }

  async getUsers(): Promise<GetUsersResponse> {
    const response = await fetch(`${this.baseUrl}/users`)
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    return await response.json()
  }

  async createUser(data: CreateUserRequest): Promise<CreateUserResponse> {
    const response = await fetch(`${this.baseUrl}/users`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    })
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    return await response.json()
  }
}
```

### openapi-fetchとの組み合わせ

```typescript
import createClient from 'openapi-fetch'
import type { paths } from './types/api'

const client = createClient<paths>({ baseUrl: 'https://api.example.com' })

// 型安全なAPI呼び出し
const { data, error } = await client.GET('/users')
if (data) {
  // dataは自動的に型推論される
  console.log(data.users)
}

const { data: user } = await client.POST('/users', {
  body: {
    name: 'John Doe',
    email: 'john@example.com',
  },
})
```

## 2. Zodによるランタイムバリデーション

型定義だけではランタイムエラーを防げません。Zodを使用して、実行時にデータの妥当性を検証します。

### 基本的なバリデーション

```typescript
import { z } from 'zod'

const UserSchema = z.object({
  id: z.number(),
  name: z.string().min(1),
  email: z.string().email(),
})

const CreateUserSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
})

type User = z.infer<typeof UserSchema>
type CreateUserRequest = z.infer<typeof CreateUserSchema>

class ValidatedApiClient {
  private baseUrl: string

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl
  }

  async getUsers(): Promise<User[]> {
    const response = await fetch(`${this.baseUrl}/users`)
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    const data = await response.json()
    // ランタイムバリデーション
    return z.array(UserSchema).parse(data)
  }

  async createUser(request: CreateUserRequest): Promise<User> {
    // リクエストのバリデーション
    const validatedRequest = CreateUserSchema.parse(request)

    const response = await fetch(`${this.baseUrl}/users`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(validatedRequest),
    })

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    const data = await response.json()
    // レスポンスのバリデーション
    return UserSchema.parse(data)
  }
}
```

### エラーハンドリングの強化

```typescript
import { z } from 'zod'

type ApiError = {
  message: string
  code: string
  details?: unknown
}

class SafeApiClient {
  private baseUrl: string

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {},
    schema: z.ZodSchema<T>,
  ): Promise<T> {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, options)

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.message || `HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      return schema.parse(data)
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new Error(`Validation error: ${error.errors.map((e) => e.message).join(', ')}`)
      }
      throw error
    }
  }

  async getUsers(): Promise<User[]> {
    return this.request('/users', {}, z.array(UserSchema))
  }

  async createUser(data: CreateUserRequest): Promise<User> {
    return this.request(
      '/users',
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      },
      UserSchema,
    )
  }
}
```

## 3. カスタム型定義による型安全な実装

OpenAPI定義がない場合でも、手動で型定義を作成して型安全なAPI通信を実現できます。

### 型定義の作成

```typescript
type ApiResponse<T> = {
  data: T
  message?: string
}

type ApiError = {
  error: {
    code: string
    message: string
    details?: unknown
  }
}

type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'

type RequestConfig<TBody = unknown> = {
  method: HttpMethod
  body?: TBody
  headers?: Record<string, string>
  params?: Record<string, string>
}

class TypedApiClient {
  private baseUrl: string

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl
  }

  private async request<TResponse, TBody = unknown>(
    endpoint: string,
    config: RequestConfig<TBody> = { method: 'GET' },
  ): Promise<ApiResponse<TResponse>> {
    const url = new URL(endpoint, this.baseUrl)

    // クエリパラメータの追加
    if (config.params) {
      Object.entries(config.params).forEach(([key, value]) => {
        url.searchParams.append(key, value)
      })
    }

    const response = await fetch(url.toString(), {
      method: config.method,
      headers: {
        'Content-Type': 'application/json',
        ...config.headers,
      },
      body: config.body ? JSON.stringify(config.body) : undefined,
    })

    if (!response.ok) {
      const error: ApiError = await response.json()
      throw new Error(error.error.message)
    }

    const data: ApiResponse<TResponse> = await response.json()
    return data
  }

  // 型安全なメソッドを定義
  async getUsers(): Promise<ApiResponse<User[]>> {
    return this.request<User[]>('/users')
  }

  async getUser(id: number): Promise<ApiResponse<User>> {
    return this.request<User>(`/users/${id}`)
  }

  async createUser(data: CreateUserRequest): Promise<ApiResponse<User>> {
    return this.request<User, CreateUserRequest>('/users', {
      method: 'POST',
      body: data,
    })
  }

  async updateUser(id: number, data: Partial<CreateUserRequest>): Promise<ApiResponse<User>> {
    return this.request<User, Partial<CreateUserRequest>>(`/users/${id}`, {
      method: 'PUT',
      body: data,
    })
  }

  async deleteUser(id: number): Promise<ApiResponse<void>> {
    return this.request<void>(`/users/${id}`, {
      method: 'DELETE',
    })
  }
}
```

## 4. tRPCによるエンドツーエンドの型安全性

tRPCは、TypeScriptの型システムを活用して、クライアントとサーバー間の完全な型安全性を実現します。

### サーバー側の実装

```typescript
import { initTRPC } from '@trpc/server'
import { z } from 'zod'

const t = initTRPC.context().create()

const router = t.router({
  getUser: t.procedure.input(z.object({ id: z.number() })).query(async ({ input }) => {
    // データベースから取得
    return { id: input.id, name: 'John Doe', email: 'john@example.com' }
  }),

  createUser: t.procedure
    .input(
      z.object({
        name: z.string().min(1),
        email: z.string().email(),
      }),
    )
    .mutation(async ({ input }) => {
      // ユーザーを作成
      return { id: 1, ...input }
    }),
})

export type AppRouter = typeof router
```

### クライアント側の実装

```typescript
import { createTRPCProxyClient, httpBatchLink } from '@trpc/client'
import type { AppRouter } from './server'

const client = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000/trpc',
    }),
  ],
})

// 完全に型安全なAPI呼び出し
const user = await client.getUser.query({ id: 1 })
const newUser = await client.createUser.mutate({
  name: 'Jane Doe',
  email: 'jane@example.com',
})
```

## 5. エラーハンドリングの型安全化

エラーも型安全に扱うことで、適切なエラーハンドリングが可能になります。

### Result型パターンの実装

```typescript
type Result<T, E = Error> = { success: true; data: T } | { success: false; error: E }

class ResultApiClient {
  private baseUrl: string

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl
  }

  async getUsers(): Promise<Result<User[], Error>> {
    try {
      const response = await fetch(`${this.baseUrl}/users`)
      if (!response.ok) {
        return {
          success: false,
          error: new Error(`HTTP error! status: ${response.status}`),
        }
      }
      const data = await response.json()
      const users = z.array(UserSchema).parse(data)
      return { success: true, data: users }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new Error('Unknown error'),
      }
    }
  }

  async createUser(request: CreateUserRequest): Promise<Result<User, Error>> {
    try {
      const validatedRequest = CreateUserSchema.parse(request)

      const response = await fetch(`${this.baseUrl}/users`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(validatedRequest),
      })

      if (!response.ok) {
        return {
          success: false,
          error: new Error(`HTTP error! status: ${response.status}`),
        }
      }

      const data = await response.json()
      const user = UserSchema.parse(data)
      return { success: true, data: user }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new Error('Unknown error'),
      }
    }
  }
}

// 使用例
const client = new ResultApiClient('https://api.example.com')

const result = await client.getUsers()
if (result.success) {
  console.log(result.data) // User[]型
} else {
  console.error(result.error) // Error型
}
```

## 実践的なワークフロー

### 1. OpenAPI定義から型を生成

```bash
# OpenAPI定義から型定義を生成
npx openapi-typescript schema.yaml -o src/types/api.d.ts

# 型定義を更新するスクリプトを追加
{
  "scripts": {
    "generate:types": "openapi-typescript schema.yaml -o src/types/api.d.ts"
  }
}
```

### 2. Zodスキーマでバリデーション

```typescript
// OpenAPI定義からZodスキーマを生成（openapi-zod-client等を使用）
// または手動でZodスキーマを定義

import { z } from 'zod'
import type { paths } from './types/api'

// 型定義とZodスキーマを同期
const UserSchema = z.object({
  id: z.number(),
  name: z.string(),
  email: z.string().email(),
})

type User = z.infer<typeof UserSchema>
```

### 3. 型安全なAPIクライアントの実装

```typescript
// 上記の手法を組み合わせて実装
const client = new SafeApiClient('https://api.example.com')
const users = await client.getUsers() // 型安全
```

## まとめ

APIリクエストを型安全に実装することで、コンパイル時のエラー検出とランタイムの堅牢性を両立できます。

**主要なポイント**:

- **OpenAPI定義から型生成**: 仕様と型定義を一元管理
- **Zodによるバリデーション**: ランタイムでのデータ検証
- **カスタム型定義**: OpenAPIがない場合でも型安全に実装可能
- **tRPC**: エンドツーエンドの型安全性を実現
- **Result型パターン**: エラーハンドリングも型安全に

**実装時の推奨事項**:

- OpenAPI定義がある場合は、型定義の自動生成を活用
- ランタイムバリデーションは必須（Zod等を使用）
- エラーハンドリングも型安全に実装
- APIクライアントは再利用可能なクラスとして実装

これらの手法を適切に組み合わせることで、堅牢で保守性の高いAPI通信を実現できます。
