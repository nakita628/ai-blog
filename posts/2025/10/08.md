---
date: 2025-10-08
title: Zustand入門完全ガイド：軽量でシンプルなReact状態管理ライブラリを初心者向けに解説
description: Zustandの基本について、初心者にも分かりやすく解説。軽量でシンプルなReact状態管理ライブラリの特徴、基本的な使い方、実践的な例、他の状態管理ライブラリとの比較、パフォーマンス最適化まで実際のコード例と共に詳しく説明する。
tags:
  - zustand
  - react
  - state-management
  - javascript
  - frontend
  - beginner
  - tutorial
  - hooks
prev:
  text: 'セッション認証とJWT認証の違いを初心者向けに完全解説：どちらを選ぶべきか'
  link: '/posts/2025/10/07'
next: false
---

# Zustand入門完全ガイド：軽量でシンプルなReact状態管理ライブラリを初心者向けに解説

Zustandは、Reactアプリケーションの状態管理を簡単に行える軽量でシンプルなライブラリです。この記事では、初心者にも分かりやすく、Zustandの特徴、基本的な使い方、実践的な例、他の状態管理ライブラリとの比較、パフォーマンス最適化まで実際のコード例と共に詳しく解説します。

## Zustandとは

Zustand（ドイツ語で「状態」を意味する）は、React用の軽量な状態管理ライブラリです。ReduxやContext APIと比較して、より少ないボイラープレートコードで状態管理を実現できます。

### Zustandの特徴

- **軽量**: バンドルサイズが小さい（約2.5KB）
- **シンプル**: 最小限のAPIで直感的に使用可能
- **TypeScript対応**: 型安全性を提供
- **フレームワーク非依存**: React以外でも使用可能
- **DevTools対応**: Redux DevToolsとの統合
- **ミドルウェア対応**: 永続化、ログ出力など

## 基本的な使い方

### インストール

```bash
npm install zustand
# または
yarn add zustand
```

### 基本的なストアの作成

```typescript
// store/useCounterStore.ts
import { create } from 'zustand'

interface CounterState {
  count: number
  increment: () => void
  decrement: () => void
  reset: () => void
}

export const useCounterStore = create<CounterState>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
}))
```

### コンポーネントでの使用

```typescript
// components/Counter.tsx
import React from 'react';
import { useCounterStore } from '../store/useCounterStore';

const Counter: React.FC = () => {
  const { count, increment, decrement, reset } = useCounterStore();

  return (
    <div className="flex items-center space-x-4">
      <button
        onClick={decrement}
        className="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600"
      >
        -
      </button>
      <span className="text-2xl font-bold">{count}</span>
      <button
        onClick={increment}
        className="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600"
      >
        +
      </button>
      <button
        onClick={reset}
        className="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600"
      >
        Reset
      </button>
    </div>
  );
};

export default Counter;
```

## 実践的な例：Todoアプリケーション

### Todoストアの実装

```typescript
// store/useTodoStore.ts
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'

export interface Todo {
  id: string
  text: string
  completed: boolean
  createdAt: Date
}

interface TodoState {
  todos: Todo[]
  filter: 'all' | 'active' | 'completed'
  addTodo: (text: string) => void
  toggleTodo: (id: string) => void
  deleteTodo: (id: string) => void
  setFilter: (filter: 'all' | 'active' | 'completed') => void
  clearCompleted: () => void
  getFilteredTodos: () => Todo[]
}

export const useTodoStore = create<TodoState>()(
  devtools(
    persist(
      (set, get) => ({
        todos: [],
        filter: 'all',

        addTodo: (text: string) => {
          const newTodo: Todo = {
            id: Date.now().toString(),
            text,
            completed: false,
            createdAt: new Date(),
          }
          set((state) => ({
            todos: [...state.todos, newTodo],
          }))
        },

        toggleTodo: (id: string) => {
          set((state) => ({
            todos: state.todos.map((todo) =>
              todo.id === id ? { ...todo, completed: !todo.completed } : todo,
            ),
          }))
        },

        deleteTodo: (id: string) => {
          set((state) => ({
            todos: state.todos.filter((todo) => todo.id !== id),
          }))
        },

        setFilter: (filter) => {
          set({ filter })
        },

        clearCompleted: () => {
          set((state) => ({
            todos: state.todos.filter((todo) => !todo.completed),
          }))
        },

        getFilteredTodos: () => {
          const { todos, filter } = get()
          switch (filter) {
            case 'active':
              return todos.filter((todo) => !todo.completed)
            case 'completed':
              return todos.filter((todo) => todo.completed)
            default:
              return todos
          }
        },
      }),
      {
        name: 'todo-storage', // localStorage のキー名
        partialize: (state) => ({ todos: state.todos }), // 永続化する部分を指定
      },
    ),
    {
      name: 'todo-store', // DevTools での表示名
    },
  ),
)
```

### Todoコンポーネントの実装

```typescript
// components/TodoApp.tsx
import React, { useState } from 'react';
import { useTodoStore } from '../store/useTodoStore';

const TodoApp: React.FC = () => {
  const [inputValue, setInputValue] = useState('');
  const {
    todos,
    filter,
    addTodo,
    toggleTodo,
    deleteTodo,
    setFilter,
    clearCompleted,
    getFilteredTodos,
  } = useTodoStore();

  const filteredTodos = getFilteredTodos();
  const activeTodosCount = todos.filter((todo) => !todo.completed).length;

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (inputValue.trim()) {
      addTodo(inputValue.trim());
      setInputValue('');
    }
  };

  return (
    <div className="max-w-md mx-auto mt-8 p-6 bg-white rounded-lg shadow-lg">
      <h1 className="text-2xl font-bold text-center mb-6">Todo App</h1>

      {/* 入力フォーム */}
      <form onSubmit={handleSubmit} className="mb-6">
        <div className="flex space-x-2">
          <input
            type="text"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            placeholder="新しいタスクを入力..."
            className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <button
            type="submit"
            className="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            追加
          </button>
        </div>
      </form>

      {/* フィルターボタン */}
      <div className="flex space-x-2 mb-4">
        {(['all', 'active', 'completed'] as const).map((filterType) => (
          <button
            key={filterType}
            onClick={() => setFilter(filterType)}
            className={`px-3 py-1 rounded-md text-sm ${
              filter === filterType
                ? 'bg-blue-500 text-white'
                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
            }`}
          >
            {filterType === 'all' && 'すべて'}
            {filterType === 'active' && '未完了'}
            {filterType === 'completed' && '完了済み'}
          </button>
        ))}
      </div>

      {/* Todoリスト */}
      <div className="space-y-2 mb-4">
        {filteredTodos.map((todo) => (
          <div
            key={todo.id}
            className="flex items-center space-x-2 p-2 border border-gray-200 rounded-md"
          >
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
              className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
            />
            <span
              className={`flex-1 ${
                todo.completed ? 'line-through text-gray-500' : 'text-gray-900'
              }`}
            >
              {todo.text}
            </span>
            <button
              onClick={() => deleteTodo(todo.id)}
              className="text-red-500 hover:text-red-700 text-sm"
            >
              削除
            </button>
          </div>
        ))}
      </div>

      {/* 統計情報 */}
      <div className="flex justify-between items-center text-sm text-gray-600">
        <span>{activeTodosCount} 個のタスクが残っています</span>
        {todos.some((todo) => todo.completed) && (
          <button
            onClick={clearCompleted}
            className="text-red-500 hover:text-red-700"
          >
            完了済みを削除
          </button>
        )}
      </div>
    </div>
  );
};

export default TodoApp;
```

## 非同期処理の実装

### データフェッチングの例

```typescript
// store/useUserStore.ts
import { create } from 'zustand'

interface User {
  id: number
  name: string
  email: string
  avatar?: string
}

interface UserState {
  users: User[]
  loading: boolean
  error: string | null
  fetchUsers: () => Promise<void>
  addUser: (user: Omit<User, 'id'>) => Promise<void>
  updateUser: (id: number, updates: Partial<User>) => Promise<void>
  deleteUser: (id: number) => Promise<void>
}

export const useUserStore = create<UserState>((set, get) => ({
  users: [],
  loading: false,
  error: null,

  fetchUsers: async () => {
    set({ loading: true, error: null })
    try {
      const response = await fetch('/api/users')
      if (!response.ok) {
        throw new Error('Failed to fetch users')
      }
      const users = await response.json()
      set({ users, loading: false })
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Unknown error',
        loading: false,
      })
    }
  },

  addUser: async (userData) => {
    set({ loading: true, error: null })
    try {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(userData),
      })

      if (!response.ok) {
        throw new Error('Failed to add user')
      }

      const newUser = await response.json()
      set((state) => ({
        users: [...state.users, newUser],
        loading: false,
      }))
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Unknown error',
        loading: false,
      })
    }
  },

  updateUser: async (id, updates) => {
    set({ loading: true, error: null })
    try {
      const response = await fetch(`/api/users/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(updates),
      })

      if (!response.ok) {
        throw new Error('Failed to update user')
      }

      const updatedUser = await response.json()
      set((state) => ({
        users: state.users.map((user) => (user.id === id ? updatedUser : user)),
        loading: false,
      }))
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Unknown error',
        loading: false,
      })
    }
  },

  deleteUser: async (id) => {
    set({ loading: true, error: null })
    try {
      const response = await fetch(`/api/users/${id}`, {
        method: 'DELETE',
      })

      if (!response.ok) {
        throw new Error('Failed to delete user')
      }

      set((state) => ({
        users: state.users.filter((user) => user.id !== id),
        loading: false,
      }))
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Unknown error',
        loading: false,
      })
    }
  },
}))
```

### 非同期処理を使用するコンポーネント

```typescript
// components/UserList.tsx
import React, { useEffect } from 'react';
import { useUserStore } from '../store/useUserStore';

const UserList: React.FC = () => {
  const { users, loading, error, fetchUsers, deleteUser } = useUserStore();

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  const handleDelete = async (id: number) => {
    if (window.confirm('このユーザーを削除しますか？')) {
      await deleteUser(id);
    }
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
        <p>エラー: {error}</p>
        <button
          onClick={fetchUsers}
          className="mt-2 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600"
        >
          再試行
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold">ユーザー一覧</h2>
        <button
          onClick={fetchUsers}
          className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
        >
          更新
        </button>
      </div>

      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {users.map((user) => (
          <div
            key={user.id}
            className="bg-white p-4 rounded-lg shadow-md border"
          >
            <div className="flex items-center space-x-3 mb-3">
              {user.avatar ? (
                <img
                  src={user.avatar}
                  alt={user.name}
                  className="w-10 h-10 rounded-full"
                />
              ) : (
                <div className="w-10 h-10 bg-gray-300 rounded-full flex items-center justify-center">
                  <span className="text-gray-600 font-medium">
                    {user.name.charAt(0)}
                  </span>
                </div>
              )}
              <div>
                <h3 className="font-semibold text-gray-900">{user.name}</h3>
                <p className="text-sm text-gray-600">{user.email}</p>
              </div>
            </div>
            <button
              onClick={() => handleDelete(user.id)}
              className="w-full bg-red-500 text-white py-2 px-4 rounded hover:bg-red-600 transition-colors"
            >
              削除
            </button>
          </div>
        ))}
      </div>

      {users.length === 0 && (
        <div className="text-center py-8 text-gray-500">
          ユーザーが登録されていません
        </div>
      )}
    </div>
  );
};

export default UserList;
```

## ミドルウェアの使用

### 永続化ミドルウェア

```typescript
// store/useSettingsStore.ts
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

interface Settings {
  theme: 'light' | 'dark'
  language: 'ja' | 'en'
  notifications: boolean
}

interface SettingsState extends Settings {
  updateSettings: (settings: Partial<Settings>) => void
  resetSettings: () => void
}

const defaultSettings: Settings = {
  theme: 'light',
  language: 'ja',
  notifications: true,
}

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set) => ({
      ...defaultSettings,

      updateSettings: (newSettings) => {
        set((state) => ({ ...state, ...newSettings }))
      },

      resetSettings: () => {
        set(defaultSettings)
      },
    }),
    {
      name: 'settings-storage',
      // 特定のフィールドのみ永続化
      partialize: (state) => ({
        theme: state.theme,
        language: state.language,
        notifications: state.notifications,
      }),
    },
  ),
)
```

### ログミドルウェア

```typescript
// store/useLogStore.ts
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'

interface LogEntry {
  id: string
  message: string
  timestamp: Date
  level: 'info' | 'warn' | 'error'
}

interface LogState {
  logs: LogEntry[]
  addLog: (message: string, level?: 'info' | 'warn' | 'error') => void
  clearLogs: () => void
}

export const useLogStore = create<LogState>()(
  devtools(
    (set) => ({
      logs: [],

      addLog: (message, level = 'info') => {
        const logEntry: LogEntry = {
          id: Date.now().toString(),
          message,
          timestamp: new Date(),
          level,
        }
        set((state) => ({
          logs: [...state.logs, logEntry],
        }))
      },

      clearLogs: () => {
        set({ logs: [] })
      },
    }),
    {
      name: 'log-store',
    },
  ),
)
```

## パフォーマンス最適化

### セレクターの使用

```typescript
// store/useProductStore.ts
import { create } from 'zustand'
import { subscribeWithSelector } from 'zustand/middleware'

interface Product {
  id: string
  name: string
  price: number
  category: string
  inStock: boolean
}

interface ProductState {
  products: Product[]
  cart: string[]
  addToCart: (productId: string) => void
  removeFromCart: (productId: string) => void
  clearCart: () => void
}

export const useProductStore = create<ProductState>()(
  subscribeWithSelector((set) => ({
    products: [],
    cart: [],

    addToCart: (productId) => {
      set((state) => ({
        cart: [...state.cart, productId],
      }))
    },

    removeFromCart: (productId) => {
      set((state) => ({
        cart: state.cart.filter((id) => id !== productId),
      }))
    },

    clearCart: () => {
      set({ cart: [] })
    },
  })),
)

// セレクターを使用してパフォーマンスを最適化
export const useCartCount = () => useProductStore((state) => state.cart.length)

export const useCartProducts = () =>
  useProductStore((state) => state.products.filter((product) => state.cart.includes(product.id)))

export const useProductById = (id: string) =>
  useProductStore((state) => state.products.find((product) => product.id === id))
```

### 最適化されたコンポーネント

```typescript
// components/CartButton.tsx
import React from 'react';
import { useCartCount } from '../store/useProductStore';

const CartButton: React.FC = () => {
  // カートのアイテム数だけを購読
  const cartCount = useCartCount();

  return (
    <button className="relative bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">
      カート
      {cartCount > 0 && (
        <span className="absolute -top-2 -right-2 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
          {cartCount}
        </span>
      )}
    </button>
  );
};

export default CartButton;
```

## 他の状態管理ライブラリとの比較

### Redux vs Zustand

| 特徴             | Redux  | Zustand      |
| ---------------- | ------ | ------------ |
| ボイラープレート | 多い   | 少ない       |
| 学習コスト       | 高い   | 低い         |
| バンドルサイズ   | 大きい | 小さい       |
| TypeScript対応   | 良好   | 優秀         |
| DevTools         | 標準   | ミドルウェア |
| ミドルウェア     | 豊富   | 基本的なもの |

### Context API vs Zustand

| 特徴           | Context API | Zustand      |
| -------------- | ----------- | ------------ |
| 再レンダリング | 多い        | 少ない       |
| パフォーマンス | 低い        | 高い         |
| セレクター     | なし        | あり         |
| 永続化         | 手動        | ミドルウェア |
| 非同期処理     | 手動        | 簡単         |

## まとめ

Zustandは、Reactアプリケーションの状態管理を簡単に行える優秀なライブラリです。軽量でシンプルなAPI、優れたTypeScript対応、豊富なミドルウェアにより、様々なプロジェクトで活用できます。

### Zustandを選ぶべき場合

- **軽量な状態管理**が必要な場合
- **学習コストを抑えたい**場合
- **TypeScript**を積極的に使用する場合
- **パフォーマンス**を重視する場合
- **シンプルなAPI**を求める場合

### 学習のポイント

- **基本的なストア作成**から始める
- **非同期処理**の実装方法を理解する
- **ミドルウェア**の活用方法を学ぶ
- **パフォーマンス最適化**のテクニックを習得する
- **実際のプロジェクト**で使用して経験を積む

Zustandは、[公式デモサイト](https://zustand-demo.pmnd.rs/)で実際の動作を確認できます。初心者から上級者まで、様々なレベルの開発者に適した状態管理ライブラリです。まずは基本的な使い方から始めて、徐々に高度な機能を学習していきましょう。
