---
date: 2025-10-05
title: Neverthrow入門完全ガイド：TypeScriptで型安全なエラーハンドリングを初心者向けに解説
description: Neverthrowライブラリを使った型安全なエラーハンドリングの基本から実践的な使い方まで、初心者にも分かりやすく解説。Result型とResultAsync型の使い方、エラーハンドリングのベストプラクティス、実際のコード例と共に詳しく説明する。
tags:
  - neverthrow
  - typescript
  - error-handling
  - functional-programming
  - result-type
  - beginner
  - tutorial
prev:
  text: 'Drizzle ORM入門完全ガイド：TypeScriptで型安全なデータベース操作を初心者向けに解説'
  link: '/posts/2025/10/03'
next: false
---

# Neverthrow入門完全ガイド：TypeScriptで型安全なエラーハンドリングを初心者向けに解説

Neverthrowは、TypeScriptとJavaScriptで型安全なエラーハンドリングを実現するライブラリです。[Neverthrow公式リポジトリ](https://github.com/supermacro/neverthrow)でも紹介されているように、`Result`型と`ResultAsync`型を使用して、例外を使わずにエラーを処理できます。この記事では、初心者にも分かりやすくNeverthrowの基本から実践的な使い方まで詳しく解説します。

## Neverthrowとは

Neverthrowは、関数型プログラミングの概念である`Result`型をTypeScriptで実装したライブラリです。従来の`try-catch`による例外処理とは異なり、エラーを型として表現することで、コンパイル時にエラーハンドリングの漏れを防ぐことができます。

### 主な特徴

- **型安全性**: エラーが型として表現され、コンパイル時にチェック可能
- **例外を使わない**: `throw`や`catch`を使わずにエラーを処理
- **関数型プログラミング**: モナド的な操作でエラーを安全に伝播
- **TypeScript完全対応**: 型推論と型チェックを最大限活用
- **軽量**: 小さなバンドルサイズで高いパフォーマンス

## プロジェクトのセットアップ

### インストール

```bash
npm install neverthrow
```

### 基本的なインポート

```typescript
import { ok, err, Result, ResultAsync } from 'neverthrow'
```

## Result型の基本

### OkとErrの作成

```typescript
// 成功を表すResult
const successResult: Result<string, never> = ok('Hello, World!')

// エラーを表すResult
const errorResult: Result<never, string> = err('Something went wrong')

// 型推論を活用した例
const userResult = ok({ id: 1, name: 'Alice' })
const validationError = err('Invalid email format')
```

### Resultの状態チェック

```typescript
function processResult(result: Result<string, string>) {
  if (result.isOk()) {
    console.log('成功:', result.value)
    // result.valueは型安全にアクセス可能
  } else {
    console.log('エラー:', result.error)
    // result.errorは型安全にアクセス可能
  }
}

// 使用例
processResult(ok('Success!'))
processResult(err('Failed!'))
```

## 基本的な操作

### map - 成功時の値の変換

```typescript
// 成功時の値を変換
const result = ok(42)
const doubled = result.map((value) => value * 2)

console.log(doubled.isOk() ? doubled.value : 'Error') // 84

// エラーの場合は変換されない
const errorResult = err('Error')
const mappedError = errorResult.map((value) => value * 2)
console.log(mappedError.isErr()) // true
```

### mapErr - エラーの変換

```typescript
// エラーメッセージを変換
const result = err('Database error')
const userFriendlyError = result.mapErr((error) => `ユーザーに分かりやすいエラー: ${error}`)

console.log(userFriendlyError.error) // "ユーザーに分かりやすいエラー: Database error"
```

### andThen - チェーン操作

```typescript
// 複数の操作をチェーン
function validateEmail(email: string): Result<string, string> {
  if (email.includes('@')) {
    return ok(email)
  }
  return err('Invalid email format')
}

function sendEmail(email: string): Result<void, string> {
  // メール送信のシミュレーション
  if (email === 'test@example.com') {
    return ok(undefined)
  }
  return err('Failed to send email')
}

// チェーン操作
const result = validateEmail('test@example.com').andThen((email) => sendEmail(email))

if (result.isOk()) {
  console.log('メール送信成功')
} else {
  console.log('エラー:', result.error)
}
```

## 実践的な使用例

### データベース操作

```typescript
import { Result, ResultAsync, ok, err } from 'neverthrow'

// ユーザー型の定義
interface User {
  id: number
  name: string
  email: string
}

// データベース操作のシミュレーション
class UserRepository {
  async findById(id: number): Promise<Result<User, string>> {
    try {
      // 実際のデータベースクエリをシミュレート
      if (id === 1) {
        return ok({ id: 1, name: 'Alice', email: 'alice@example.com' })
      }
      return err('User not found')
    } catch (error) {
      return err('Database error')
    }
  }

  async create(user: Omit<User, 'id'>): Promise<Result<User, string>> {
    try {
      // ユーザー作成のシミュレート
      const newUser: User = { id: Date.now(), ...user }
      return ok(newUser)
    } catch (error) {
      return err('Failed to create user')
    }
  }
}

// 使用例
const userRepo = new UserRepository()

async function getUserInfo(id: number) {
  const result = await userRepo.findById(id)

  if (result.isOk()) {
    console.log('ユーザー情報:', result.value)
    return result.value
  } else {
    console.error('エラー:', result.error)
    return null
  }
}
```

### API呼び出し

```typescript
// API呼び出しの例
async function fetchUserData(userId: number): Promise<Result<User, string>> {
  try {
    const response = await fetch(`/api/users/${userId}`)

    if (!response.ok) {
      return err(`HTTP Error: ${response.status}`)
    }

    const userData = await response.json()
    return ok(userData)
  } catch (error) {
    return err('Network error')
  }
}

// 使用例
async function displayUser(userId: number) {
  const result = await fetchUserData(userId)

  result.match(
    (user) => {
      console.log(`ユーザー名: ${user.name}`)
      console.log(`メール: ${user.email}`)
    },
    (error) => {
      console.error(`エラーが発生しました: ${error}`)
    },
  )
}
```

## ResultAsync型の使用

### 非同期操作でのResult

```typescript
import { ResultAsync, okAsync, errAsync } from 'neverthrow'

// 非同期操作をResultAsyncでラップ
function fetchData(url: string): ResultAsync<User[], string> {
  return ResultAsync.fromPromise(
    fetch(url).then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`)
      }
      return response.json()
    }),
    (error) => `Failed to fetch data: ${error}`,
  )
}

// チェーン操作
function processUserData(url: string): ResultAsync<string[], string> {
  return fetchData(url)
    .map((users) => users.map((user) => user.name))
    .mapErr((error) => `Processing failed: ${error}`)
}

// 使用例
processUserData('/api/users').then((result) => {
  result.match(
    (names) => console.log('ユーザー名一覧:', names),
    (error) => console.error('エラー:', error),
  )
})
```

### 複数の非同期操作の組み合わせ

```typescript
// 複数のAPI呼び出しを組み合わせ
function getUserAndPosts(userId: number): ResultAsync<{ user: User; posts: Post[] }, string> {
  const userResult = ResultAsync.fromPromise(
    fetch(`/api/users/${userId}`).then((res) => res.json()),
    (error) => `Failed to fetch user: ${error}`,
  )

  const postsResult = ResultAsync.fromPromise(
    fetch(`/api/users/${userId}/posts`).then((res) => res.json()),
    (error) => `Failed to fetch posts: ${error}`,
  )

  // 両方の結果を組み合わせ
  return ResultAsync.combine([userResult, postsResult]).map(([user, posts]) => ({ user, posts }))
}
```

## エラーハンドリングのベストプラクティス

### エラー型の定義

```typescript
// エラー型の定義
type AppError =
  | { type: 'VALIDATION_ERROR'; message: string }
  | { type: 'NETWORK_ERROR'; message: string }
  | { type: 'DATABASE_ERROR'; message: string }
  | { type: 'NOT_FOUND'; message: string }

// エラーファクトリー関数
const createError = {
  validation: (message: string): AppError => ({ type: 'VALIDATION_ERROR', message }),
  network: (message: string): AppError => ({ type: 'NETWORK_ERROR', message }),
  database: (message: string): AppError => ({ type: 'DATABASE_ERROR', message }),
  notFound: (message: string): AppError => ({ type: 'NOT_FOUND', message }),
}

// 使用例
function validateUser(user: any): Result<User, AppError> {
  if (!user.name) {
    return err(createError.validation('Name is required'))
  }

  if (!user.email) {
    return err(createError.validation('Email is required'))
  }

  return ok(user as User)
}
```

### エラーの分類と処理

```typescript
function handleError(error: AppError): void {
  switch (error.type) {
    case 'VALIDATION_ERROR':
      console.error('バリデーションエラー:', error.message)
      break
    case 'NETWORK_ERROR':
      console.error('ネットワークエラー:', error.message)
      break
    case 'DATABASE_ERROR':
      console.error('データベースエラー:', error.message)
      break
    case 'NOT_FOUND':
      console.error('リソースが見つかりません:', error.message)
      break
  }
}

// 使用例
const result = validateUser({ name: '', email: 'test@example.com' })

result.match(
  (user) => console.log('ユーザー:', user),
  (error) => handleError(error),
)
```

## 実践的なアプリケーション例

### Express.jsとの組み合わせ

```typescript
import express from 'express'
import { Result, ok, err } from 'neverthrow'

const app = express()
app.use(express.json())

// ユーザーサービス
class UserService {
  async createUser(userData: any): Promise<Result<User, string>> {
    // バリデーション
    if (!userData.name || !userData.email) {
      return err('Name and email are required')
    }

    // ユーザー作成のシミュレート
    try {
      const user: User = {
        id: Date.now(),
        name: userData.name,
        email: userData.email,
      }
      return ok(user)
    } catch (error) {
      return err('Failed to create user')
    }
  }
}

const userService = new UserService()

// ルートハンドラー
app.post('/users', async (req, res) => {
  const result = await userService.createUser(req.body)

  result.match(
    (user) => {
      res.status(201).json({ success: true, data: user })
    },
    (error) => {
      res.status(400).json({ success: false, error })
    },
  )
})

app.listen(3000, () => {
  console.log('Server running on port 3000')
})
```

### Reactコンポーネントでの使用

```typescript
import React, { useState, useEffect } from 'react';
import { Result, ok, err } from 'neverthrow';

interface User {
  id: number;
  name: string;
  email: string;
}

function UserProfile({ userId }: { userId: number }) {
  const [userResult, setUserResult] = useState<Result<User, string> | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchUser() {
      setLoading(true);

      try {
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) {
          setUserResult(err(`HTTP Error: ${response.status}`));
          return;
        }

        const userData = await response.json();
        setUserResult(ok(userData));
      } catch (error) {
        setUserResult(err('Failed to fetch user'));
      } finally {
        setLoading(false);
      }
    }

    fetchUser();
  }, [userId]);

  if (loading) {
    return <div>Loading...</div>;
  }

  if (!userResult) {
    return <div>No data</div>;
  }

  return userResult.match(
    (user) => (
      <div>
        <h1>{user.name}</h1>
        <p>Email: {user.email}</p>
      </div>
    ),
    (error) => (
      <div>
        <h1>Error</h1>
        <p>{error}</p>
      </div>
    )
  );
}
```

## テストでの使用

```typescript
import { ok, err } from 'neverthrow'

// テスト用のヘルパー関数
function createUser(name: string, email: string): Result<User, string> {
  if (!name || !email) {
    return err('Name and email are required')
  }

  return ok({ id: 1, name, email })
}

// テスト例
describe('User creation', () => {
  it('should create user with valid data', () => {
    const result = createUser('Alice', 'alice@example.com')

    expect(result.isOk()).toBe(true)
    if (result.isOk()) {
      expect(result.value.name).toBe('Alice')
      expect(result.value.email).toBe('alice@example.com')
    }
  })

  it('should return error for invalid data', () => {
    const result = createUser('', 'alice@example.com')

    expect(result.isErr()).toBe(true)
    if (result.isErr()) {
      expect(result.error).toBe('Name and email are required')
    }
  })
})
```

## まとめ

Neverthrowは、TypeScriptで型安全なエラーハンドリングを実現する強力なライブラリです。従来の例外処理とは異なり、エラーを型として表現することで、コンパイル時にエラーハンドリングの漏れを防ぐことができます。

### 主な利点

- **型安全性**: エラーが型として表現され、コンパイル時にチェック可能
- **予測可能性**: 例外を使わないため、エラーの発生が予測可能
- **関数型プログラミング**: モナド的な操作でエラーを安全に伝播
- **テスト容易性**: エラーが値として扱えるため、テストが簡単
- **デバッグの容易さ**: エラーの流れが追跡しやすい

### 学習のポイント

- **Result型の基本**: `ok`と`err`の使い方
- **チェーン操作**: `map`、`mapErr`、`andThen`の活用
- **非同期処理**: `ResultAsync`の使用方法
- **エラー型の設計**: 適切なエラー型の定義
- **実践的な応用**: 実際のアプリケーションでの活用

Neverthrowを活用することで、より安全で保守性の高いコードを書くことができます。まずは基本的な`Result`型から始めて、徐々に高度な機能を学習していきましょう。
