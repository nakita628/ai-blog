---
date: 2025-10-05
title: Neverthrow入門完全ガイド：TypeScriptで型安全なエラーハンドリングを初心者向けに解説
description: Neverthrowライブラリを使った型安全なエラーハンドリングの基本から実践的な使い方まで、初心者にも分かりやすく解説。Result型とResultAsync型の使い方、エラーハンドリングのベストプラクティス、実際のコード例と共に詳しく説明する。
tags:
    - neverthrow
    - typescript
    - error-handling
    - functional-programming
    - result-type
    - beginner
    - tutorial
prev:
    text: "Drizzle ORM入門完全ガイド：TypeScriptで型安全なデータベース操作を初心者向けに解説"
    link: "/posts/2025/10/03"
next: false
---

# Neverthrow入門完全ガイド：TypeScriptで型安全なエラーハンドリングを初心者向けに解説

Neverthrowは、TypeScriptとJavaScriptで型安全なエラーハンドリングを実現するライブラリです。[Neverthrow公式リポジトリ](https://github.com/supermacro/neverthrow)でも紹介されているように、`Result`型と`ResultAsync`型を使用して、例外を使わずにエラーを処理できます。この記事では、初心者にも分かりやすくNeverthrowの基本から実践的な使い方まで詳しく解説します。

## Neverthrowとは

Neverthrowは、関数型プログラミングの概念である`Result`型をTypeScriptで実装したライブラリです。従来の`try-catch`による例外処理とは異なり、エラーを型として表現することで、コンパイル時にエラーハンドリングの漏れを防ぐことができます。

### 主な特徴

- **型安全性**: エラーが型として表現され、コンパイル時にチェック可能
- **例外を使わない**: `throw`や`catch`を使わずにエラーを処理
- **関数型プログラミング**: モナド的な操作でエラーを安全に伝播
- **TypeScript完全対応**: 型推論と型チェックを最大限活用
- **軽量**: 小さなバンドルサイズで高いパフォーマンス

## プロジェクトのセットアップ

### インストール

```bash
npm install neverthrow
```

### 基本的なインポート

```typescript
import { ok, err, Result, ResultAsync } from 'neverthrow';
```

## Result型の基本

### OkとErrの作成

```typescript
// 成功を表すResult
const successResult: Result<string, never> = ok('Hello, World!');

// エラーを表すResult
const errorResult: Result<never, string> = err('Something went wrong');

// 型推論を活用した例
const userResult = ok({ id: 1, name: 'Alice' });
const validationError = err('Invalid email format');
```

### Resultの状態チェック

```typescript
function processResult(result: Result<string, string>) {
  if (result.isOk()) {
    console.log('成功:', result.value);
    // result.valueは型安全にアクセス可能
  } else {
    console.log('エラー:', result.error);
    // result.errorは型安全にアクセス可能
  }
}

// 使用例
processResult(ok('Success!'));
processResult(err('Failed!'));
```

## 基本的な操作

### map - 成功時の値の変換

```typescript
// 成功時の値を変換
const result = ok(42);
const doubled = result.map(value => value * 2);

console.log(doubled.isOk() ? doubled.value : 'Error'); // 84

// エラーの場合は変換されない
const errorResult = err('Error');
const mappedError = errorResult.map(value => value * 2);
console.log(mappedError.isErr()); // true
```

### mapErr - エラーの変換

```typescript
// エラーメッセージを変換
const result = err('Database error');
const userFriendlyError = result.mapErr(error => 
  `ユーザーに分かりやすいエラー: ${error}`
);

console.log(userFriendlyError.error); // "ユーザーに分かりやすいエラー: Database error"
```

### andThen - チェーン操作

```typescript
// 複数の操作をチェーン
function validateEmail(email: string): Result<string, string> {
  if (email.includes('@')) {
    return ok(email);
  }
  return err('Invalid email format');
}

function sendEmail(email: string): Result<void, string> {
  // メール送信のシミュレーション
  if (email === 'test@example.com') {
    return ok(undefined);
  }
  return err('Failed to send email');
}

// チェーン操作
const result = validateEmail('test@example.com')
  .andThen(email => sendEmail(email));

if (result.isOk()) {
  console.log('メール送信成功');
} else {
  console.log('エラー:', result.error);
}
```

## 実践的な使用例

### データベース操作

```typescript
import { Result, ResultAsync, ok, err } from 'neverthrow';

// ユーザー型の定義
interface User {
  id: number;
  name: string;
  email: string;
}

// データベース操作のシミュレーション
class UserRepository {
  async findById(id: number): Promise<Result<User, string>> {
    try {
      // 実際のデータベースクエリをシミュレート
      if (id === 1) {
        return ok({ id: 1, name: 'Alice', email: 'alice@example.com' });
      }
      return err('User not found');
    } catch (error) {
      return err('Database error');
    }
  }

  async create(user: Omit<User, 'id'>): Promise<Result<User, string>> {
    try {
      // ユーザー作成のシミュレート
      const newUser: User = { id: Date.now(), ...user };
      return ok(newUser);
    } catch (error) {
      return err('Failed to create user');
    }
  }
}

// 使用例
const userRepo = new UserRepository();

async function getUserInfo(id: number) {
  const result = await userRepo.findById(id);
  
  if (result.isOk()) {
    console.log('ユーザー情報:', result.value);
    return result.value;
  } else {
    console.error('エラー:', result.error);
    return null;
  }
}
```

### API呼び出し

```typescript
// API呼び出しの例
async function fetchUserData(userId: number): Promise<Result<User, string>> {
  try {
    const response = await fetch(`/api/users/${userId}`);
    
    if (!response.ok) {
      return err(`HTTP Error: ${response.status}`);
    }
    
    const userData = await response.json();
    return ok(userData);
  } catch (error) {
    return err('Network error');
  }
}

// 使用例
async function displayUser(userId: number) {
  const result = await fetchUserData(userId);
  
  result.match(
    (user) => {
      console.log(`ユーザー名: ${user.name}`);
      console.log(`メール: ${user.email}`);
    },
    (error) => {
      console.error(`エラーが発生しました: ${error}`);
    }
  );
}
```

## ResultAsync型の使用

### 非同期操作でのResult

```typescript
import { ResultAsync, okAsync, errAsync } from 'neverthrow';

// 非同期操作をResultAsyncでラップ
function fetchData(url: string): ResultAsync<User[], string> {
  return ResultAsync.fromPromise(
    fetch(url).then(response => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      return response.json();
    }),
    (error) => `Failed to fetch data: ${error}`
  );
}

// チェーン操作
function processUserData(url: string): ResultAsync<string[], string> {
  return fetchData(url)
    .map(users => users.map(user => user.name))
    .mapErr(error => `Processing failed: ${error}`);
}

// 使用例
processUserData('/api/users')
  .then(result => {
    result.match(
      (names) => console.log('ユーザー名一覧:', names),
      (error) => console.error('エラー:', error)
    );
  });
```

### 複数の非同期操作の組み合わせ

```typescript
// 複数のAPI呼び出しを組み合わせ
function getUserAndPosts(userId: number): ResultAsync<{ user: User; posts: Post[] }, string> {
  const userResult = ResultAsync.fromPromise(
    fetch(`/api/users/${userId}`).then(res => res.json()),
    (error) => `Failed to fetch user: ${error}`
  );

  const postsResult = ResultAsync.fromPromise(
    fetch(`/api/users/${userId}/posts`).then(res => res.json()),
    (error) => `Failed to fetch posts: ${error}`
  );

  // 両方の結果を組み合わせ
  return ResultAsync.combine([userResult, postsResult])
    .map(([user, posts]) => ({ user, posts }));
}
```

## エラーハンドリングのベストプラクティス

### エラー型の定義

```typescript
// エラー型の定義
type AppError = 
  | { type: 'VALIDATION_ERROR'; message: string }
  | { type: 'NETWORK_ERROR'; message: string }
  | { type: 'DATABASE_ERROR'; message: string }
  | { type: 'NOT_FOUND'; message: string };

// エラーファクトリー関数
const createError = {
  validation: (message: string): AppError => ({ type: 'VALIDATION_ERROR', message }),
  network: (message: string): AppError => ({ type: 'NETWORK_ERROR', message }),
  database: (message: string): AppError => ({ type: 'DATABASE_ERROR', message }),
  notFound: (message: string): AppError => ({ type: 'NOT_FOUND', message }),
};

// 使用例
function validateUser(user: any): Result<User, AppError> {
  if (!user.name) {
    return err(createError.validation('Name is required'));
  }
  
  if (!user.email) {
    return err(createError.validation('Email is required'));
  }
  
  return ok(user as User);
}
```

### エラーの分類と処理

```typescript
function handleError(error: AppError): void {
  switch (error.type) {
    case 'VALIDATION_ERROR':
      console.error('バリデーションエラー:', error.message);
      break;
    case 'NETWORK_ERROR':
      console.error('ネットワークエラー:', error.message);
      break;
    case 'DATABASE_ERROR':
      console.error('データベースエラー:', error.message);
      break;
    case 'NOT_FOUND':
      console.error('リソースが見つかりません:', error.message);
      break;
  }
}

// 使用例
const result = validateUser({ name: '', email: 'test@example.com' });

result.match(
  (user) => console.log('ユーザー:', user),
  (error) => handleError(error)
);
```

## 実践的なアプリケーション例

### Express.jsとの組み合わせ

```typescript
import express from 'express';
import { Result, ok, err } from 'neverthrow';

const app = express();
app.use(express.json());

// ユーザーサービス
class UserService {
  async createUser(userData: any): Promise<Result<User, string>> {
    // バリデーション
    if (!userData.name || !userData.email) {
      return err('Name and email are required');
    }
    
    // ユーザー作成のシミュレート
    try {
      const user: User = {
        id: Date.now(),
        name: userData.name,
        email: userData.email,
      };
      return ok(user);
    } catch (error) {
      return err('Failed to create user');
    }
  }
}

const userService = new UserService();

// ルートハンドラー
app.post('/users', async (req, res) => {
  const result = await userService.createUser(req.body);
  
  result.match(
    (user) => {
      res.status(201).json({ success: true, data: user });
    },
    (error) => {
      res.status(400).json({ success: false, error });
    }
  );
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

### Reactコンポーネントでの使用

```typescript
import React, { useState, useEffect } from 'react';
import { Result, ok, err } from 'neverthrow';

interface User {
  id: number;
  name: string;
  email: string;
}

function UserProfile({ userId }: { userId: number }) {
  const [userResult, setUserResult] = useState<Result<User, string> | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchUser() {
      setLoading(true);
      
      try {
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) {
          setUserResult(err(`HTTP Error: ${response.status}`));
          return;
        }
        
        const userData = await response.json();
        setUserResult(ok(userData));
      } catch (error) {
        setUserResult(err('Failed to fetch user'));
      } finally {
        setLoading(false);
      }
    }

    fetchUser();
  }, [userId]);

  if (loading) {
    return <div>Loading...</div>;
  }

  if (!userResult) {
    return <div>No data</div>;
  }

  return userResult.match(
    (user) => (
      <div>
        <h1>{user.name}</h1>
        <p>Email: {user.email}</p>
      </div>
    ),
    (error) => (
      <div>
        <h1>Error</h1>
        <p>{error}</p>
      </div>
    )
  );
}
```

## テストでの使用

```typescript
import { ok, err } from 'neverthrow';

// テスト用のヘルパー関数
function createUser(name: string, email: string): Result<User, string> {
  if (!name || !email) {
    return err('Name and email are required');
  }
  
  return ok({ id: 1, name, email });
}

// テスト例
describe('User creation', () => {
  it('should create user with valid data', () => {
    const result = createUser('Alice', 'alice@example.com');
    
    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value.name).toBe('Alice');
      expect(result.value.email).toBe('alice@example.com');
    }
  });

  it('should return error for invalid data', () => {
    const result = createUser('', 'alice@example.com');
    
    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error).toBe('Name and email are required');
    }
  });
});
```

## まとめ

Neverthrowは、TypeScriptで型安全なエラーハンドリングを実現する強力なライブラリです。従来の例外処理とは異なり、エラーを型として表現することで、コンパイル時にエラーハンドリングの漏れを防ぐことができます。

### 主な利点

- **型安全性**: エラーが型として表現され、コンパイル時にチェック可能
- **予測可能性**: 例外を使わないため、エラーの発生が予測可能
- **関数型プログラミング**: モナド的な操作でエラーを安全に伝播
- **テスト容易性**: エラーが値として扱えるため、テストが簡単
- **デバッグの容易さ**: エラーの流れが追跡しやすい

### 学習のポイント

- **Result型の基本**: `ok`と`err`の使い方
- **チェーン操作**: `map`、`mapErr`、`andThen`の活用
- **非同期処理**: `ResultAsync`の使用方法
- **エラー型の設計**: 適切なエラー型の定義
- **実践的な応用**: 実際のアプリケーションでの活用

Neverthrowを活用することで、より安全で保守性の高いコードを書くことができます。まずは基本的な`Result`型から始めて、徐々に高度な機能を学習していきましょう。