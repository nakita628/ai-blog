---
date: 2025-10-07
title: セッション認証とJWT認証の違いを初心者向けに完全解説：どちらを選ぶべきか
description: セッション認証とJWT認証の違いについて、初心者にも分かりやすく解説。それぞれの仕組み、メリット・デメリット、実装方法、セキュリティ面での違いを実際のコード例と共に詳しく説明し、プロジェクトでどちらを選ぶべきかの判断基準も提供する。
tags:
  - authentication
  - session
  - jwt
  - security
  - web-development
  - backend
  - frontend
  - beginner
  - tutorial
prev:
  text: 'Reactエコシステム完全ガイド：初心者でもわかる豊富なライブラリとツールの世界'
  link: '/posts/2025/10/06'
next: false
---

# セッション認証とJWT認証の違いを初心者向けに完全解説：どちらを選ぶべきか

Webアプリケーションの認証システムには、主にセッション認証とJWT認証の2つの方式があります。この記事では、初心者にも分かりやすく、それぞれの仕組み、メリット・デメリット、実装方法、セキュリティ面での違いを実際のコード例と共に詳しく解説します。

## 認証とは何か

認証（Authentication）とは、ユーザーが「本人である」ことを確認するプロセスです。ログイン時にユーザー名とパスワードを入力し、正しい場合にアプリケーションへのアクセスが許可されます。

### 認証の基本フロー

1. ユーザーがログイン情報を入力
2. サーバーが認証情報を検証
3. 認証成功時に認証トークン（セッションIDまたはJWT）を発行
4. 以降のリクエストで認証トークンを使用してアクセス制御

## セッション認証とは

セッション認証は、サーバー側でセッション情報を管理する認証方式です。ユーザーがログインすると、サーバーはセッションIDを生成し、クライアントにCookieとして送信します。

### セッション認証の仕組み

```mermaid
sequenceDiagram
    participant Client as クライアント
    participant Server as サーバー
    participant DB as データベース

    Client->>Server: ログイン情報を送信
    Server->>DB: ユーザー情報を検証
    DB-->>Server: 認証結果
    Server->>Server: セッションIDを生成
    Server->>DB: セッション情報を保存
    Server-->>Client: セッションIDをCookieで送信
    Client->>Server: リクエスト（セッションID付き）
    Server->>DB: セッション情報を確認
    DB-->>Server: セッション有効性
    Server-->>Client: レスポンス
```

### セッション認証の実装例（Node.js + Express）

```typescript
// server.ts
import express from 'express'
import session from 'express-session'
import { v4 as uuidv4 } from 'uuid'

const app = express()

// セッション設定
app.use(
  session({
    secret: 'your-secret-key',
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: false, // HTTPS環境ではtrue
      httpOnly: true, // XSS攻撃を防ぐ
      maxAge: 24 * 60 * 60 * 1000, // 24時間
    },
  }),
)

// ログイン処理
app.post('/login', (req, res) => {
  const { username, password } = req.body

  // ユーザー認証（実際の実装ではデータベースで確認）
  if (username === 'user' && password === 'password') {
    // セッションにユーザー情報を保存
    req.session.userId = uuidv4()
    req.session.username = username
    req.session.isAuthenticated = true

    res.json({ message: 'Login successful' })
  } else {
    res.status(401).json({ message: 'Invalid credentials' })
  }
})

// 認証が必要なエンドポイント
app.get('/profile', (req, res) => {
  if (req.session.isAuthenticated) {
    res.json({
      userId: req.session.userId,
      username: req.session.username,
    })
  } else {
    res.status(401).json({ message: 'Unauthorized' })
  }
})

// ログアウト処理
app.post('/logout', (req, res) => {
  req.session.destroy((err) => {
    if (err) {
      return res.status(500).json({ message: 'Logout failed' })
    }
    res.clearCookie('connect.sid')
    res.json({ message: 'Logout successful' })
  })
})

app.listen(3000, () => {
  console.log('Server running on port 3000')
})
```

### セッション認証のクライアント側実装（React）

```typescript
// components/LoginForm.tsx
import React, { useState } from 'react';

interface LoginFormProps {
  onLogin: (user: { userId: string; username: string }) => void;
}

const LoginForm: React.FC<LoginFormProps> = ({ onLogin }) => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    try {
      const response = await fetch('/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include', // Cookieを送信
        body: JSON.stringify({ username, password }),
      });

      if (response.ok) {
        // プロフィール情報を取得
        const profileResponse = await fetch('/profile', {
          credentials: 'include',
        });
        const user = await profileResponse.json();
        onLogin(user);
      } else {
        setError('ログインに失敗しました');
      }
    } catch (err) {
      setError('ネットワークエラーが発生しました');
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label className="block text-sm font-medium text-gray-700">
          ユーザー名
        </label>
        <input
          type="text"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
          required
        />
      </div>

      <div>
        <label className="block text-sm font-medium text-gray-700">
          パスワード
        </label>
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
          required
        />
      </div>

      {error && (
        <div className="text-red-600 text-sm">{error}</div>
      )}

      <button
        type="submit"
        className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700"
      >
        ログイン
      </button>
    </form>
  );
};

export default LoginForm;
```

## JWT認証とは

JWT（JSON Web Token）認証は、トークンベースの認証方式です。サーバーは認証成功時にJWTを生成し、クライアントに送信します。クライアントは以降のリクエストでJWTをAuthorizationヘッダーに含めて送信します。

### JWT認証の仕組み

```mermaid
sequenceDiagram
    participant Client as クライアント
    participant Server as サーバー
    participant DB as データベース

    Client->>Server: ログイン情報を送信
    Server->>DB: ユーザー情報を検証
    DB-->>Server: 認証結果
    Server->>Server: JWTを生成・署名
    Server-->>Client: JWTを送信
    Client->>Server: リクエスト（JWT付き）
    Server->>Server: JWTを検証・復号
    Server-->>Client: レスポンス
```

### JWTの構造

JWTは3つの部分から構成されます：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

1. **Header**: アルゴリズムとトークンタイプ
2. **Payload**: ユーザー情報やクレーム
3. **Signature**: 署名（改ざん検知用）

### JWT認証の実装例（Node.js + Express）

```typescript
// server.ts
import express from 'express'
import jwt from 'jsonwebtoken'
import bcrypt from 'bcrypt'

const app = express()
app.use(express.json())

const JWT_SECRET = 'your-secret-key'
const JWT_EXPIRES_IN = '24h'

// ログイン処理
app.post('/login', async (req, res) => {
  const { username, password } = req.body

  // ユーザー認証（実際の実装ではデータベースで確認）
  if (username === 'user' && password === 'password') {
    // JWTを生成
    const token = jwt.sign(
      {
        userId: '123',
        username: username,
        role: 'user',
      },
      JWT_SECRET,
      { expiresIn: JWT_EXPIRES_IN },
    )

    res.json({
      message: 'Login successful',
      token: token,
    })
  } else {
    res.status(401).json({ message: 'Invalid credentials' })
  }
})

// JWT検証ミドルウェア
const authenticateToken = (req: any, res: any, next: any) => {
  const authHeader = req.headers['authorization']
  const token = authHeader && authHeader.split(' ')[1] // Bearer TOKEN

  if (!token) {
    return res.status(401).json({ message: 'Access token required' })
  }

  jwt.verify(token, JWT_SECRET, (err: any, user: any) => {
    if (err) {
      return res.status(403).json({ message: 'Invalid or expired token' })
    }
    req.user = user
    next()
  })
}

// 認証が必要なエンドポイント
app.get('/profile', authenticateToken, (req: any, res) => {
  res.json({
    userId: req.user.userId,
    username: req.user.username,
    role: req.user.role,
  })
})

// ログアウト処理（JWTは無効化できないため、クライアント側で削除）
app.post('/logout', (req, res) => {
  res.json({ message: 'Logout successful' })
})

app.listen(3000, () => {
  console.log('Server running on port 3000')
})
```

### JWT認証のクライアント側実装（React）

```typescript
// hooks/useAuth.ts
import { useState, useEffect } from 'react';

interface User {
  userId: string;
  username: string;
  role: string;
}

export const useAuth = () => {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(null);

  useEffect(() => {
    // ローカルストレージからトークンを取得
    const savedToken = localStorage.getItem('token');
    if (savedToken) {
      setToken(savedToken);
      // トークンからユーザー情報を取得
      fetchUserProfile(savedToken);
    }
  }, []);

  const fetchUserProfile = async (authToken: string) => {
    try {
      const response = await fetch('/profile', {
        headers: {
          'Authorization': `Bearer ${authToken}`,
        },
      });

      if (response.ok) {
        const userData = await response.json();
        setUser(userData);
      } else {
        // トークンが無効な場合
        logout();
      }
    } catch (error) {
      console.error('Failed to fetch user profile:', error);
      logout();
    }
  };

  const login = async (username: string, password: string) => {
    try {
      const response = await fetch('/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ username, password }),
      });

      if (response.ok) {
        const data = await response.json();
        setToken(data.token);
        localStorage.setItem('token', data.token);
        await fetchUserProfile(data.token);
        return { success: true };
      } else {
        return { success: false, error: 'ログインに失敗しました' };
      }
    } catch (error) {
      return { success: false, error: 'ネットワークエラーが発生しました' };
    }
  };

  const logout = () => {
    setUser(null);
    setToken(null);
    localStorage.removeItem('token');
  };

  return {
    user,
    token,
    login,
    logout,
    isAuthenticated: !!user,
  };
};

// components/LoginForm.tsx
import React, { useState } from 'react';
import { useAuth } from '../hooks/useAuth';

const LoginForm: React.FC = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const { login } = useAuth();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    const result = await login(username, password);
    if (!result.success) {
      setError(result.error || 'ログインに失敗しました');
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label className="block text-sm font-medium text-gray-700">
          ユーザー名
        </label>
        <input
          type="text"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
          required
        />
      </div>

      <div>
        <label className="block text-sm font-medium text-gray-700">
          パスワード
        </label>
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
          required
        />
      </div>

      {error && (
        <div className="text-red-600 text-sm">{error}</div>
      )}

      <button
        type="submit"
        className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700"
      >
        ログイン
      </button>
    </form>
  );
};

export default LoginForm;
```

## セッション認証とJWT認証の比較

### セッション認証のメリット・デメリット

#### メリット

- **セキュリティが高い**: サーバー側でセッション情報を管理
- **即座に無効化可能**: ログアウト時にセッションを削除
- **サーバー側での制御**: セッションの有効期限やアクセス制御を柔軟に管理
- **XSS攻撃に強い**: HttpOnly CookieによりJavaScriptからアクセス不可

#### デメリット

- **サーバー側のメモリ使用**: セッション情報をサーバーに保存
- **スケーラビリティの課題**: 複数サーバー間でのセッション共有が複雑
- **Cookie依存**: クライアントがCookieを無効化している場合に問題
- **CSRF攻撃のリスク**: 適切な対策が必要

### JWT認証のメリット・デメリット

#### メリット

- **ステートレス**: サーバー側でセッション情報を保存不要
- **スケーラブル**: 複数サーバー間での認証情報共有が容易
- **モバイルアプリ対応**: Cookieに依存しない
- **分散システムに適している**: マイクロサービス間での認証

#### デメリット

- **即座に無効化不可**: トークンの有効期限まで有効
- **トークンサイズが大きい**: セッションIDより大きなサイズ
- **XSS攻撃に脆弱**: ローカルストレージに保存する場合
- **改ざん検知のみ**: 暗号化されていない（署名のみ）

## セキュリティ面での考慮事項

### セッション認証のセキュリティ対策

```typescript
// セッション設定のセキュリティ強化
app.use(
  session({
    secret: process.env.SESSION_SECRET, // 環境変数から取得
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: process.env.NODE_ENV === 'production', // HTTPS環境ではtrue
      httpOnly: true, // XSS攻撃を防ぐ
      sameSite: 'strict', // CSRF攻撃を防ぐ
      maxAge: 24 * 60 * 60 * 1000, // 24時間
    },
    store: new RedisStore({
      // Redisでセッション管理
      host: 'localhost',
      port: 6379,
    }),
  }),
)

// CSRF保護
import csrf from 'csurf'
app.use(csrf())
```

### JWT認証のセキュリティ対策

```typescript
// JWT設定のセキュリティ強化
const JWT_SECRET = process.env.JWT_SECRET // 強力な秘密鍵
const JWT_EXPIRES_IN = '15m' // 短い有効期限

// リフレッシュトークンの実装
app.post('/refresh', (req, res) => {
  const { refreshToken } = req.body

  try {
    const decoded = jwt.verify(refreshToken, JWT_SECRET)
    const newToken = jwt.sign({ userId: decoded.userId, username: decoded.username }, JWT_SECRET, {
      expiresIn: '15m',
    })

    res.json({ token: newToken })
  } catch (error) {
    res.status(403).json({ message: 'Invalid refresh token' })
  }
})

// トークンブラックリストの実装（ログアウト時の無効化）
const tokenBlacklist = new Set()

app.post('/logout', (req, res) => {
  const authHeader = req.headers['authorization']
  const token = authHeader && authHeader.split(' ')[1]

  if (token) {
    tokenBlacklist.add(token)
  }

  res.json({ message: 'Logout successful' })
})

// ミドルウェアでブラックリストをチェック
const authenticateToken = (req: any, res: any, next: any) => {
  const authHeader = req.headers['authorization']
  const token = authHeader && authHeader.split(' ')[1]

  if (!token) {
    return res.status(401).json({ message: 'Access token required' })
  }

  // ブラックリストをチェック
  if (tokenBlacklist.has(token)) {
    return res.status(403).json({ message: 'Token has been revoked' })
  }

  jwt.verify(token, JWT_SECRET, (err: any, user: any) => {
    if (err) {
      return res.status(403).json({ message: 'Invalid or expired token' })
    }
    req.user = user
    next()
  })
}
```

## どちらを選ぶべきか

### セッション認証を選ぶべき場合

- **セキュリティを最優先**する場合
- **単一のサーバー**で運用する場合
- **即座にログアウト**が必要な場合
- **従来のWebアプリケーション**の場合

### JWT認証を選ぶべき場合

- **スケーラビリティ**を重視する場合
- **マイクロサービス**アーキテクチャの場合
- **モバイルアプリ**も含む場合
- **API中心**のアプリケーションの場合

### ハイブリッドアプローチ

実際のプロジェクトでは、両方の方式を組み合わせることも可能です：

```typescript
// ハイブリッド認証の例
app.post('/login', async (req, res) => {
  const { username, password } = req.body

  if (await authenticateUser(username, password)) {
    // セッション認証用のセッションID
    req.session.userId = user.id
    req.session.isAuthenticated = true

    // JWT認証用のトークン
    const token = jwt.sign({ userId: user.id, username: user.username }, JWT_SECRET, {
      expiresIn: '1h',
    })

    res.json({
      message: 'Login successful',
      token: token,
      sessionId: req.sessionID,
    })
  } else {
    res.status(401).json({ message: 'Invalid credentials' })
  }
})
```

## まとめ

セッション認証とJWT認証は、それぞれ異なる特徴と用途を持っています。適切な選択をするためには、プロジェクトの要件、セキュリティレベル、スケーラビリティ、運用環境などを総合的に考慮する必要があります。

### 選択のポイント

- **セキュリティ要件**: 高いセキュリティが必要ならセッション認証
- **スケーラビリティ**: 大規模なシステムならJWT認証
- **運用環境**: 単一サーバーならセッション、分散システムならJWT
- **開発チームの経験**: 既存の知識と経験を活用

### 実装時の注意点

- **適切なセキュリティ対策**を実装する
- **定期的なセキュリティ監査**を行う
- **トークンの有効期限**を適切に設定する
- **エラーハンドリング**を適切に実装する

認証システムは、アプリケーションの基盤となる重要な部分です。要件に応じて適切な方式を選択し、セキュリティを最優先に実装することが重要です。
