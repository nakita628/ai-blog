---
date: 2025-10-17
title: tRPC完全入門：型安全なAPI開発でフルスタックTypeScriptを極める
description: tRPCの基本概念から実装方法まで、初心者向けに詳しく解説。従来のREST APIやGraphQLとの違い、型安全性のメリット、Next.jsとの組み合わせ方を通じて、tRPCを使った効率的なフルスタック開発を学ぶ実践的なガイド。
tags:
    - trpc
    - typescript
    - api
    - fullstack
    - nextjs
    - type-safety
    - react
    - backend
prev:
    text: "React Server Components（RSC）完全入門：サーバーサイドレンダリングの新時代を初心者向けに解説"
    link: "/posts/2025/10/16"
next: false
---

# tRPC完全入門：型安全なAPI開発でフルスタックTypeScriptを極める

tRPCは、TypeScriptの型安全性を活用してフルスタックアプリケーションを構築するためのライブラリです。従来のREST APIやGraphQLとは異なり、サーバーとクライアント間で完全な型安全性を提供し、開発効率を大幅に向上させます。この記事では、tRPCの基本概念から実装方法まで、初心者向けに詳しく解説します。

## tRPCとは

[tRPC](https://trpc.io/)は「TypeScript Remote Procedure Call」の略で、TypeScriptの型システムを活用してサーバーとクライアント間の通信を型安全にするライブラリです。従来のAPI開発では、サーバー側でAPIを定義し、クライアント側で型定義を手動で管理する必要がありましたが、tRPCでは型定義が自動的に共有されます。

### 従来のAPI開発との違い

```typescript
// 従来のREST API
// サーバー側
app.get('/api/users/:id', (req, res) => {
  const user = getUserById(req.params.id);
  res.json(user);
});

// クライアント側（型定義を手動で管理）
interface User {
  id: string;
  name: string;
  email: string;
}

const response = await fetch('/api/users/123');
const user: User = await response.json(); // 型安全性なし
```

```typescript
// tRPC
// サーバー側
const userRouter = router({
  getById: publicProcedure
    .input(z.string())
    .query(({ input }) => {
      return getUserById(input); // 型安全
    }),
});

// クライアント側（型が自動的に共有される）
const user = await trpc.user.getById.query('123');
// user の型は自動的に推論される
```

## tRPCの主要な特徴

### 1. 完全な型安全性

tRPCの最大の特徴は、サーバーとクライアント間で完全な型安全性を提供することです：

- **自動的な型推論**: サーバー側の型定義がクライアント側に自動的に反映
- **コンパイル時エラー検出**: 型の不一致をコンパイル時に検出
- **IntelliSenseサポート**: IDEでの自動補完とエラー表示

### 2. ゼロ設定

tRPCは設定が不要で、すぐに使い始められます：

- **コード生成なし**: ビルドステップやコード生成が不要
- **ランタイムオーバーヘッド最小**: 軽量で高速
- **フレームワーク非依存**: React、Next.js、Express、Fastifyなどに対応

### 3. 優れた開発者体験

- **リアルタイム型チェック**: サーバー側の変更が即座にクライアント側に反映
- **エラーハンドリング**: 統一されたエラーハンドリング
- **バッチリクエスト**: 複数のリクエストを自動的にバッチ化

## 基本的な実装

### プロジェクトのセットアップ

```bash
# Next.jsプロジェクトを作成
npx create-next-app@latest my-trpc-app --typescript --tailwind --eslint
cd my-trpc-app

# tRPCと関連パッケージをインストール
npm install @trpc/server @trpc/client @trpc/react-query @trpc/next
npm install @tanstack/react-query zod
npm install -D @types/node
```

### サーバー側の実装

```typescript
// server/trpc.ts
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

// tRPCインスタンスを作成
const t = initTRPC.create();

// ルーターとプロシージャを定義
export const router = t.router;
export const publicProcedure = t.procedure;

// サンプルデータ
const users = [
  { id: '1', name: 'Alice', email: 'alice@example.com' },
  { id: '2', name: 'Bob', email: 'bob@example.com' },
  { id: '3', name: 'Charlie', email: 'charlie@example.com' },
];

const posts = [
  { id: '1', title: 'First Post', content: 'Hello World', userId: '1' },
  { id: '2', title: 'Second Post', content: 'tRPC is awesome', userId: '2' },
  { id: '3', title: 'Third Post', content: 'TypeScript rocks', userId: '1' },
];

// ユーザールーター
const userRouter = router({
  // 全ユーザーを取得
  getAll: publicProcedure.query(() => {
    return users;
  }),

  // IDでユーザーを取得
  getById: publicProcedure
    .input(z.string())
    .query(({ input }) => {
      const user = users.find(u => u.id === input);
      if (!user) {
        throw new Error('User not found');
      }
      return user;
    }),

  // ユーザーを作成
  create: publicProcedure
    .input(z.object({
      name: z.string().min(1),
      email: z.string().email(),
    }))
    .mutation(({ input }) => {
      const newUser = {
        id: String(users.length + 1),
        name: input.name,
        email: input.email,
      };
      users.push(newUser);
      return newUser;
    }),

  // ユーザーを更新
  update: publicProcedure
    .input(z.object({
      id: z.string(),
      name: z.string().min(1).optional(),
      email: z.string().email().optional(),
    }))
    .mutation(({ input }) => {
      const userIndex = users.findIndex(u => u.id === input.id);
      if (userIndex === -1) {
        throw new Error('User not found');
      }
      
      const updatedUser = { ...users[userIndex], ...input };
      users[userIndex] = updatedUser;
      return updatedUser;
    }),

  // ユーザーを削除
  delete: publicProcedure
    .input(z.string())
    .mutation(({ input }) => {
      const userIndex = users.findIndex(u => u.id === input);
      if (userIndex === -1) {
        throw new Error('User not found');
      }
      
      const deletedUser = users[userIndex];
      users.splice(userIndex, 1);
      return deletedUser;
    }),
});

// 投稿ルーター
const postRouter = router({
  // 全投稿を取得
  getAll: publicProcedure.query(() => {
    return posts;
  }),

  // ユーザーの投稿を取得
  getByUserId: publicProcedure
    .input(z.string())
    .query(({ input }) => {
      return posts.filter(p => p.userId === input);
    }),

  // 投稿を作成
  create: publicProcedure
    .input(z.object({
      title: z.string().min(1),
      content: z.string().min(1),
      userId: z.string(),
    }))
    .mutation(({ input }) => {
      const newPost = {
        id: String(posts.length + 1),
        title: input.title,
        content: input.content,
        userId: input.userId,
      };
      posts.push(newPost);
      return newPost;
    }),
});

// メインルーター
export const appRouter = router({
  user: userRouter,
  post: postRouter,
});

// ルーターの型をエクスポート
export type AppRouter = typeof appRouter;
```

### Next.js APIルートの設定

```typescript
// pages/api/trpc/[trpc].ts
import { createNextApiHandler } from '@trpc/server/adapters/next';
import { appRouter } from '../../../server/trpc';

export default createNextApiHandler({
  router: appRouter,
  createContext: () => ({}),
});
```

### クライアント側の設定

```typescript
// utils/trpc.ts
import { createTRPCNext } from '@trpc/next';
import { httpBatchLink } from '@trpc/client';
import type { AppRouter } from '../server/trpc';

export const trpc = createTRPCNext<AppRouter>({
  config() {
    return {
      links: [
        httpBatchLink({
          url: '/api/trpc',
        }),
      ],
    };
  },
  ssr: false,
});
```

### React Queryプロバイダーの設定

```typescript
// pages/_app.tsx
import type { AppProps } from 'next/app';
import { trpc } from '../utils/trpc';

function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />;
}

export default trpc.withTRPC(MyApp);
```

## 実践的な使用例

### ユーザー管理コンポーネント

```typescript
// components/UserList.tsx
import { trpc } from '../utils/trpc';

export function UserList() {
  const { data: users, isLoading, error } = trpc.user.getAll.useQuery();

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div className="space-y-4">
      <h2 className="text-2xl font-bold">Users</h2>
      <div className="grid gap-4">
        {users?.map((user) => (
          <div key={user.id} className="border p-4 rounded">
            <h3 className="font-semibold">{user.name}</h3>
            <p className="text-gray-600">{user.email}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### ユーザー作成フォーム

```typescript
// components/CreateUserForm.tsx
import { useState } from 'react';
import { trpc } from '../utils/trpc';

export function CreateUserForm() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  
  const utils = trpc.useUtils();
  const createUser = trpc.user.create.useMutation({
    onSuccess: () => {
      // ユーザー一覧を再取得
      utils.user.getAll.invalidate();
      setName('');
      setEmail('');
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    createUser.mutate({ name, email });
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label htmlFor="name" className="block text-sm font-medium">
          Name
        </label>
        <input
          type="text"
          id="name"
          value={name}
          onChange={(e) => setName(e.target.value)}
          className="mt-1 block w-full border rounded px-3 py-2"
          required
        />
      </div>
      
      <div>
        <label htmlFor="email" className="block text-sm font-medium">
          Email
        </label>
        <input
          type="email"
          id="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          className="mt-1 block w-full border rounded px-3 py-2"
          required
        />
      </div>
      
      <button
        type="submit"
        disabled={createUser.isLoading}
        className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 disabled:opacity-50"
      >
        {createUser.isLoading ? 'Creating...' : 'Create User'}
      </button>
    </form>
  );
}
```

### ユーザー詳細ページ

```typescript
// pages/user/[id].tsx
import { useRouter } from 'next/router';
import { trpc } from '../../utils/trpc';

export default function UserDetail() {
  const router = useRouter();
  const { id } = router.query;
  
  const { data: user, isLoading, error } = trpc.user.getById.useQuery(
    id as string,
    { enabled: !!id }
  );
  
  const { data: posts } = trpc.post.getByUserId.useQuery(
    id as string,
    { enabled: !!id }
  );

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-bold mb-8">{user.name}</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        <div>
          <h2 className="text-xl font-semibold mb-4">User Information</h2>
          <div className="space-y-2">
            <p><strong>ID:</strong> {user.id}</p>
            <p><strong>Name:</strong> {user.name}</p>
            <p><strong>Email:</strong> {user.email}</p>
          </div>
        </div>
        
        <div>
          <h2 className="text-xl font-semibold mb-4">Posts</h2>
          <div className="space-y-2">
            {posts?.map((post) => (
              <div key={post.id} className="border p-3 rounded">
                <h3 className="font-medium">{post.title}</h3>
                <p className="text-sm text-gray-600">{post.content}</p>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}
```

## 高度な機能

### ミドルウェアの使用

```typescript
// server/trpc.ts
import { initTRPC, TRPCError } from '@trpc/server';

const t = initTRPC.create();

// 認証ミドルウェア
const isAuthenticated = t.middleware(({ next, ctx }) => {
  // 認証チェック（実際の実装ではJWTトークンなどを検証）
  const isAuth = true; // 仮の実装
  
  if (!isAuth) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  
  return next({
    ctx: {
      ...ctx,
      user: { id: '1', name: 'Alice' }, // 認証されたユーザー情報
    },
  });
});

// 認証が必要なプロシージャ
export const protectedProcedure = t.procedure.use(isAuthenticated);

// 使用例
const userRouter = router({
  getProfile: protectedProcedure.query(({ ctx }) => {
    // ctx.user が利用可能
    return ctx.user;
  }),
});
```

### エラーハンドリング

```typescript
// server/trpc.ts
import { TRPCError } from '@trpc/server';

const userRouter = router({
  getById: publicProcedure
    .input(z.string())
    .query(({ input }) => {
      const user = users.find(u => u.id === input);
      
      if (!user) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'User not found',
        });
      }
      
      return user;
    }),
});
```

### バッチリクエスト

```typescript
// 複数のリクエストを同時に実行
const [user, posts] = await Promise.all([
  trpc.user.getById.query('1'),
  trpc.post.getByUserId.query('1'),
]);

// または、React QueryのuseQueriesを使用
const queries = trpc.useQueries((t) => [
  t.user.getById('1'),
  t.post.getByUserId('1'),
]);
```

## パフォーマンス最適化

### キャッシュの活用

```typescript
// クエリのキャッシュ設定
const { data: users } = trpc.user.getAll.useQuery(undefined, {
  staleTime: 5 * 60 * 1000, // 5分間キャッシュ
  cacheTime: 10 * 60 * 1000, // 10分間メモリに保持
});
```

### 楽観的更新

```typescript
const utils = trpc.useUtils();
const updateUser = trpc.user.update.useMutation({
  onMutate: async (newData) => {
    // 楽観的更新
    await utils.user.getById.cancel(newData.id);
    const previousUser = utils.user.getById.getData(newData.id);
    utils.user.getById.setData(newData.id, { ...previousUser, ...newData });
    return { previousUser };
  },
  onError: (err, newData, context) => {
    // エラー時は元に戻す
    utils.user.getById.setData(newData.id, context?.previousUser);
  },
  onSettled: (data, error, variables) => {
    // 最終的にサーバーのデータで更新
    utils.user.getById.invalidate(variables.id);
  },
});
```

## tRPCのメリット

### 1. 開発効率の向上

- **型安全性**: コンパイル時にエラーを検出
- **自動補完**: IDEでの完全なIntelliSenseサポート
- **リファクタリング**: サーバー側の変更がクライアント側に自動反映

### 2. 保守性の向上

- **単一の型定義**: サーバーとクライアントで型定義を共有
- **エラーハンドリング**: 統一されたエラーハンドリング
- **ドキュメント**: 型定義がそのままドキュメントになる

### 3. パフォーマンス

- **バッチリクエスト**: 複数のリクエストを自動的にバッチ化
- **キャッシュ**: React Queryとの統合による効率的なキャッシュ
- **軽量**: ランタイムオーバーヘッドが最小

## まとめ

tRPCは、TypeScriptの型安全性を活用してフルスタックアプリケーションを構築するための強力なツールです。主なポイントは以下の通りです：

### 主要な特徴
- **完全な型安全性**: サーバーとクライアント間で型定義を自動共有
- **ゼロ設定**: 設定不要で即座に使用開始
- **優れた開発者体験**: リアルタイム型チェックと自動補完

### 適用場面
- **TypeScriptプロジェクト**: 型安全性を重視するプロジェクト
- **フルスタック開発**: サーバーとクライアントを同じ言語で開発
- **高速開発**: プロトタイピングやMVP開発

### 注意点
- **TypeScript必須**: TypeScriptプロジェクトでのみ使用可能
- **学習コスト**: 新しい概念の理解が必要
- **エコシステム**: 比較的新しいライブラリのため、コミュニティは成長中

tRPCを活用することで、型安全で保守性の高いAPIを効率的に構築できます。Next.jsやReactとの組み合わせで、モダンなフルスタックアプリケーション開発を体験してみてください。

## 参考リンク

- [tRPC公式ドキュメント](https://trpc.io/)
- [tRPC GitHub](https://github.com/trpc/trpc)
- [Next.js公式ドキュメント](https://nextjs.org/docs)
- [React Query公式ドキュメント](https://tanstack.com/query/latest)
