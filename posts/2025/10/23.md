---
date: 2025-10-23
title: NestJS/Swagger完全入門：OpenAPI仕様でAPIドキュメントを自動生成する
description: NestJSとSwaggerを組み合わせて、OpenAPI仕様に基づいたAPIドキュメントを自動生成する方法を詳しく解説。デコレータを使った直感的なAPI定義、型安全なスキーマ生成、認証機能の統合、カスタムデコレータの作成まで、実践的な開発手法を初心者向けに分かりやすく説明する。
tags:
  - nestjs
  - swagger
  - openapi
  - api-documentation
  - typescript
  - backend
  - rest-api
  - documentation
prev:
  text: 'Amazon DynamoDB完全入門：サーバーレスNoSQLデータベースでスケーラブルなアプリケーションを構築する'
  link: '/posts/2025/10/22'
next: false
---

# NestJS/Swagger完全入門：OpenAPI仕様でAPIドキュメントを自動生成する

NestJSとSwaggerを組み合わせることで、OpenAPI仕様に基づいた美しく機能的なAPIドキュメントを自動生成できます。この記事では、[NestJS OpenAPI](https://docs.nestjs.com/openapi/introduction)の基本的な使い方から高度な機能まで、実践的な開発手法を詳しく解説します。

## NestJS/Swaggerとは

NestJS/Swaggerは、NestJSアプリケーションでOpenAPI仕様に基づいたAPIドキュメントを自動生成するための公式パッケージです。デコレータベースの直感的なAPI定義により、型安全で保守性の高いドキュメントを生成できます。

### 主な特徴

- **自動生成**: デコレータからOpenAPI仕様を自動生成
- **型安全性**: TypeScriptの型情報を活用したスキーマ生成
- **インタラクティブ**: Swagger UIでのAPIテスト機能
- **認証統合**: JWT、OAuth2などの認証機能を統合
- **カスタマイズ**: カスタムデコレータとプラグインの拡張

## プロジェクトのセットアップ

### 必要なパッケージのインストール

```bash
# NestJSプロジェクトを作成
npm i -g @nestjs/cli
nest new swagger-app
cd swagger-app

# Swagger関連パッケージをインストール
npm install @nestjs/swagger swagger-ui-express
npm install class-validator class-transformer

# 開発用パッケージ
npm install -D @types/swagger-ui-express
```

### 基本的なSwagger設定

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core'
import { ValidationPipe } from '@nestjs/common'
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger'
import { AppModule } from './app.module'

async function bootstrap() {
  const app = await NestFactory.create(AppModule)

  // バリデーションパイプの設定
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    }),
  )

  // Swagger設定
  const config = new DocumentBuilder()
    .setTitle('My API')
    .setDescription('The API description')
    .setVersion('1.0')
    .addTag('users')
    .addTag('posts')
    .addBearerAuth() // JWT認証の設定
    .build()

  const document = SwaggerModule.createDocument(app, config)
  SwaggerModule.setup('api', app, document)

  await app.listen(3000)
  console.log('Application is running on: http://localhost:3000')
  console.log('Swagger UI is available at: http://localhost:3000/api')
}
bootstrap()
```

## DTO（Data Transfer Object）の定義

### 基本的なDTO

```typescript
// src/users/dto/create-user.dto.ts
import { ApiProperty } from '@nestjs/swagger'
import { IsEmail, IsNotEmpty, IsString, MinLength, MaxLength } from 'class-validator'

export class CreateUserDto {
  @ApiProperty({
    description: 'ユーザーのメールアドレス',
    example: 'user@example.com',
    format: 'email',
  })
  @IsEmail()
  @IsNotEmpty()
  email: string

  @ApiProperty({
    description: 'ユーザーの名前',
    example: 'John Doe',
    minLength: 2,
    maxLength: 50,
  })
  @IsString()
  @IsNotEmpty()
  @MinLength(2)
  @MaxLength(50)
  name: string

  @ApiProperty({
    description: 'ユーザーのパスワード',
    example: 'password123',
    minLength: 8,
    writeOnly: true, // レスポンスから除外
  })
  @IsString()
  @IsNotEmpty()
  @MinLength(8)
  password: string
}
```

### レスポンスDTO

```typescript
// src/users/dto/user-response.dto.ts
import { ApiProperty } from '@nestjs/swagger'
import { Exclude, Expose, Transform } from 'class-transformer'

export class UserResponseDto {
  @ApiProperty({
    description: 'ユーザーID',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @Expose()
  id: string

  @ApiProperty({
    description: 'ユーザーのメールアドレス',
    example: 'user@example.com',
  })
  @Expose()
  email: string

  @ApiProperty({
    description: 'ユーザーの名前',
    example: 'John Doe',
  })
  @Expose()
  name: string

  @ApiProperty({
    description: 'アカウント作成日時',
    example: '2025-10-23T10:30:00Z',
  })
  @Expose()
  @Transform(({ value }) => value.toISOString())
  createdAt: Date

  @ApiProperty({
    description: '最終更新日時',
    example: '2025-10-23T10:30:00Z',
  })
  @Expose()
  @Transform(({ value }) => value.toISOString())
  updatedAt: Date

  // パスワードは除外
  @Exclude()
  password: string
}
```

### 更新用DTO

```typescript
// src/users/dto/update-user.dto.ts
import { PartialType } from '@nestjs/swagger'
import { CreateUserDto } from './create-user.dto'

export class UpdateUserDto extends PartialType(CreateUserDto) {
  // PartialTypeにより、CreateUserDtoの全プロパティがオプショナルになる
}
```

## コントローラーの実装

### 基本的なCRUDコントローラー

```typescript
// src/users/users.controller.ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  HttpCode,
  HttpStatus,
  UseGuards,
} from '@nestjs/common'
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
  ApiNotFoundResponse,
  ApiBadRequestResponse,
  ApiUnauthorizedResponse,
} from '@nestjs/swagger'
import { UsersService } from './users.service'
import { CreateUserDto } from './dto/create-user.dto'
import { UpdateUserDto } from './dto/update-user.dto'
import { UserResponseDto } from './dto/user-response.dto'
import { JwtAuthGuard } from '../auth/jwt-auth.guard'

@ApiTags('users')
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({
    summary: 'ユーザーを作成',
    description: '新しいユーザーアカウントを作成します。',
  })
  @ApiCreatedResponse({
    description: 'ユーザーが正常に作成されました。',
    type: UserResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'リクエストデータが無効です。',
    schema: {
      type: 'object',
      properties: {
        statusCode: { type: 'number', example: 400 },
        message: { type: 'array', items: { type: 'string' } },
        error: { type: 'string', example: 'Bad Request' },
      },
    },
  })
  async create(@Body() createUserDto: CreateUserDto): Promise<UserResponseDto> {
    return this.usersService.create(createUserDto)
  }

  @Get()
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({
    summary: '全ユーザーを取得',
    description: 'システムに登録されている全ユーザーの一覧を取得します。',
  })
  @ApiOkResponse({
    description: 'ユーザー一覧を正常に取得しました。',
    type: [UserResponseDto],
  })
  @ApiUnauthorizedResponse({
    description: '認証が必要です。',
    schema: {
      type: 'object',
      properties: {
        statusCode: { type: 'number', example: 401 },
        message: { type: 'string', example: 'Unauthorized' },
      },
    },
  })
  async findAll(): Promise<UserResponseDto[]> {
    return this.usersService.findAll()
  }

  @Get(':id')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({
    summary: 'ユーザーを取得',
    description: '指定されたIDのユーザー情報を取得します。',
  })
  @ApiParam({
    name: 'id',
    description: 'ユーザーID',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @ApiOkResponse({
    description: 'ユーザー情報を正常に取得しました。',
    type: UserResponseDto,
  })
  @ApiNotFoundResponse({
    description: '指定されたユーザーが見つかりません。',
    schema: {
      type: 'object',
      properties: {
        statusCode: { type: 'number', example: 404 },
        message: { type: 'string', example: 'User not found' },
      },
    },
  })
  @ApiUnauthorizedResponse({
    description: '認証が必要です。',
  })
  async findOne(@Param('id') id: string): Promise<UserResponseDto> {
    return this.usersService.findOne(id)
  }

  @Patch(':id')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({
    summary: 'ユーザーを更新',
    description: '指定されたIDのユーザー情報を更新します。',
  })
  @ApiParam({
    name: 'id',
    description: 'ユーザーID',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @ApiOkResponse({
    description: 'ユーザー情報を正常に更新しました。',
    type: UserResponseDto,
  })
  @ApiNotFoundResponse({
    description: '指定されたユーザーが見つかりません。',
  })
  @ApiBadRequestResponse({
    description: 'リクエストデータが無効です。',
  })
  async update(
    @Param('id') id: string,
    @Body() updateUserDto: UpdateUserDto,
  ): Promise<UserResponseDto> {
    return this.usersService.update(id, updateUserDto)
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'ユーザーを削除',
    description: '指定されたIDのユーザーを削除します。',
  })
  @ApiParam({
    name: 'id',
    description: 'ユーザーID',
    example: '123e4567-e89b-12d3-a456-426614174000',
  })
  @ApiResponse({
    status: 204,
    description: 'ユーザーを正常に削除しました。',
  })
  @ApiNotFoundResponse({
    description: '指定されたユーザーが見つかりません。',
  })
  async remove(@Param('id') id: string): Promise<void> {
    return this.usersService.remove(id)
  }
}
```

## 認証機能の統合

### JWT認証の設定

```typescript
// src/auth/auth.controller.ts
import { Controller, Post, Body, HttpCode, HttpStatus } from '@nestjs/common'
import { ApiTags, ApiOperation, ApiResponse, ApiBody } from '@nestjs/swagger'
import { AuthService } from './auth.service'
import { LoginDto } from './dto/login.dto'
import { AuthResponseDto } from './dto/auth-response.dto'

@ApiTags('auth')
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('login')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'ユーザーログイン',
    description: 'メールアドレスとパスワードでログインし、JWTトークンを取得します。',
  })
  @ApiBody({
    type: LoginDto,
    description: 'ログイン情報',
  })
  @ApiResponse({
    status: 200,
    description: 'ログインに成功しました。',
    type: AuthResponseDto,
  })
  @ApiResponse({
    status: 401,
    description: '認証に失敗しました。',
    schema: {
      type: 'object',
      properties: {
        statusCode: { type: 'number', example: 401 },
        message: { type: 'string', example: 'Invalid credentials' },
      },
    },
  })
  async login(@Body() loginDto: LoginDto): Promise<AuthResponseDto> {
    return this.authService.login(loginDto)
  }
}
```

### 認証DTO

```typescript
// src/auth/dto/login.dto.ts
import { ApiProperty } from '@nestjs/swagger'
import { IsEmail, IsNotEmpty, IsString } from 'class-validator'

export class LoginDto {
  @ApiProperty({
    description: 'メールアドレス',
    example: 'user@example.com',
    format: 'email',
  })
  @IsEmail()
  @IsNotEmpty()
  email: string

  @ApiProperty({
    description: 'パスワード',
    example: 'password123',
    writeOnly: true,
  })
  @IsString()
  @IsNotEmpty()
  password: string
}

// src/auth/dto/auth-response.dto.ts
import { ApiProperty } from '@nestjs/swagger'

export class AuthResponseDto {
  @ApiProperty({
    description: 'JWTアクセストークン',
    example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
  })
  accessToken: string

  @ApiProperty({
    description: 'トークンの有効期限（秒）',
    example: 3600,
  })
  expiresIn: number

  @ApiProperty({
    description: 'トークンの種類',
    example: 'Bearer',
  })
  tokenType: string
}
```

## 高度な機能

### カスタムデコレータの作成

```typescript
// src/common/decorators/api-paginated-response.decorator.ts
import { applyDecorators, Type } from '@nestjs/common';
import { ApiOkResponse, getSchemaPath } from '@nestjs/swagger';

export const ApiPaginatedResponse = <TModel extends Type<any>>(
  model: TModel,
) => {
  return applyDecorators(
    ApiOkResponse({
      description: 'ページネーション付きレスポンス',
      schema: {
        type: 'object',
        properties: {
          data: {
            type: 'array',
            items: { $ref: getSchemaPath(model) },
          },
          meta: {
            type: 'object',
            properties: {
              total: { type: 'number', example: 100 },
              page: { type: 'number', example: 1 },
              limit: { type: 'number', example: 10 },
              totalPages: { type: 'number', example: 10 },
            },
          },
        },
      },
    }),
  );
};

// 使用例
@Get()
@ApiPaginatedResponse(UserResponseDto)
async findAll(@Query() query: PaginationQueryDto): Promise<PaginatedResponse<UserResponseDto>> {
  return this.usersService.findAll(query);
}
```

### ファイルアップロードの設定

```typescript
// src/users/users.controller.ts
import { UseInterceptors, UploadedFile } from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { ApiConsumes, ApiBody } from '@nestjs/swagger';

@Post(':id/avatar')
@UseInterceptors(FileInterceptor('file'))
@ApiOperation({
  summary: 'ユーザーアバターをアップロード',
  description: 'ユーザーのプロフィール画像をアップロードします。',
})
@ApiConsumes('multipart/form-data')
@ApiBody({
  description: 'アバター画像ファイル',
  schema: {
    type: 'object',
    properties: {
      file: {
        type: 'string',
        format: 'binary',
        description: '画像ファイル（JPEG、PNG、GIF）',
      },
    },
  },
})
@ApiResponse({
  status: 200,
  description: 'アバターが正常にアップロードされました。',
  schema: {
    type: 'object',
    properties: {
      message: { type: 'string', example: 'Avatar uploaded successfully' },
      avatarUrl: { type: 'string', example: '/uploads/avatars/user123.jpg' },
    },
  },
})
async uploadAvatar(
  @Param('id') id: string,
  @UploadedFile() file: Express.Multer.File,
) {
  return this.usersService.uploadAvatar(id, file);
}
```

### エラーレスポンスの統一

```typescript
// src/common/dto/error-response.dto.ts
import { ApiProperty } from '@nestjs/swagger'

export class ErrorResponseDto {
  @ApiProperty({
    description: 'HTTPステータスコード',
    example: 400,
  })
  statusCode: number

  @ApiProperty({
    description: 'エラーメッセージ',
    example: 'Validation failed',
  })
  message: string | string[]

  @ApiProperty({
    description: 'エラーの種類',
    example: 'Bad Request',
  })
  error: string

  @ApiProperty({
    description: 'タイムスタンプ',
    example: '2025-10-23T10:30:00.000Z',
  })
  timestamp: string

  @ApiProperty({
    description: 'エラーが発生したパス',
    example: '/api/users',
  })
  path: string
}

// src/common/filters/http-exception.filter.ts
import { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus } from '@nestjs/common'
import { Response } from 'express'

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp()
    const response = ctx.getResponse<Response>()
    const request = ctx.getRequest()
    const status = exception.getStatus()

    const errorResponse = {
      statusCode: status,
      message: exception.message,
      error: exception.name,
      timestamp: new Date().toISOString(),
      path: request.url,
    }

    response.status(status).json(errorResponse)
  }
}
```

## 環境別設定

### 開発環境用設定

```typescript
// src/config/swagger.config.ts
import { DocumentBuilder } from '@nestjs/swagger'

export const createSwaggerConfig = (appName: string, version: string) => {
  return new DocumentBuilder()
    .setTitle(`${appName} API`)
    .setDescription(`The ${appName} API documentation`)
    .setVersion(version)
    .addBearerAuth(
      {
        type: 'http',
        scheme: 'bearer',
        bearerFormat: 'JWT',
        name: 'JWT',
        description: 'Enter JWT token',
        in: 'header',
      },
      'JWT-auth',
    )
    .addTag('auth', '認証関連のエンドポイント')
    .addTag('users', 'ユーザー管理のエンドポイント')
    .addTag('posts', '投稿管理のエンドポイント')
    .addServer('http://localhost:3000', '開発環境')
    .addServer('https://api.example.com', '本番環境')
    .build()
}
```

### 本番環境での設定

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core'
import { ValidationPipe } from '@nestjs/common'
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger'
import { AppModule } from './app.module'

async function bootstrap() {
  const app = await NestFactory.create(AppModule)

  // 本番環境ではSwaggerを無効化
  if (process.env.NODE_ENV !== 'production') {
    const config = new DocumentBuilder()
      .setTitle('My API')
      .setDescription('The API description')
      .setVersion('1.0')
      .addBearerAuth()
      .build()

    const document = SwaggerModule.createDocument(app, config)
    SwaggerModule.setup('api', app, document, {
      swaggerOptions: {
        persistAuthorization: true,
      },
    })
  }

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    }),
  )

  await app.listen(process.env.PORT || 3000)
}
bootstrap()
```

## テストとの統合

### E2EテストでのSwagger検証

```typescript
// test/users.e2e-spec.ts
import { Test, TestingModule } from '@nestjs/testing'
import { INestApplication } from '@nestjs/common'
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger'
import * as request from 'supertest'
import { AppModule } from '../src/app.module'

describe('Users (e2e)', () => {
  let app: INestApplication

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile()

    app = moduleFixture.createNestApplication()

    // Swagger設定
    const config = new DocumentBuilder().setTitle('Test API').setVersion('1.0').build()
    const document = SwaggerModule.createDocument(app, config)
    SwaggerModule.setup('api', app, document)

    await app.init()
  })

  it('/api (GET)', () => {
    return request(app.getHttpServer())
      .get('/api-json')
      .expect(200)
      .expect((res) => {
        expect(res.body).toHaveProperty('openapi')
        expect(res.body).toHaveProperty('info')
        expect(res.body).toHaveProperty('paths')
      })
  })

  afterAll(async () => {
    await app.close()
  })
})
```

## まとめ

NestJS/Swaggerを活用することで、以下のような効果が得られます：

### 主なメリット

- **自動ドキュメント生成**: デコレータベースの直感的なAPI定義
- **型安全性**: TypeScriptの型情報を活用したスキーマ生成
- **インタラクティブなテスト**: Swagger UIでのAPIテスト機能
- **認証統合**: JWT、OAuth2などの認証機能を簡単に統合
- **保守性の向上**: コードとドキュメントの同期

### 実装のポイント

- **適切なDTO設計**: バリデーションとSwaggerデコレータの組み合わせ
- **エラーハンドリング**: 統一されたエラーレスポンスの定義
- **認証設定**: セキュリティ要件に応じた認証機能の統合
- **環境別設定**: 開発・本番環境での適切な設定分離

### 参考リンク

- [NestJS公式ドキュメント](https://docs.nestjs.com/openapi/introduction)
- [OpenAPI仕様](https://swagger.io/specification/)
- [Swagger UI](https://swagger.io/tools/swagger-ui/)
- [class-validator](https://github.com/typestack/class-validator)
- [class-transformer](https://github.com/typestack/class-transformer)

NestJS/Swaggerを活用することで、開発効率とAPIの品質を大幅に向上させることができます。適切な設計と実装により、保守性の高いAPIドキュメントを構築しましょう。
