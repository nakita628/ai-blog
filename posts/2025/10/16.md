---
date: 2025-10-16
title: React Server Components（RSC）完全入門：サーバーサイドレンダリングの新時代を初心者向けに解説
description: React Server Components（RSC）の基本概念から実装方法まで、初心者向けに詳しく解説。従来のSSRとの違い、メリット・デメリット、Next.js 13+での実装例を通じて、RSCの理解を深める実践的なガイド。
tags:
    - react
    - rsc
    - server-components
    - nextjs
    - ssr
    - web-development
    - javascript
    - typescript
prev:
    text: "uvで作るPython monorepo完全ガイド：ワークスペース管理とプロジェクト構造のベストプラクティス"
    link: "/posts/2025/10/15"
next: false
---

# React Server Components（RSC）完全入門：サーバーサイドレンダリングの新時代を初心者向けに解説

React Server Components（RSC）は、React 18で導入された革新的な機能です。従来のクライアントサイドレンダリングとは異なり、サーバーサイドでコンポーネントを実行することで、パフォーマンスの向上とバンドルサイズの削減を実現します。この記事では、RSCの基本概念から実装方法まで、初心者向けに詳しく解説します。

## React Server Componentsとは

React Server Components（RSC）は、サーバーサイドで実行されるReactコンポーネントです。従来のReactコンポーネントはクライアント（ブラウザ）で実行されていましたが、RSCはサーバーで実行され、その結果がクライアントに送信されます。

### 従来のReactとの違い

```jsx
// 従来のクライアントコンポーネント
function ClientComponent() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .then(setData);
  }, []);
  
  return <div>{data ? data.title : 'Loading...'}</div>;
}
```

```jsx
// React Server Component
async function ServerComponent() {
  // サーバーサイドで直接データを取得
  const data = await fetch('https://api.example.com/data');
  const json = await data.json();
  
  return <div>{json.title}</div>;
}
```

## RSCの主要な特徴

### 1. サーバーサイド実行

RSCはサーバーで実行されるため、以下のような処理が可能です：

- データベースへの直接アクセス
- ファイルシステムの読み書き
- 外部APIの呼び出し
- 機密情報の処理

### 2. バンドルサイズの削減

RSCはサーバーで実行されるため、クライアントのJavaScriptバンドルに含まれません：

```jsx
// このライブラリはクライアントバンドルに含まれない
import fs from 'fs';
import { PrismaClient } from '@prisma/client';

async function ServerComponent() {
  const prisma = new PrismaClient();
  const users = await prisma.user.findMany();
  
  return (
    <div>
      {users.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
}
```

### 3. 自動的なコード分割

RSCは自動的にコード分割され、必要な部分のみがクライアントに送信されます。

## RSCと従来のSSRの違い

### 従来のSSR（Server-Side Rendering）

```jsx
// 従来のSSR
function App() {
  return (
    <div>
      <Header />
      <Main />
      <Footer />
    </div>
  );
}

// サーバーでHTMLを生成してクライアントに送信
// クライアントでハイドレーション（再実行）
```

### RSC（React Server Components）

```jsx
// RSC
async function App() {
  return (
    <div>
      <Header />
      <ServerMain />  {/* サーバーで実行 */}
      <ClientFooter /> {/* クライアントで実行 */}
    </div>
  );
}

// サーバーでコンポーネントを実行し、結果をストリーミング
```

## Next.js 13+でのRSC実装

Next.js 13以降では、App RouterでRSCがデフォルトで有効になっています。

### プロジェクトのセットアップ

```bash
# Next.js 13+プロジェクトを作成
npx create-next-app@latest my-rsc-app --typescript --tailwind --eslint
cd my-rsc-app
```

### 基本的なRSCの実装

```jsx
// app/page.tsx（デフォルトでServer Component）
import { Suspense } from 'react';

// これはServer Component
async function ServerComponent() {
  // サーバーサイドでデータを取得
  const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
  const post = await response.json();
  
  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold">{post.title}</h1>
      <p className="mt-2">{post.body}</p>
    </div>
  );
}

// クライアントコンポーネント
'use client';

import { useState } from 'react';

function ClientComponent() {
  const [count, setCount] = useState(0);
  
  return (
    <div className="p-4">
      <button 
        onClick={() => setCount(count + 1)}
        className="bg-blue-500 text-white px-4 py-2 rounded"
      >
        Count: {count}
      </button>
    </div>
  );
}

// メインページ
export default function HomePage() {
  return (
    <main className="container mx-auto">
      <h1 className="text-3xl font-bold text-center my-8">
        React Server Components Demo
      </h1>
      
      <Suspense fallback={<div>Loading server component...</div>}>
        <ServerComponent />
      </Suspense>
      
      <ClientComponent />
    </main>
  );
}
```

### データベースとの連携

```jsx
// app/posts/page.tsx
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function PostsList() {
  // サーバーサイドでデータベースから直接データを取得
  const posts = await prisma.post.findMany({
    include: {
      author: true,
    },
    take: 10,
  });

  return (
    <div className="space-y-4">
      {posts.map((post) => (
        <article key={post.id} className="border p-4 rounded">
          <h2 className="text-xl font-semibold">{post.title}</h2>
          <p className="text-gray-600">By {post.author.name}</p>
          <p className="mt-2">{post.content}</p>
        </article>
      ))}
    </div>
  );
}

export default function PostsPage() {
  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-bold mb-8">Posts</h1>
      <PostsList />
    </div>
  );
}
```

### ストリーミングとSuspense

```jsx
// app/dashboard/page.tsx
import { Suspense } from 'react';

async function UserProfile({ userId }: { userId: string }) {
  // ユーザー情報の取得（時間がかかる処理）
  const user = await fetch(`/api/users/${userId}`).then(res => res.json());
  
  return (
    <div className="bg-white p-4 rounded shadow">
      <h2 className="text-xl font-semibold">{user.name}</h2>
      <p className="text-gray-600">{user.email}</p>
    </div>
  );
}

async function UserPosts({ userId }: { userId: string }) {
  // 投稿の取得（別の時間がかかる処理）
  const posts = await fetch(`/api/users/${userId}/posts`).then(res => res.json());
  
  return (
    <div className="space-y-2">
      {posts.map((post: any) => (
        <div key={post.id} className="p-2 border rounded">
          <h3 className="font-medium">{post.title}</h3>
        </div>
      ))}
    </div>
  );
}

export default function DashboardPage() {
  const userId = '123';
  
  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-bold mb-8">Dashboard</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <Suspense fallback={<div>Loading profile...</div>}>
          <UserProfile userId={userId} />
        </Suspense>
        
        <Suspense fallback={<div>Loading posts...</div>}>
          <UserPosts userId={userId} />
        </Suspense>
      </div>
    </div>
  );
}
```

## RSCのメリット

### 1. パフォーマンスの向上

- **初期ロード時間の短縮**: サーバーでレンダリングされたHTMLが送信される
- **バンドルサイズの削減**: サーバーコンポーネントはクライアントバンドルに含まれない
- **ストリーミング**: コンポーネントごとに段階的にレンダリング

### 2. 開発体験の向上

- **直接的なデータアクセス**: データベースやAPIに直接アクセス可能
- **型安全性**: TypeScriptとの相性が良い
- **自動的な最適化**: フレームワークが自動的に最適化

### 3. セキュリティの向上

- **機密情報の保護**: APIキーやデータベース認証情報をクライアントに送信しない
- **サーバーサイド検証**: サーバーでデータの検証を実行

## RSCのデメリットと制限

### 1. インタラクティブ性の制限

```jsx
// ❌ RSCでは使用できない
async function ServerComponent() {
  const [state, setState] = useState(0); // エラー
  const handleClick = () => {}; // イベントハンドラーは使用不可
  
  return <button onClick={handleClick}>Click me</button>;
}

// ✅ クライアントコンポーネントで実装
'use client';

function ClientComponent() {
  const [state, setState] = useState(0);
  const handleClick = () => setState(state + 1);
  
  return <button onClick={handleClick}>Count: {state}</button>;
}
```

### 2. ブラウザAPIの制限

```jsx
// ❌ RSCでは使用できない
async function ServerComponent() {
  const userAgent = navigator.userAgent; // エラー
  const localStorage = window.localStorage; // エラー
  
  return <div>User Agent: {userAgent}</div>;
}
```

### 3. 学習コスト

- 新しい概念の理解が必要
- サーバーとクライアントの境界の理解
- 適切なコンポーネント分割の判断

## 実践的なパターン

### 1. ハイブリッドコンポーネント

```jsx
// app/products/page.tsx
import { Suspense } from 'react';

// サーバーコンポーネント：データ取得
async function ProductList() {
  const products = await fetch('https://api.example.com/products').then(res => res.json());
  
  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
      {products.map((product: any) => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}

// クライアントコンポーネント：インタラクション
'use client';

import { useState } from 'react';

function ProductCard({ product }: { product: any }) {
  const [isLiked, setIsLiked] = useState(false);
  
  return (
    <div className="border rounded p-4">
      <h3 className="font-semibold">{product.name}</h3>
      <p className="text-gray-600">${product.price}</p>
      <button 
        onClick={() => setIsLiked(!isLiked)}
        className={`mt-2 px-3 py-1 rounded ${
          isLiked ? 'bg-red-500 text-white' : 'bg-gray-200'
        }`}
      >
        {isLiked ? '❤️' : '🤍'}
      </button>
    </div>
  );
}

export default function ProductsPage() {
  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-bold mb-8">Products</h1>
      <Suspense fallback={<div>Loading products...</div>}>
        <ProductList />
      </Suspense>
    </div>
  );
}
```

### 2. フォーム処理

```jsx
// app/contact/page.tsx
import { redirect } from 'next/navigation';

// サーバーアクション
async function submitContact(formData: FormData) {
  'use server';
  
  const name = formData.get('name') as string;
  const email = formData.get('email') as string;
  const message = formData.get('message') as string;
  
  // サーバーサイドでバリデーション
  if (!name || !email || !message) {
    throw new Error('All fields are required');
  }
  
  // データベースに保存
  // await saveContact({ name, email, message });
  
  redirect('/contact/success');
}

export default function ContactPage() {
  return (
    <div className="container mx-auto py-8 max-w-md">
      <h1 className="text-3xl font-bold mb-8">Contact Us</h1>
      
      <form action={submitContact} className="space-y-4">
        <div>
          <label htmlFor="name" className="block text-sm font-medium">
            Name
          </label>
          <input
            type="text"
            id="name"
            name="name"
            required
            className="mt-1 block w-full border rounded px-3 py-2"
          />
        </div>
        
        <div>
          <label htmlFor="email" className="block text-sm font-medium">
            Email
          </label>
          <input
            type="email"
            id="email"
            name="email"
            required
            className="mt-1 block w-full border rounded px-3 py-2"
          />
        </div>
        
        <div>
          <label htmlFor="message" className="block text-sm font-medium">
            Message
          </label>
          <textarea
            id="message"
            name="message"
            required
            rows={4}
            className="mt-1 block w-full border rounded px-3 py-2"
          />
        </div>
        
        <button
          type="submit"
          className="w-full bg-blue-500 text-white py-2 px-4 rounded hover:bg-blue-600"
        >
          Send Message
        </button>
      </form>
    </div>
  );
}
```

## パフォーマンス最適化

### 1. 適切なキャッシュ戦略

```jsx
// app/blog/page.tsx
import { cache } from 'react';

// リクエストごとにキャッシュ
const getPosts = cache(async () => {
  const posts = await fetch('https://api.example.com/posts', {
    next: { revalidate: 3600 } // 1時間キャッシュ
  }).then(res => res.json());
  
  return posts;
});

async function BlogPage() {
  const posts = await getPosts();
  
  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-bold mb-8">Blog</h1>
      <div className="space-y-4">
        {posts.map((post: any) => (
          <article key={post.id} className="border p-4 rounded">
            <h2 className="text-xl font-semibold">{post.title}</h2>
            <p className="text-gray-600">{post.excerpt}</p>
          </article>
        ))}
      </div>
    </div>
  );
}
```

### 2. 段階的なストリーミング

```jsx
// app/dashboard/page.tsx
import { Suspense } from 'react';

async function QuickStats() {
  // 高速な統計データ
  const stats = await fetch('/api/stats/quick').then(res => res.json());
  
  return (
    <div className="grid grid-cols-3 gap-4 mb-8">
      <div className="bg-blue-100 p-4 rounded">
        <h3 className="font-semibold">Total Users</h3>
        <p className="text-2xl font-bold">{stats.totalUsers}</p>
      </div>
      <div className="bg-green-100 p-4 rounded">
        <h3 className="font-semibold">Active Today</h3>
        <p className="text-2xl font-bold">{stats.activeToday}</p>
      </div>
      <div className="bg-yellow-100 p-4 rounded">
        <h3 className="font-semibold">Revenue</h3>
        <p className="text-2xl font-bold">${stats.revenue}</p>
      </div>
    </div>
  );
}

async function DetailedAnalytics() {
  // 時間のかかる詳細分析
  const analytics = await fetch('/api/analytics/detailed').then(res => res.json());
  
  return (
    <div className="bg-white p-6 rounded shadow">
      <h2 className="text-xl font-semibold mb-4">Detailed Analytics</h2>
      {/* 詳細な分析データの表示 */}
    </div>
  );
}

export default function DashboardPage() {
  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-bold mb-8">Dashboard</h1>
      
      {/* 即座に表示される統計 */}
      <QuickStats />
      
      {/* 後からストリーミングされる詳細分析 */}
      <Suspense fallback={<div>Loading detailed analytics...</div>}>
        <DetailedAnalytics />
      </Suspense>
    </div>
  );
}
```

## まとめ

React Server Components（RSC）は、Reactアプリケーションのパフォーマンスと開発体験を大幅に改善する革新的な機能です。主なポイントは以下の通りです：

### 主要な特徴
- **サーバーサイド実行**: サーバーでコンポーネントを実行し、結果をクライアントに送信
- **バンドルサイズ削減**: サーバーコンポーネントはクライアントバンドルに含まれない
- **直接的なデータアクセス**: データベースやAPIに直接アクセス可能

### 適用場面
- **データ取得が中心のコンポーネント**: ブログ記事、商品一覧、ユーザープロフィール
- **静的コンテンツ**: ヘッダー、フッター、ナビゲーション
- **SEOが重要なページ**: ランディングページ、ブログ、商品ページ

### 注意点
- **インタラクティブな機能**: 状態管理やイベントハンドラーはクライアントコンポーネントで実装
- **ブラウザAPI**: `navigator`や`window`などのブラウザAPIは使用不可
- **適切な境界の設定**: サーバーとクライアントの役割分担を明確にする

RSCを活用することで、より高速で効率的なReactアプリケーションを構築できます。Next.js 13+のApp Routerと組み合わせることで、簡単にRSCを導入できるため、ぜひ試してみてください。
