---
date: 2025-10-03
title: Drizzle ORM入門完全ガイド：TypeScriptで型安全なデータベース操作を初心者向けに解説
description: Drizzle ORMの基本から実践的な使い方まで、初心者にも分かりやすく解説。TypeScriptの型安全性を活かしたデータベース操作、スキーマ定義、クエリの書き方、マイグレーションなど、実際のコード例と共に詳しく説明する。
tags:
    - drizzle-orm
    - typescript
    - database
    - orm
    - sql
    - beginner
    - tutorial
prev:
    text: "Python有名ライブラリ完全ガイド：初心者でもわかる人気ライブラリの使い方と選び方"
    link: "/posts/2025/10/02"
next: false
---

# Drizzle ORM入門完全ガイド：TypeScriptで型安全なデータベース操作を初心者向けに解説

Drizzle ORMは、TypeScriptの型安全性を最大限に活用したモダンなORM（Object-Relational Mapping）ライブラリです。[Drizzle公式サイト](https://orm.drizzle.team/)でも紹介されているように、軽量で高速、そして型安全なデータベース操作を提供します。この記事では、初心者にも分かりやすくDrizzle ORMの基本から実践的な使い方まで詳しく解説します。

## Drizzle ORMとは

Drizzle ORMは、TypeScriptとJavaScriptで使用できる軽量なORMライブラリです。従来のORMとは異なり、SQLに近い書き方でクエリを記述でき、TypeScriptの型システムを活用してコンパイル時にエラーを検出できます。

### 主な特徴

- **型安全性**: TypeScriptの型システムを活用した完全な型安全
- **軽量**: バンドルサイズが小さく、パフォーマンスが高い
- **SQLライク**: 直感的で理解しやすいクエリ構文
- **多様なデータベース対応**: PostgreSQL、MySQL、SQLiteなどに対応
- **マイグレーション**: スキーマの変更を安全に管理

## プロジェクトのセットアップ

### 必要なパッケージのインストール

```bash
# 基本的なパッケージ
npm install drizzle-orm
npm install -D drizzle-kit

# データベースドライバー（例：SQLite）
npm install better-sqlite3
npm install -D @types/better-sqlite3

# またはPostgreSQLの場合
npm install pg
npm install -D @types/pg
```

### 設定ファイルの作成

```typescript
// drizzle.config.ts
import type { Config } from 'drizzle-kit';

export default {
  schema: './src/db/schema.ts',
  out: './drizzle',
  driver: 'better-sqlite',
  dbCredentials: {
    url: './sqlite.db',
  },
} satisfies Config;
```

## スキーマの定義

Drizzle ORMでは、TypeScriptの型システムを活用してスキーマを定義します。

```typescript
// src/db/schema.ts
import { sqliteTable, text, integer, real } from 'drizzle-orm/sqlite-core';
import { relations } from 'drizzle-orm';

// ユーザーテーブル
export const users = sqliteTable('users', {
  id: text('id').primaryKey(),
  name: text('name').notNull(),
  email: text('email').notNull().unique(),
  age: integer('age'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
});

// 投稿テーブル
export const posts = sqliteTable('posts', {
  id: text('id').primaryKey(),
  title: text('title').notNull(),
  content: text('content'),
  authorId: text('author_id').notNull().references(() => users.id),
  published: integer('published', { mode: 'boolean' }).default(false),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
});

// リレーションの定義
export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}));

export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id],
  }),
}));

// 型のエクスポート
export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;
export type Post = typeof posts.$inferSelect;
export type NewPost = typeof posts.$inferInsert;
```

## データベース接続の設定

```typescript
// src/db/index.ts
import { drizzle } from 'drizzle-orm/better-sqlite3';
import Database from 'better-sqlite3';
import * as schema from './schema';

// SQLiteデータベースの作成
const sqlite = new Database('sqlite.db');

// Drizzleインスタンスの作成
export const db = drizzle(sqlite, { schema });

// PostgreSQLの場合の例
/*
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

const connectionString = process.env.DATABASE_URL!;
const client = postgres(connectionString);
export const db = drizzle(client, { schema });
*/
```

## 基本的なCRUD操作

### データの挿入（Create）

```typescript
// src/operations/users.ts
import { db } from '../db';
import { users } from '../db/schema';
import { eq } from 'drizzle-orm';

// 単一ユーザーの作成
export async function createUser(userData: {
  id: string;
  name: string;
  email: string;
  age?: number;
}) {
  const newUser = await db.insert(users).values({
    ...userData,
    createdAt: new Date(),
    updatedAt: new Date(),
  }).returning();
  
  return newUser[0];
}

// 複数ユーザーの一括作成
export async function createUsers(usersData: Array<{
  id: string;
  name: string;
  email: string;
  age?: number;
}>) {
  const newUsers = await db.insert(users).values(
    usersData.map(user => ({
      ...user,
      createdAt: new Date(),
      updatedAt: new Date(),
    }))
  ).returning();
  
  return newUsers;
}
```

### データの読み取り（Read）

```typescript
// 全ユーザーの取得
export async function getAllUsers() {
  return await db.select().from(users);
}

// IDによる単一ユーザーの取得
export async function getUserById(id: string) {
  const result = await db.select().from(users).where(eq(users.id, id));
  return result[0] || null;
}

// 条件付きクエリ
export async function getUsersByAge(minAge: number) {
  return await db.select().from(users).where(gte(users.age, minAge));
}

// リレーションを含むクエリ
export async function getUserWithPosts(userId: string) {
  return await db.query.users.findFirst({
    where: eq(users.id, userId),
    with: {
      posts: true,
    },
  });
}
```

### データの更新（Update）

```typescript
// ユーザー情報の更新
export async function updateUser(id: string, updateData: {
  name?: string;
  email?: string;
  age?: number;
}) {
  const updatedUser = await db.update(users)
    .set({
      ...updateData,
      updatedAt: new Date(),
    })
    .where(eq(users.id, id))
    .returning();
  
  return updatedUser[0];
}

// 条件付き更新
export async function updateUsersByAge(minAge: number, updateData: {
  name?: string;
  email?: string;
}) {
  return await db.update(users)
    .set({
      ...updateData,
      updatedAt: new Date(),
    })
    .where(gte(users.age, minAge))
    .returning();
}
```

### データの削除（Delete）

```typescript
// ユーザーの削除
export async function deleteUser(id: string) {
  const deletedUser = await db.delete(users)
    .where(eq(users.id, id))
    .returning();
  
  return deletedUser[0];
}

// 条件付き削除
export async function deleteUsersByAge(maxAge: number) {
  return await db.delete(users)
    .where(lte(users.age, maxAge))
    .returning();
}
```

## 高度なクエリ操作

### 結合（JOIN）クエリ

```typescript
// ユーザーと投稿の結合
export async function getUsersWithPosts() {
  return await db
    .select({
      user: users,
      post: posts,
    })
    .from(users)
    .leftJoin(posts, eq(users.id, posts.authorId));
}

// 集計クエリ
export async function getUserPostCounts() {
  return await db
    .select({
      userId: users.id,
      userName: users.name,
      postCount: count(posts.id),
    })
    .from(users)
    .leftJoin(posts, eq(users.id, posts.authorId))
    .groupBy(users.id, users.name);
}
```

### トランザクション

```typescript
// トランザクションを使用した複数操作
export async function createUserWithPost(userData: {
  id: string;
  name: string;
  email: string;
}, postData: {
  id: string;
  title: string;
  content: string;
}) {
  return await db.transaction(async (tx) => {
    // ユーザーを作成
    const newUser = await tx.insert(users).values({
      ...userData,
      createdAt: new Date(),
      updatedAt: new Date(),
    }).returning();

    // 投稿を作成
    const newPost = await tx.insert(posts).values({
      ...postData,
      authorId: newUser[0].id,
      createdAt: new Date(),
    }).returning();

    return { user: newUser[0], post: newPost[0] };
  });
}
```

## マイグレーション

### マイグレーションファイルの生成

```bash
# スキーマの変更を検出してマイグレーションファイルを生成
npx drizzle-kit generate

# データベースにマイグレーションを適用
npx drizzle-kit migrate

# スキーマを直接プッシュ（開発環境のみ）
npx drizzle-kit push
```

### マイグレーションの例

```typescript
// drizzle/0001_add_user_table.sql
CREATE TABLE `users` (
  `id` text PRIMARY KEY NOT NULL,
  `name` text NOT NULL,
  `email` text NOT NULL,
  `age` integer,
  `created_at` integer NOT NULL,
  `updated_at` integer NOT NULL
);

CREATE UNIQUE INDEX `users_email_unique` ON `users` (`email`);
```

## 実践的なアプリケーション例

### Express.jsとの組み合わせ

```typescript
// src/routes/users.ts
import express from 'express';
import { createUser, getAllUsers, getUserById, updateUser, deleteUser } from '../operations/users';

const router = express.Router();

// 全ユーザー取得
router.get('/', async (req, res) => {
  try {
    const users = await getAllUsers();
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

// 特定ユーザー取得
router.get('/:id', async (req, res) => {
  try {
    const user = await getUserById(req.params.id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch user' });
  }
});

// ユーザー作成
router.post('/', async (req, res) => {
  try {
    const user = await createUser(req.body);
    res.status(201).json(user);
  } catch (error) {
    res.status(400).json({ error: 'Failed to create user' });
  }
});

// ユーザー更新
router.put('/:id', async (req, res) => {
  try {
    const user = await updateUser(req.params.id, req.body);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.json(user);
  } catch (error) {
    res.status(400).json({ error: 'Failed to update user' });
  }
});

// ユーザー削除
router.delete('/:id', async (req, res) => {
  try {
    const user = await deleteUser(req.params.id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.json({ message: 'User deleted successfully' });
  } catch (error) {
    res.status(500).json({ error: 'Failed to delete user' });
  }
});

export default router;
```

## パフォーマンスの最適化

### プリペアドステートメント

```typescript
// プリペアドステートメントの使用
export const getUserByIdPrepared = db
  .select()
  .from(users)
  .where(eq(users.id, placeholder('id')))
  .prepare();

// 使用例
const user = await getUserByIdPrepared.execute({ id: 'user-123' });
```

### バッチ操作

```typescript
// バッチでの挿入
export async function batchInsertUsers(usersData: NewUser[]) {
  return await db.insert(users).values(usersData);
}

// バッチでの更新
export async function batchUpdateUsers(updates: Array<{
  id: string;
  data: Partial<NewUser>;
}>) {
  return await db.transaction(async (tx) => {
    const results = [];
    for (const update of updates) {
      const result = await tx.update(users)
        .set(update.data)
        .where(eq(users.id, update.id))
        .returning();
      results.push(result[0]);
    }
    return results;
  });
}
```

## エラーハンドリング

```typescript
// エラーハンドリングの例
export async function safeCreateUser(userData: NewUser) {
  try {
    const user = await createUser(userData);
    return { success: true, data: user };
  } catch (error) {
    if (error instanceof Error) {
      // 一意制約違反のチェック
      if (error.message.includes('UNIQUE constraint failed')) {
        return { success: false, error: 'Email already exists' };
      }
    }
    return { success: false, error: 'Failed to create user' };
  }
}
```

## まとめ

Drizzle ORMは、TypeScriptの型安全性を最大限に活用したモダンなORMライブラリです。従来のORMと比較して軽量で高速、そして直感的なクエリ構文を提供します。

### 主な利点

- **型安全性**: コンパイル時にエラーを検出
- **パフォーマンス**: 軽量で高速な実行
- **学習コスト**: SQLに近い直感的な構文
- **柔軟性**: 複数のデータベースに対応
- **開発体験**: 優れたTypeScriptサポート

### 学習のポイント

- **スキーマ定義**: TypeScriptの型システムを活用
- **クエリ構文**: SQLに近い直感的な書き方
- **マイグレーション**: スキーマの変更を安全に管理
- **エラーハンドリング**: 適切な例外処理の実装
- **パフォーマンス**: プリペアドステートメントの活用

Drizzle ORMを活用することで、型安全で保守性の高いデータベース操作を実現できます。まずは基本的なCRUD操作から始めて、徐々に高度な機能を学習していきましょう。
