---
date: 2025-10-03
title: Drizzle ORM入門完全ガイド：TypeScriptで型安全なデータベース操作を初心者向けに解説
description: Drizzle ORMの基本から実践的な使い方まで、初心者にも分かりやすく解説。TypeScriptの型安全性を活かしたデータベース操作、スキーマ定義、クエリの書き方、マイグレーションなど、実際のコード例と共に詳しく説明する。
tags:
  - drizzle-orm
  - typescript
  - database
  - orm
  - sql
  - beginner
  - tutorial
prev:
  text: 'Python有名ライブラリ完全ガイド：初心者でもわかる人気ライブラリの使い方と選び方'
  link: '/posts/2025/10/02'
next: false
---

# Drizzle ORM入門完全ガイド：TypeScriptで型安全なデータベース操作を初心者向けに解説

Drizzle ORMは、TypeScriptの型安全性を最大限に活用したモダンなORM（Object-Relational Mapping）ライブラリです。[Drizzle公式サイト](https://orm.drizzle.team/)でも紹介されているように、軽量で高速、そして型安全なデータベース操作を提供します。この記事では、初心者にも分かりやすくDrizzle ORMの基本から実践的な使い方まで詳しく解説します。

## Drizzle ORMとは

Drizzle ORMは、TypeScriptとJavaScriptで使用できる軽量なORMライブラリです。従来のORMとは異なり、SQLに近い書き方でクエリを記述でき、TypeScriptの型システムを活用してコンパイル時にエラーを検出できます。

### 主な特徴

- **型安全性**: TypeScriptの型システムを活用した完全な型安全
- **軽量**: バンドルサイズが小さく、パフォーマンスが高い
- **SQLライク**: 直感的で理解しやすいクエリ構文
- **多様なデータベース対応**: PostgreSQL、MySQL、SQLiteなどに対応
- **マイグレーション**: スキーマの変更を安全に管理

## プロジェクトのセットアップ

### 必要なパッケージのインストール

```bash
# 基本的なパッケージ
npm install drizzle-orm
npm install -D drizzle-kit

# データベースドライバー（例：SQLite）
npm install better-sqlite3
npm install -D @types/better-sqlite3

# またはPostgreSQLの場合
npm install pg
npm install -D @types/pg
```

### 設定ファイルの作成

```typescript
// drizzle.config.ts
import type { Config } from 'drizzle-kit'

export default {
  schema: './src/db/schema.ts',
  out: './drizzle',
  driver: 'better-sqlite',
  dbCredentials: {
    url: './sqlite.db',
  },
} satisfies Config
```

## スキーマの定義

Drizzle ORMでは、TypeScriptの型システムを活用してスキーマを定義します。

```typescript
// src/db/schema.ts
import { sqliteTable, text, integer, real } from 'drizzle-orm/sqlite-core'
import { relations } from 'drizzle-orm'

// ユーザーテーブル
export const users = sqliteTable('users', {
  id: text('id').primaryKey(),
  name: text('name').notNull(),
  email: text('email').notNull().unique(),
  age: integer('age'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
})

// 投稿テーブル
export const posts = sqliteTable('posts', {
  id: text('id').primaryKey(),
  title: text('title').notNull(),
  content: text('content'),
  authorId: text('author_id')
    .notNull()
    .references(() => users.id),
  published: integer('published', { mode: 'boolean' }).default(false),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
})

// リレーションの定義
export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}))

export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id],
  }),
}))

// 型のエクスポート
export type User = typeof users.$inferSelect
export type NewUser = typeof users.$inferInsert
export type Post = typeof posts.$inferSelect
export type NewPost = typeof posts.$inferInsert
```

## データベース接続の設定

```typescript
// src/db/index.ts
import { drizzle } from 'drizzle-orm/better-sqlite3'
import Database from 'better-sqlite3'
import * as schema from './schema'

// SQLiteデータベースの作成
const sqlite = new Database('sqlite.db')

// Drizzleインスタンスの作成
export const db = drizzle(sqlite, { schema })

// PostgreSQLの場合の例
/*
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

const connectionString = process.env.DATABASE_URL!;
const client = postgres(connectionString);
export const db = drizzle(client, { schema });
*/
```

## 基本的なCRUD操作

### データの挿入（Create）

```typescript
// src/operations/users.ts
import { db } from '../db'
import { users } from '../db/schema'
import { eq } from 'drizzle-orm'

// 単一ユーザーの作成
export async function createUser(userData: {
  id: string
  name: string
  email: string
  age?: number
}) {
  const newUser = await db
    .insert(users)
    .values({
      ...userData,
      createdAt: new Date(),
      updatedAt: new Date(),
    })
    .returning()

  return newUser[0]
}

// 複数ユーザーの一括作成
export async function createUsers(
  usersData: Array<{
    id: string
    name: string
    email: string
    age?: number
  }>,
) {
  const newUsers = await db
    .insert(users)
    .values(
      usersData.map((user) => ({
        ...user,
        createdAt: new Date(),
        updatedAt: new Date(),
      })),
    )
    .returning()

  return newUsers
}
```

### データの読み取り（Read）

```typescript
// 全ユーザーの取得
export async function getAllUsers() {
  return await db.select().from(users)
}

// IDによる単一ユーザーの取得
export async function getUserById(id: string) {
  const result = await db.select().from(users).where(eq(users.id, id))
  return result[0] || null
}

// 条件付きクエリ
export async function getUsersByAge(minAge: number) {
  return await db.select().from(users).where(gte(users.age, minAge))
}

// リレーションを含むクエリ
export async function getUserWithPosts(userId: string) {
  return await db.query.users.findFirst({
    where: eq(users.id, userId),
    with: {
      posts: true,
    },
  })
}
```

### データの更新（Update）

```typescript
// ユーザー情報の更新
export async function updateUser(
  id: string,
  updateData: {
    name?: string
    email?: string
    age?: number
  },
) {
  const updatedUser = await db
    .update(users)
    .set({
      ...updateData,
      updatedAt: new Date(),
    })
    .where(eq(users.id, id))
    .returning()

  return updatedUser[0]
}

// 条件付き更新
export async function updateUsersByAge(
  minAge: number,
  updateData: {
    name?: string
    email?: string
  },
) {
  return await db
    .update(users)
    .set({
      ...updateData,
      updatedAt: new Date(),
    })
    .where(gte(users.age, minAge))
    .returning()
}
```

### データの削除（Delete）

```typescript
// ユーザーの削除
export async function deleteUser(id: string) {
  const deletedUser = await db.delete(users).where(eq(users.id, id)).returning()

  return deletedUser[0]
}

// 条件付き削除
export async function deleteUsersByAge(maxAge: number) {
  return await db.delete(users).where(lte(users.age, maxAge)).returning()
}
```

## 高度なクエリ操作

### 結合（JOIN）クエリ

```typescript
// ユーザーと投稿の結合
export async function getUsersWithPosts() {
  return await db
    .select({
      user: users,
      post: posts,
    })
    .from(users)
    .leftJoin(posts, eq(users.id, posts.authorId))
}

// 集計クエリ
export async function getUserPostCounts() {
  return await db
    .select({
      userId: users.id,
      userName: users.name,
      postCount: count(posts.id),
    })
    .from(users)
    .leftJoin(posts, eq(users.id, posts.authorId))
    .groupBy(users.id, users.name)
}
```

### トランザクション

```typescript
// トランザクションを使用した複数操作
export async function createUserWithPost(
  userData: {
    id: string
    name: string
    email: string
  },
  postData: {
    id: string
    title: string
    content: string
  },
) {
  return await db.transaction(async (tx) => {
    // ユーザーを作成
    const newUser = await tx
      .insert(users)
      .values({
        ...userData,
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning()

    // 投稿を作成
    const newPost = await tx
      .insert(posts)
      .values({
        ...postData,
        authorId: newUser[0].id,
        createdAt: new Date(),
      })
      .returning()

    return { user: newUser[0], post: newPost[0] }
  })
}
```

## マイグレーション

### マイグレーションファイルの生成

```bash
# スキーマの変更を検出してマイグレーションファイルを生成
npx drizzle-kit generate

# データベースにマイグレーションを適用
npx drizzle-kit migrate

# スキーマを直接プッシュ（開発環境のみ）
npx drizzle-kit push
```

### マイグレーションの例

```typescript
// drizzle/0001_add_user_table.sql
CREATE TABLE `users` (
  `id` text PRIMARY KEY NOT NULL,
  `name` text NOT NULL,
  `email` text NOT NULL,
  `age` integer,
  `created_at` integer NOT NULL,
  `updated_at` integer NOT NULL
);

CREATE UNIQUE INDEX `users_email_unique` ON `users` (`email`);
```

## 実践的なアプリケーション例

### Express.jsとの組み合わせ

```typescript
// src/routes/users.ts
import express from 'express'
import { createUser, getAllUsers, getUserById, updateUser, deleteUser } from '../operations/users'

const router = express.Router()

// 全ユーザー取得
router.get('/', async (req, res) => {
  try {
    const users = await getAllUsers()
    res.json(users)
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch users' })
  }
})

// 特定ユーザー取得
router.get('/:id', async (req, res) => {
  try {
    const user = await getUserById(req.params.id)
    if (!user) {
      return res.status(404).json({ error: 'User not found' })
    }
    res.json(user)
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch user' })
  }
})

// ユーザー作成
router.post('/', async (req, res) => {
  try {
    const user = await createUser(req.body)
    res.status(201).json(user)
  } catch (error) {
    res.status(400).json({ error: 'Failed to create user' })
  }
})

// ユーザー更新
router.put('/:id', async (req, res) => {
  try {
    const user = await updateUser(req.params.id, req.body)
    if (!user) {
      return res.status(404).json({ error: 'User not found' })
    }
    res.json(user)
  } catch (error) {
    res.status(400).json({ error: 'Failed to update user' })
  }
})

// ユーザー削除
router.delete('/:id', async (req, res) => {
  try {
    const user = await deleteUser(req.params.id)
    if (!user) {
      return res.status(404).json({ error: 'User not found' })
    }
    res.json({ message: 'User deleted successfully' })
  } catch (error) {
    res.status(500).json({ error: 'Failed to delete user' })
  }
})

export default router
```

## パフォーマンスの最適化

### プリペアドステートメント

```typescript
// プリペアドステートメントの使用
export const getUserByIdPrepared = db
  .select()
  .from(users)
  .where(eq(users.id, placeholder('id')))
  .prepare()

// 使用例
const user = await getUserByIdPrepared.execute({ id: 'user-123' })
```

### バッチ操作

```typescript
// バッチでの挿入
export async function batchInsertUsers(usersData: NewUser[]) {
  return await db.insert(users).values(usersData)
}

// バッチでの更新
export async function batchUpdateUsers(
  updates: Array<{
    id: string
    data: Partial<NewUser>
  }>,
) {
  return await db.transaction(async (tx) => {
    const results = []
    for (const update of updates) {
      const result = await tx
        .update(users)
        .set(update.data)
        .where(eq(users.id, update.id))
        .returning()
      results.push(result[0])
    }
    return results
  })
}
```

## エラーハンドリング

```typescript
// エラーハンドリングの例
export async function safeCreateUser(userData: NewUser) {
  try {
    const user = await createUser(userData)
    return { success: true, data: user }
  } catch (error) {
    if (error instanceof Error) {
      // 一意制約違反のチェック
      if (error.message.includes('UNIQUE constraint failed')) {
        return { success: false, error: 'Email already exists' }
      }
    }
    return { success: false, error: 'Failed to create user' }
  }
}
```

## まとめ

Drizzle ORMは、TypeScriptの型安全性を最大限に活用したモダンなORMライブラリです。従来のORMと比較して軽量で高速、そして直感的なクエリ構文を提供します。

### 主な利点

- **型安全性**: コンパイル時にエラーを検出
- **パフォーマンス**: 軽量で高速な実行
- **学習コスト**: SQLに近い直感的な構文
- **柔軟性**: 複数のデータベースに対応
- **開発体験**: 優れたTypeScriptサポート

### 学習のポイント

- **スキーマ定義**: TypeScriptの型システムを活用
- **クエリ構文**: SQLに近い直感的な書き方
- **マイグレーション**: スキーマの変更を安全に管理
- **エラーハンドリング**: 適切な例外処理の実装
- **パフォーマンス**: プリペアドステートメントの活用

Drizzle ORMを活用することで、型安全で保守性の高いデータベース操作を実現できます。まずは基本的なCRUD操作から始めて、徐々に高度な機能を学習していきましょう。
