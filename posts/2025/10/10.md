---
date: 2025-10-10
title: TypeScriptバックエンド開発で使えるnpmライブラリ完全ガイド：初心者向けに人気ライブラリを解説
description: TypeScriptでバックエンドを実装する際によく使われるnpmライブラリについて、初心者にも分かりやすく解説。Webフレームワーク、データベース、認証、バリデーション、テスト、ログ、API開発など、実際のコード例と共に詳しく紹介する。
tags:
  - typescript
  - backend
  - npm
  - libraries
  - nodejs
  - express
  - fastify
  - prisma
  - drizzle
  - beginner
  - tutorial
prev:
  text: '外部キー制約入門完全ガイド：データベースの整合性を保つ重要な仕組みを初心者向けに解説'
  link: '/posts/2025/10/09'
next: false
---

# TypeScriptバックエンド開発で使えるnpmライブラリ完全ガイド：初心者向けに人気ライブラリを解説

TypeScriptでバックエンドを実装する際には、様々なnpmライブラリが活用されます。この記事では、初心者にも分かりやすく、Webフレームワーク、データベース、認証、バリデーション、テスト、ログ、API開発などでよく使われる人気ライブラリを実際のコード例と共に詳しく紹介します。

## TypeScriptバックエンド開発の基本構成

TypeScriptでバックエンドを開発する際の一般的な構成要素：

- **Webフレームワーク**: Express、Fastify、Hono
- **データベース**: Prisma、Drizzle、TypeORM
- **認証**: Passport、JWT、bcrypt
- **バリデーション**: Zod、Joi、class-validator
- **テスト**: Jest、Vitest、Supertest
- **ログ**: Winston、Pino
- **API**: tRPC、GraphQL
- **その他**: dotenv、helmet、cors

## Webフレームワーク

### Express.js - 最も人気のWebフレームワーク

Express.jsは、Node.jsで最も広く使用されているWebフレームワークです。

```bash
npm install express
npm install -D @types/express typescript ts-node nodemon
```

```typescript
// server.ts
import express, { Request, Response, NextFunction } from 'express'
import cors from 'cors'
import helmet from 'helmet'
import dotenv from 'dotenv'

dotenv.config()

const app = express()
const PORT = process.env.PORT || 3000

// ミドルウェア
app.use(helmet())
app.use(cors())
app.use(express.json())
app.use(express.urlencoded({ extended: true }))

// ルート定義
app.get('/', (req: Request, res: Response) => {
  res.json({ message: 'Hello TypeScript Backend!' })
})

app.get('/api/users', (req: Request, res: Response) => {
  const users = [
    { id: 1, name: 'John Doe', email: 'john@example.com' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
  ]
  res.json(users)
})

app.post('/api/users', (req: Request, res: Response) => {
  const { name, email } = req.body
  const newUser = {
    id: Date.now(),
    name,
    email,
  }
  res.status(201).json(newUser)
})

// エラーハンドリングミドルウェア
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error(err.stack)
  res.status(500).json({ error: 'Something went wrong!' })
})

// 404ハンドラー
app.use('*', (req: Request, res: Response) => {
  res.status(404).json({ error: 'Route not found' })
})

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`)
})
```

### Fastify - 高性能なWebフレームワーク

Fastifyは、Expressよりも高速で、TypeScriptとの統合が優れています。

```bash
npm install fastify
npm install -D @types/node
```

```typescript
// server.ts
import Fastify, { FastifyRequest, FastifyReply } from 'fastify'
import cors from '@fastify/cors'
import helmet from '@fastify/helmet'

const fastify = Fastify({
  logger: true,
})

// プラグインの登録
await fastify.register(helmet)
await fastify.register(cors, {
  origin: true,
})

// 型定義
interface User {
  id: number
  name: string
  email: string
}

interface CreateUserRequest extends FastifyRequest {
  body: {
    name: string
    email: string
  }
}

// ルート定義
fastify.get('/', async (request: FastifyRequest, reply: FastifyReply) => {
  return { message: 'Hello Fastify with TypeScript!' }
})

fastify.get('/api/users', async (request: FastifyRequest, reply: FastifyReply) => {
  const users: User[] = [
    { id: 1, name: 'John Doe', email: 'john@example.com' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
  ]
  return users
})

fastify.post('/api/users', async (request: CreateUserRequest, reply: FastifyReply) => {
  const { name, email } = request.body
  const newUser: User = {
    id: Date.now(),
    name,
    email,
  }
  reply.status(201).send(newUser)
})

// サーバー起動
const start = async () => {
  try {
    await fastify.listen({ port: 3000, host: '0.0.0.0' })
    console.log('Server is running on port 3000')
  } catch (err) {
    fastify.log.error(err)
    process.exit(1)
  }
}

start()
```

### Hono - モダンなWebフレームワーク

Honoは、軽量で高速なWebフレームワークです。

```bash
npm install hono
```

```typescript
// server.ts
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { logger } from 'hono/logger'

const app = new Hono()

// ミドルウェア
app.use('*', logger())
app.use('*', cors())

// 型定義
interface User {
  id: number
  name: string
  email: string
}

// ルート定義
app.get('/', (c) => {
  return c.json({ message: 'Hello Hono with TypeScript!' })
})

app.get('/api/users', (c) => {
  const users: User[] = [
    { id: 1, name: 'John Doe', email: 'john@example.com' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
  ]
  return c.json(users)
})

app.post('/api/users', async (c) => {
  const body = await c.req.json()
  const { name, email } = body

  const newUser: User = {
    id: Date.now(),
    name,
    email,
  }

  return c.json(newUser, 201)
})

// サーバー起動
const port = 3000
console.log(`Server is running on port ${port}`)

export default {
  port,
  fetch: app.fetch,
}
```

## データベースライブラリ

### Prisma - モダンなORM

Prismaは、型安全なデータベースアクセスを提供するORMです。

```bash
npm install prisma @prisma/client
npm install -D prisma
```

```typescript
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  posts     Post[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

```typescript
// lib/prisma.ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
```

```typescript
// routes/users.ts
import { Request, Response } from 'express'
import { prisma } from '../lib/prisma'

export const getUsers = async (req: Request, res: Response) => {
  try {
    const users = await prisma.user.findMany({
      include: {
        posts: true,
      },
    })
    res.json(users)
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch users' })
  }
}

export const createUser = async (req: Request, res: Response) => {
  try {
    const { email, name } = req.body
    const user = await prisma.user.create({
      data: {
        email,
        name,
      },
    })
    res.status(201).json(user)
  } catch (error) {
    res.status(500).json({ error: 'Failed to create user' })
  }
}

export const getUserById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const user = await prisma.user.findUnique({
      where: { id: parseInt(id) },
      include: {
        posts: true,
      },
    })

    if (!user) {
      return res.status(404).json({ error: 'User not found' })
    }

    res.json(user)
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch user' })
  }
}
```

### Drizzle ORM - 軽量なORM

Drizzle ORMは、軽量で型安全なORMです。

```bash
npm install drizzle-orm
npm install -D drizzle-kit
```

```typescript
// db/schema.ts
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core'
import { relations } from 'drizzle-orm'

export const users = sqliteTable('users', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  email: text('email').notNull().unique(),
  name: text('name'),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .$defaultFn(() => new Date()),
})

export const posts = sqliteTable('posts', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  title: text('title').notNull(),
  content: text('content'),
  published: integer('published', { mode: 'boolean' }).notNull().default(false),
  authorId: integer('author_id')
    .notNull()
    .references(() => users.id),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .$defaultFn(() => new Date()),
})

export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}))

export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id],
  }),
}))
```

```typescript
// db/index.ts
import { drizzle } from 'drizzle-orm/better-sqlite3'
import Database from 'better-sqlite3'
import * as schema from './schema'

const sqlite = new Database('sqlite.db')
export const db = drizzle(sqlite, { schema })
```

```typescript
// routes/users.ts
import { Request, Response } from 'express'
import { db } from '../db'
import { users, posts } from '../db/schema'
import { eq } from 'drizzle-orm'

export const getUsers = async (req: Request, res: Response) => {
  try {
    const allUsers = await db.query.users.findMany({
      with: {
        posts: true,
      },
    })
    res.json(allUsers)
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch users' })
  }
}

export const createUser = async (req: Request, res: Response) => {
  try {
    const { email, name } = req.body
    const [newUser] = await db
      .insert(users)
      .values({
        email,
        name,
      })
      .returning()
    res.status(201).json(newUser)
  } catch (error) {
    res.status(500).json({ error: 'Failed to create user' })
  }
}
```

## 認証ライブラリ

### JWT認証

```bash
npm install jsonwebtoken bcryptjs
npm install -D @types/jsonwebtoken @types/bcryptjs
```

```typescript
// lib/auth.ts
import jwt from 'jsonwebtoken'
import bcrypt from 'bcryptjs'

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key'

export interface JWTPayload {
  userId: number
  email: string
}

export const generateToken = (payload: JWTPayload): string => {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: '24h' })
}

export const verifyToken = (token: string): JWTPayload => {
  return jwt.verify(token, JWT_SECRET) as JWTPayload
}

export const hashPassword = async (password: string): Promise<string> => {
  return bcrypt.hash(password, 12)
}

export const comparePassword = async (
  password: string,
  hashedPassword: string,
): Promise<boolean> => {
  return bcrypt.compare(password, hashedPassword)
}
```

```typescript
// middleware/auth.ts
import { Request, Response, NextFunction } from 'express'
import { verifyToken } from '../lib/auth'

export interface AuthenticatedRequest extends Request {
  user?: {
    userId: number
    email: string
  }
}

export const authenticateToken = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  const authHeader = req.headers['authorization']
  const token = authHeader && authHeader.split(' ')[1]

  if (!token) {
    return res.status(401).json({ error: 'Access token required' })
  }

  try {
    const user = verifyToken(token)
    req.user = user
    next()
  } catch (error) {
    return res.status(403).json({ error: 'Invalid or expired token' })
  }
}
```

### Passport.js - 認証ミドルウェア

```bash
npm install passport passport-jwt passport-local
npm install -D @types/passport @types/passport-jwt @types/passport-local
```

```typescript
// config/passport.ts
import passport from 'passport'
import { Strategy as JwtStrategy, ExtractJwt } from 'passport-jwt'
import { Strategy as LocalStrategy } from 'passport-local'
import { prisma } from '../lib/prisma'
import { comparePassword } from '../lib/auth'

// JWT Strategy
passport.use(
  new JwtStrategy(
    {
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: process.env.JWT_SECRET || 'your-secret-key',
    },
    async (payload, done) => {
      try {
        const user = await prisma.user.findUnique({
          where: { id: payload.userId },
        })

        if (user) {
          return done(null, user)
        }
        return done(null, false)
      } catch (error) {
        return done(error, false)
      }
    },
  ),
)

// Local Strategy
passport.use(
  new LocalStrategy(
    {
      usernameField: 'email',
      passwordField: 'password',
    },
    async (email, password, done) => {
      try {
        const user = await prisma.user.findUnique({
          where: { email },
        })

        if (!user) {
          return done(null, false, { message: 'User not found' })
        }

        const isValidPassword = await comparePassword(password, user.password)
        if (!isValidPassword) {
          return done(null, false, { message: 'Invalid password' })
        }

        return done(null, user)
      } catch (error) {
        return done(error, false)
      }
    },
  ),
)
```

## バリデーションライブラリ

### Zod - 型安全なバリデーション

```bash
npm install zod
```

```typescript
// schemas/user.ts
import { z } from 'zod'

export const createUserSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
})

export const updateUserSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters').optional(),
  email: z.string().email('Invalid email address').optional(),
})

export const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required'),
})

export type CreateUserInput = z.infer<typeof createUserSchema>
export type UpdateUserInput = z.infer<typeof updateUserSchema>
export type LoginInput = z.infer<typeof loginSchema>
```

```typescript
// middleware/validation.ts
import { Request, Response, NextFunction } from 'express'
import { z, ZodSchema } from 'zod'

export const validate = (schema: ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      schema.parse(req.body)
      next()
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          error: 'Validation failed',
          details: error.errors,
        })
      }
      next(error)
    }
  }
}
```

```typescript
// routes/auth.ts
import { Router } from 'express'
import { validate } from '../middleware/validation'
import { createUserSchema, loginSchema } from '../schemas/user'
import { hashPassword, generateToken } from '../lib/auth'
import { prisma } from '../lib/prisma'

const router = Router()

router.post('/register', validate(createUserSchema), async (req, res) => {
  try {
    const { name, email, password } = req.body

    const existingUser = await prisma.user.findUnique({
      where: { email },
    })

    if (existingUser) {
      return res.status(400).json({ error: 'User already exists' })
    }

    const hashedPassword = await hashPassword(password)

    const user = await prisma.user.create({
      data: {
        name,
        email,
        password: hashedPassword,
      },
    })

    const token = generateToken({ userId: user.id, email: user.email })

    res.status(201).json({
      user: { id: user.id, name: user.name, email: user.email },
      token,
    })
  } catch (error) {
    res.status(500).json({ error: 'Failed to create user' })
  }
})

router.post('/login', validate(loginSchema), async (req, res) => {
  try {
    const { email, password } = req.body

    const user = await prisma.user.findUnique({
      where: { email },
    })

    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' })
    }

    const isValidPassword = await comparePassword(password, user.password)
    if (!isValidPassword) {
      return res.status(401).json({ error: 'Invalid credentials' })
    }

    const token = generateToken({ userId: user.id, email: user.email })

    res.json({
      user: { id: user.id, name: user.name, email: user.email },
      token,
    })
  } catch (error) {
    res.status(500).json({ error: 'Failed to login' })
  }
})

export default router
```

## テストライブラリ

### Jest - テストフレームワーク

```bash
npm install -D jest @types/jest ts-jest supertest @types/supertest
```

```typescript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  transform: {
    '^.+\\.ts$': 'ts-jest',
  },
  collectCoverageFrom: ['src/**/*.ts', '!src/**/*.d.ts'],
}
```

```typescript
// tests/auth.test.ts
import request from 'supertest'
import app from '../src/app'
import { prisma } from '../src/lib/prisma'

describe('Auth API', () => {
  beforeEach(async () => {
    // テストデータのクリーンアップ
    await prisma.user.deleteMany()
  })

  afterAll(async () => {
    await prisma.$disconnect()
  })

  describe('POST /api/auth/register', () => {
    it('should register a new user', async () => {
      const userData = {
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123',
      }

      const response = await request(app).post('/api/auth/register').send(userData).expect(201)

      expect(response.body).toHaveProperty('user')
      expect(response.body).toHaveProperty('token')
      expect(response.body.user.email).toBe(userData.email)
    })

    it('should not register user with existing email', async () => {
      const userData = {
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123',
      }

      // 最初のユーザーを作成
      await request(app).post('/api/auth/register').send(userData).expect(201)

      // 同じメールで再度登録を試行
      const response = await request(app).post('/api/auth/register').send(userData).expect(400)

      expect(response.body.error).toBe('User already exists')
    })
  })

  describe('POST /api/auth/login', () => {
    beforeEach(async () => {
      // テストユーザーを作成
      await request(app).post('/api/auth/register').send({
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123',
      })
    })

    it('should login with valid credentials', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@example.com',
          password: 'password123',
        })
        .expect(200)

      expect(response.body).toHaveProperty('user')
      expect(response.body).toHaveProperty('token')
    })

    it('should not login with invalid credentials', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@example.com',
          password: 'wrongpassword',
        })
        .expect(401)

      expect(response.body.error).toBe('Invalid credentials')
    })
  })
})
```

## ログライブラリ

### Winston - ログ管理

```bash
npm install winston
npm install -D @types/winston
```

```typescript
// lib/logger.ts
import winston from 'winston'

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json(),
  ),
  defaultMeta: { service: 'user-service' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
  ],
})

if (process.env.NODE_ENV !== 'production') {
  logger.add(
    new winston.transports.Console({
      format: winston.format.combine(winston.format.colorize(), winston.format.simple()),
    }),
  )
}

export default logger
```

### Pino - 高速なログライブラリ

```bash
npm install pino pino-pretty
```

```typescript
// lib/logger.ts
import pino from 'pino'

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport:
    process.env.NODE_ENV !== 'production'
      ? {
          target: 'pino-pretty',
          options: {
            colorize: true,
          },
        }
      : undefined,
})

export default logger
```

## API開発ライブラリ

### tRPC - 型安全なAPI

```bash
npm install @trpc/server @trpc/client
npm install -D @types/node
```

```typescript
// server/trpc.ts
import { initTRPC } from '@trpc/server'
import { z } from 'zod'

const t = initTRPC.create()

export const router = t.router
export const publicProcedure = t.procedure

// アプリケーションルーター
export const appRouter = router({
  hello: publicProcedure.input(z.object({ name: z.string() })).query(({ input }) => {
    return {
      greeting: `Hello ${input.name}!`,
    }
  }),

  users: router({
    list: publicProcedure.query(async () => {
      const users = await prisma.user.findMany()
      return users
    }),

    create: publicProcedure
      .input(
        z.object({
          name: z.string(),
          email: z.string().email(),
        }),
      )
      .mutation(async ({ input }) => {
        const user = await prisma.user.create({
          data: input,
        })
        return user
      }),
  }),
})

export type AppRouter = typeof appRouter
```

## その他の便利なライブラリ

### 環境変数管理

```bash
npm install dotenv
```

```typescript
// config/env.ts
import dotenv from 'dotenv'

dotenv.config()

export const config = {
  port: process.env.PORT || 3000,
  nodeEnv: process.env.NODE_ENV || 'development',
  jwtSecret: process.env.JWT_SECRET || 'your-secret-key',
  databaseUrl: process.env.DATABASE_URL || 'file:./dev.db',
  corsOrigin: process.env.CORS_ORIGIN || '*',
}
```

### セキュリティ

```bash
npm install helmet cors rate-limiter-flexible
```

```typescript
// middleware/security.ts
import helmet from 'helmet'
import cors from 'cors'
import { RateLimiterMemory } from 'rate-limiter-flexible'

const rateLimiter = new RateLimiterMemory({
  keyPrefix: 'middleware',
  points: 10, // 10 requests
  duration: 1, // per 1 second
})

export const securityMiddleware = [
  helmet(),
  cors({
    origin: process.env.CORS_ORIGIN || '*',
    credentials: true,
  }),
]

export const rateLimitMiddleware = async (req: Request, res: Response, next: NextFunction) => {
  try {
    await rateLimiter.consume(req.ip)
    next()
  } catch (rejRes) {
    res.status(429).send('Too Many Requests')
  }
}
```

## まとめ

TypeScriptでバックエンドを開発する際には、様々なnpmライブラリを活用することで、効率的で保守性の高いアプリケーションを構築できます。

### ライブラリ選択のポイント

- **プロジェクトの要件**: パフォーマンス、スケーラビリティ、開発速度
- **チームの経験**: 既存の知識と学習コスト
- **エコシステム**: コミュニティサポートとドキュメント
- **型安全性**: TypeScriptとの統合度

### 学習のポイント

- **基本的なライブラリ**から始める
- **実際のプロジェクト**で使用して経験を積む
- **公式ドキュメント**を活用する
- **コミュニティのベストプラクティス**を学ぶ

### 推奨される学習順序

1. **Express.js** - Webフレームワークの基本
2. **Prisma** - データベースアクセス
3. **Zod** - バリデーション
4. **Jest** - テスト
5. **Winston** - ログ管理
6. **その他のライブラリ** - 必要に応じて

これらのライブラリを適切に組み合わせることで、TypeScriptで堅牢で拡張性の高いバックエンドアプリケーションを開発できます。まずは基本的なライブラリから始めて、徐々に高度な機能を学習していきましょう。
