---
date: 2025-10-10
title: TypeScriptバックエンド開発で使えるnpmライブラリ完全ガイド：初心者向けに人気ライブラリを解説
description: TypeScriptでバックエンドを実装する際によく使われるnpmライブラリについて、初心者にも分かりやすく解説。Webフレームワーク、データベース、認証、バリデーション、テスト、ログ、API開発など、実際のコード例と共に詳しく紹介する。
tags:
    - typescript
    - backend
    - npm
    - libraries
    - nodejs
    - express
    - fastify
    - prisma
    - drizzle
    - beginner
    - tutorial
prev:
    text: "外部キー制約入門完全ガイド：データベースの整合性を保つ重要な仕組みを初心者向けに解説"
    link: "/posts/2025/10/09"
next: false
---

# TypeScriptバックエンド開発で使えるnpmライブラリ完全ガイド：初心者向けに人気ライブラリを解説

TypeScriptでバックエンドを実装する際には、様々なnpmライブラリが活用されます。この記事では、初心者にも分かりやすく、Webフレームワーク、データベース、認証、バリデーション、テスト、ログ、API開発などでよく使われる人気ライブラリを実際のコード例と共に詳しく紹介します。

## TypeScriptバックエンド開発の基本構成

TypeScriptでバックエンドを開発する際の一般的な構成要素：

- **Webフレームワーク**: Express、Fastify、Hono
- **データベース**: Prisma、Drizzle、TypeORM
- **認証**: Passport、JWT、bcrypt
- **バリデーション**: Zod、Joi、class-validator
- **テスト**: Jest、Vitest、Supertest
- **ログ**: Winston、Pino
- **API**: tRPC、GraphQL
- **その他**: dotenv、helmet、cors

## Webフレームワーク

### Express.js - 最も人気のWebフレームワーク

Express.jsは、Node.jsで最も広く使用されているWebフレームワークです。

```bash
npm install express
npm install -D @types/express typescript ts-node nodemon
```

```typescript
// server.ts
import express, { Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// ミドルウェア
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ルート定義
app.get('/', (req: Request, res: Response) => {
  res.json({ message: 'Hello TypeScript Backend!' });
});

app.get('/api/users', (req: Request, res: Response) => {
  const users = [
    { id: 1, name: 'John Doe', email: 'john@example.com' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
  ];
  res.json(users);
});

app.post('/api/users', (req: Request, res: Response) => {
  const { name, email } = req.body;
  const newUser = {
    id: Date.now(),
    name,
    email,
  };
  res.status(201).json(newUser);
});

// エラーハンドリングミドルウェア
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Something went wrong!' });
});

// 404ハンドラー
app.use('*', (req: Request, res: Response) => {
  res.status(404).json({ error: 'Route not found' });
});

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

### Fastify - 高性能なWebフレームワーク

Fastifyは、Expressよりも高速で、TypeScriptとの統合が優れています。

```bash
npm install fastify
npm install -D @types/node
```

```typescript
// server.ts
import Fastify, { FastifyRequest, FastifyReply } from 'fastify';
import cors from '@fastify/cors';
import helmet from '@fastify/helmet';

const fastify = Fastify({
  logger: true
});

// プラグインの登録
await fastify.register(helmet);
await fastify.register(cors, {
  origin: true
});

// 型定義
interface User {
  id: number;
  name: string;
  email: string;
}

interface CreateUserRequest extends FastifyRequest {
  body: {
    name: string;
    email: string;
  };
}

// ルート定義
fastify.get('/', async (request: FastifyRequest, reply: FastifyReply) => {
  return { message: 'Hello Fastify with TypeScript!' };
});

fastify.get('/api/users', async (request: FastifyRequest, reply: FastifyReply) => {
  const users: User[] = [
    { id: 1, name: 'John Doe', email: 'john@example.com' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
  ];
  return users;
});

fastify.post('/api/users', async (request: CreateUserRequest, reply: FastifyReply) => {
  const { name, email } = request.body;
  const newUser: User = {
    id: Date.now(),
    name,
    email,
  };
  reply.status(201).send(newUser);
});

// サーバー起動
const start = async () => {
  try {
    await fastify.listen({ port: 3000, host: '0.0.0.0' });
    console.log('Server is running on port 3000');
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
};

start();
```

### Hono - モダンなWebフレームワーク

Honoは、軽量で高速なWebフレームワークです。

```bash
npm install hono
```

```typescript
// server.ts
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { logger } from 'hono/logger';

const app = new Hono();

// ミドルウェア
app.use('*', logger());
app.use('*', cors());

// 型定義
interface User {
  id: number;
  name: string;
  email: string;
}

// ルート定義
app.get('/', (c) => {
  return c.json({ message: 'Hello Hono with TypeScript!' });
});

app.get('/api/users', (c) => {
  const users: User[] = [
    { id: 1, name: 'John Doe', email: 'john@example.com' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
  ];
  return c.json(users);
});

app.post('/api/users', async (c) => {
  const body = await c.req.json();
  const { name, email } = body;
  
  const newUser: User = {
    id: Date.now(),
    name,
    email,
  };
  
  return c.json(newUser, 201);
});

// サーバー起動
const port = 3000;
console.log(`Server is running on port ${port}`);

export default {
  port,
  fetch: app.fetch,
};
```

## データベースライブラリ

### Prisma - モダンなORM

Prismaは、型安全なデータベースアクセスを提供するORMです。

```bash
npm install prisma @prisma/client
npm install -D prisma
```

```typescript
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  posts     Post[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

```typescript
// lib/prisma.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

```typescript
// routes/users.ts
import { Request, Response } from 'express';
import { prisma } from '../lib/prisma';

export const getUsers = async (req: Request, res: Response) => {
  try {
    const users = await prisma.user.findMany({
      include: {
        posts: true,
      },
    });
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch users' });
  }
};

export const createUser = async (req: Request, res: Response) => {
  try {
    const { email, name } = req.body;
    const user = await prisma.user.create({
      data: {
        email,
        name,
      },
    });
    res.status(201).json(user);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create user' });
  }
};

export const getUserById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const user = await prisma.user.findUnique({
      where: { id: parseInt(id) },
      include: {
        posts: true,
      },
    });
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch user' });
  }
};
```

### Drizzle ORM - 軽量なORM

Drizzle ORMは、軽量で型安全なORMです。

```bash
npm install drizzle-orm
npm install -D drizzle-kit
```

```typescript
// db/schema.ts
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';
import { relations } from 'drizzle-orm';

export const users = sqliteTable('users', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  email: text('email').notNull().unique(),
  name: text('name'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),
});

export const posts = sqliteTable('posts', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  title: text('title').notNull(),
  content: text('content'),
  published: integer('published', { mode: 'boolean' }).notNull().default(false),
  authorId: integer('author_id').notNull().references(() => users.id),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),
});

export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}));

export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id],
  }),
}));
```

```typescript
// db/index.ts
import { drizzle } from 'drizzle-orm/better-sqlite3';
import Database from 'better-sqlite3';
import * as schema from './schema';

const sqlite = new Database('sqlite.db');
export const db = drizzle(sqlite, { schema });
```

```typescript
// routes/users.ts
import { Request, Response } from 'express';
import { db } from '../db';
import { users, posts } from '../db/schema';
import { eq } from 'drizzle-orm';

export const getUsers = async (req: Request, res: Response) => {
  try {
    const allUsers = await db.query.users.findMany({
      with: {
        posts: true,
      },
    });
    res.json(allUsers);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch users' });
  }
};

export const createUser = async (req: Request, res: Response) => {
  try {
    const { email, name } = req.body;
    const [newUser] = await db.insert(users).values({
      email,
      name,
    }).returning();
    res.status(201).json(newUser);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create user' });
  }
};
```

## 認証ライブラリ

### JWT認証

```bash
npm install jsonwebtoken bcryptjs
npm install -D @types/jsonwebtoken @types/bcryptjs
```

```typescript
// lib/auth.ts
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

export interface JWTPayload {
  userId: number;
  email: string;
}

export const generateToken = (payload: JWTPayload): string => {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: '24h' });
};

export const verifyToken = (token: string): JWTPayload => {
  return jwt.verify(token, JWT_SECRET) as JWTPayload;
};

export const hashPassword = async (password: string): Promise<string> => {
  return bcrypt.hash(password, 12);
};

export const comparePassword = async (password: string, hashedPassword: string): Promise<boolean> => {
  return bcrypt.compare(password, hashedPassword);
};
```

```typescript
// middleware/auth.ts
import { Request, Response, NextFunction } from 'express';
import { verifyToken } from '../lib/auth';

export interface AuthenticatedRequest extends Request {
  user?: {
    userId: number;
    email: string;
  };
}

export const authenticateToken = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  try {
    const user = verifyToken(token);
    req.user = user;
    next();
  } catch (error) {
    return res.status(403).json({ error: 'Invalid or expired token' });
  }
};
```

### Passport.js - 認証ミドルウェア

```bash
npm install passport passport-jwt passport-local
npm install -D @types/passport @types/passport-jwt @types/passport-local
```

```typescript
// config/passport.ts
import passport from 'passport';
import { Strategy as JwtStrategy, ExtractJwt } from 'passport-jwt';
import { Strategy as LocalStrategy } from 'passport-local';
import { prisma } from '../lib/prisma';
import { comparePassword } from '../lib/auth';

// JWT Strategy
passport.use(new JwtStrategy({
  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
  secretOrKey: process.env.JWT_SECRET || 'your-secret-key',
}, async (payload, done) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: payload.userId },
    });
    
    if (user) {
      return done(null, user);
    }
    return done(null, false);
  } catch (error) {
    return done(error, false);
  }
}));

// Local Strategy
passport.use(new LocalStrategy({
  usernameField: 'email',
  passwordField: 'password',
}, async (email, password, done) => {
  try {
    const user = await prisma.user.findUnique({
      where: { email },
    });
    
    if (!user) {
      return done(null, false, { message: 'User not found' });
    }
    
    const isValidPassword = await comparePassword(password, user.password);
    if (!isValidPassword) {
      return done(null, false, { message: 'Invalid password' });
    }
    
    return done(null, user);
  } catch (error) {
    return done(error, false);
  }
}));
```

## バリデーションライブラリ

### Zod - 型安全なバリデーション

```bash
npm install zod
```

```typescript
// schemas/user.ts
import { z } from 'zod';

export const createUserSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

export const updateUserSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters').optional(),
  email: z.string().email('Invalid email address').optional(),
});

export const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required'),
});

export type CreateUserInput = z.infer<typeof createUserSchema>;
export type UpdateUserInput = z.infer<typeof updateUserSchema>;
export type LoginInput = z.infer<typeof loginSchema>;
```

```typescript
// middleware/validation.ts
import { Request, Response, NextFunction } from 'express';
import { z, ZodSchema } from 'zod';

export const validate = (schema: ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      schema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          error: 'Validation failed',
          details: error.errors,
        });
      }
      next(error);
    }
  };
};
```

```typescript
// routes/auth.ts
import { Router } from 'express';
import { validate } from '../middleware/validation';
import { createUserSchema, loginSchema } from '../schemas/user';
import { hashPassword, generateToken } from '../lib/auth';
import { prisma } from '../lib/prisma';

const router = Router();

router.post('/register', validate(createUserSchema), async (req, res) => {
  try {
    const { name, email, password } = req.body;
    
    const existingUser = await prisma.user.findUnique({
      where: { email },
    });
    
    if (existingUser) {
      return res.status(400).json({ error: 'User already exists' });
    }
    
    const hashedPassword = await hashPassword(password);
    
    const user = await prisma.user.create({
      data: {
        name,
        email,
        password: hashedPassword,
      },
    });
    
    const token = generateToken({ userId: user.id, email: user.email });
    
    res.status(201).json({
      user: { id: user.id, name: user.name, email: user.email },
      token,
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to create user' });
  }
});

router.post('/login', validate(loginSchema), async (req, res) => {
  try {
    const { email, password } = req.body;
    
    const user = await prisma.user.findUnique({
      where: { email },
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    const isValidPassword = await comparePassword(password, user.password);
    if (!isValidPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    const token = generateToken({ userId: user.id, email: user.email });
    
    res.json({
      user: { id: user.id, name: user.name, email: user.email },
      token,
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to login' });
  }
});

export default router;
```

## テストライブラリ

### Jest - テストフレームワーク

```bash
npm install -D jest @types/jest ts-jest supertest @types/supertest
```

```typescript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  transform: {
    '^.+\\.ts$': 'ts-jest',
  },
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
  ],
};
```

```typescript
// tests/auth.test.ts
import request from 'supertest';
import app from '../src/app';
import { prisma } from '../src/lib/prisma';

describe('Auth API', () => {
  beforeEach(async () => {
    // テストデータのクリーンアップ
    await prisma.user.deleteMany();
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  describe('POST /api/auth/register', () => {
    it('should register a new user', async () => {
      const userData = {
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123',
      };

      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(201);

      expect(response.body).toHaveProperty('user');
      expect(response.body).toHaveProperty('token');
      expect(response.body.user.email).toBe(userData.email);
    });

    it('should not register user with existing email', async () => {
      const userData = {
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123',
      };

      // 最初のユーザーを作成
      await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(201);

      // 同じメールで再度登録を試行
      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(400);

      expect(response.body.error).toBe('User already exists');
    });
  });

  describe('POST /api/auth/login', () => {
    beforeEach(async () => {
      // テストユーザーを作成
      await request(app)
        .post('/api/auth/register')
        .send({
          name: 'Test User',
          email: 'test@example.com',
          password: 'password123',
        });
    });

    it('should login with valid credentials', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@example.com',
          password: 'password123',
        })
        .expect(200);

      expect(response.body).toHaveProperty('user');
      expect(response.body).toHaveProperty('token');
    });

    it('should not login with invalid credentials', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@example.com',
          password: 'wrongpassword',
        })
        .expect(401);

      expect(response.body.error).toBe('Invalid credentials');
    });
  });
});
```

## ログライブラリ

### Winston - ログ管理

```bash
npm install winston
npm install -D @types/winston
```

```typescript
// lib/logger.ts
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'user-service' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}

export default logger;
```

### Pino - 高速なログライブラリ

```bash
npm install pino pino-pretty
```

```typescript
// lib/logger.ts
import pino from 'pino';

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: process.env.NODE_ENV !== 'production' ? {
    target: 'pino-pretty',
    options: {
      colorize: true,
    },
  } : undefined,
});

export default logger;
```

## API開発ライブラリ

### tRPC - 型安全なAPI

```bash
npm install @trpc/server @trpc/client
npm install -D @types/node
```

```typescript
// server/trpc.ts
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

const t = initTRPC.create();

export const router = t.router;
export const publicProcedure = t.procedure;

// アプリケーションルーター
export const appRouter = router({
  hello: publicProcedure
    .input(z.object({ name: z.string() }))
    .query(({ input }) => {
      return {
        greeting: `Hello ${input.name}!`,
      };
    }),
  
  users: router({
    list: publicProcedure.query(async () => {
      const users = await prisma.user.findMany();
      return users;
    }),
    
    create: publicProcedure
      .input(z.object({
        name: z.string(),
        email: z.string().email(),
      }))
      .mutation(async ({ input }) => {
        const user = await prisma.user.create({
          data: input,
        });
        return user;
      }),
  }),
});

export type AppRouter = typeof appRouter;
```

## その他の便利なライブラリ

### 環境変数管理

```bash
npm install dotenv
```

```typescript
// config/env.ts
import dotenv from 'dotenv';

dotenv.config();

export const config = {
  port: process.env.PORT || 3000,
  nodeEnv: process.env.NODE_ENV || 'development',
  jwtSecret: process.env.JWT_SECRET || 'your-secret-key',
  databaseUrl: process.env.DATABASE_URL || 'file:./dev.db',
  corsOrigin: process.env.CORS_ORIGIN || '*',
};
```

### セキュリティ

```bash
npm install helmet cors rate-limiter-flexible
```

```typescript
// middleware/security.ts
import helmet from 'helmet';
import cors from 'cors';
import { RateLimiterMemory } from 'rate-limiter-flexible';

const rateLimiter = new RateLimiterMemory({
  keyPrefix: 'middleware',
  points: 10, // 10 requests
  duration: 1, // per 1 second
});

export const securityMiddleware = [
  helmet(),
  cors({
    origin: process.env.CORS_ORIGIN || '*',
    credentials: true,
  }),
];

export const rateLimitMiddleware = async (req: Request, res: Response, next: NextFunction) => {
  try {
    await rateLimiter.consume(req.ip);
    next();
  } catch (rejRes) {
    res.status(429).send('Too Many Requests');
  }
};
```

## まとめ

TypeScriptでバックエンドを開発する際には、様々なnpmライブラリを活用することで、効率的で保守性の高いアプリケーションを構築できます。

### ライブラリ選択のポイント

- **プロジェクトの要件**: パフォーマンス、スケーラビリティ、開発速度
- **チームの経験**: 既存の知識と学習コスト
- **エコシステム**: コミュニティサポートとドキュメント
- **型安全性**: TypeScriptとの統合度

### 学習のポイント

- **基本的なライブラリ**から始める
- **実際のプロジェクト**で使用して経験を積む
- **公式ドキュメント**を活用する
- **コミュニティのベストプラクティス**を学ぶ

### 推奨される学習順序

1. **Express.js** - Webフレームワークの基本
2. **Prisma** - データベースアクセス
3. **Zod** - バリデーション
4. **Jest** - テスト
5. **Winston** - ログ管理
6. **その他のライブラリ** - 必要に応じて

これらのライブラリを適切に組み合わせることで、TypeScriptで堅牢で拡張性の高いバックエンドアプリケーションを開発できます。まずは基本的なライブラリから始めて、徐々に高度な機能を学習していきましょう。
