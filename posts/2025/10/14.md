---
date: 2025-10-14
title: FastAPIとOpenAPI完全ガイド：初心者でもわかる自動APIドキュメント生成と実践例
description: FastAPIとOpenAPIを組み合わせた例について、初心者にも分かりやすく解説。自動APIドキュメント生成、型安全なAPI開発、Swagger UI、ReDoc、Pydanticモデル、バリデーション、認証まで実際のコード例と共に詳しく説明する。
tags:
    - fastapi
    - openapi
    - python
    - api
    - swagger
    - redoc
    - pydantic
    - documentation
    - beginner
    - tutorial
prev:
    text: "Vue.js入門完全ガイド：初心者でもわかるプログレッシブJavaScriptフレームワーク"
    link: "/posts/2025/10/11"
next: false
---

# FastAPIとOpenAPI完全ガイド：初心者でもわかる自動APIドキュメント生成と実践例

FastAPIは、PythonでモダンなWeb APIを構築するための高速で使いやすいフレームワークです。[FastAPI公式サイト](https://fastapi.tiangolo.com/ja/)によると、標準的なPythonの型ヒントに基づいて自動的にOpenAPIドキュメントを生成し、Swagger UIやReDocによる対話的なAPIドキュメントを提供します。この記事では、初心者にも分かりやすく、FastAPIとOpenAPIを組み合わせた実践的な例を実際のコードと共に詳しく解説します。

## FastAPIとOpenAPIとは

### FastAPIの特徴

- **高速**: Node.jsやGoと同等の高いパフォーマンス
- **型安全**: Pythonの型ヒントを活用した自動バリデーション
- **自動ドキュメント**: OpenAPI仕様に基づく自動APIドキュメント生成
- **標準準拠**: OpenAPI 3.0とJSON Schemaに完全準拠

### OpenAPIとは

OpenAPIは、RESTful APIを記述するための標準仕様です。FastAPIは、Pythonの型ヒントから自動的にOpenAPIスキーマを生成し、対話的なAPIドキュメントを提供します。

## 基本的なFastAPIアプリケーション

### インストール

```bash
pip install fastapi uvicorn
```

### 最小限のアプリケーション

```python
# main.py
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def read_root():
    return {"Hello": "World"}

@app.get("/items/{item_id}")
def read_item(item_id: int, q: str = None):
    return {"item_id": item_id, "q": q}
```

### アプリケーションの実行

```bash
uvicorn main:app --reload
```

アプリケーションを起動すると、以下のURLでアクセスできます：

- **API**: http://127.0.0.1:8000
- **Swagger UI**: http://127.0.0.1:8000/docs
- **ReDoc**: http://127.0.0.1:8000/redoc
- **OpenAPI JSON**: http://127.0.0.1:8000/openapi.json

## Pydanticモデルを使用したAPI

### 基本的なモデル定義

```python
# models.py
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime
from enum import Enum

class ItemStatus(str, Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"

class ItemBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100, description="アイテム名")
    description: Optional[str] = Field(None, max_length=500, description="アイテムの説明")
    price: float = Field(..., gt=0, description="価格（0より大きい値）")
    status: ItemStatus = Field(ItemStatus.ACTIVE, description="アイテムのステータス")

class ItemCreate(ItemBase):
    pass

class ItemUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    price: Optional[float] = Field(None, gt=0)
    status: Optional[ItemStatus] = None

class Item(ItemBase):
    id: int = Field(..., description="アイテムID")
    created_at: datetime = Field(..., description="作成日時")
    updated_at: datetime = Field(..., description="更新日時")
    
    class Config:
        from_attributes = True

class ItemList(BaseModel):
    items: List[Item]
    total: int
    page: int
    per_page: int
```

### データベースモデル（SQLAlchemy）

```python
# database.py
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Enum
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
import enum

SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"

engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

class ItemStatusEnum(enum.Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"

class ItemDB(Base):
    __tablename__ = "items"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    description = Column(String(500))
    price = Column(Float, nullable=False)
    status = Column(Enum(ItemStatusEnum), default=ItemStatusEnum.ACTIVE)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

Base.metadata.create_all(bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### CRUD操作の実装

```python
# crud.py
from sqlalchemy.orm import Session
from models import ItemCreate, ItemUpdate
from database import ItemDB
from typing import List, Optional

def create_item(db: Session, item: ItemCreate) -> ItemDB:
    db_item = ItemDB(**item.dict())
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item

def get_item(db: Session, item_id: int) -> Optional[ItemDB]:
    return db.query(ItemDB).filter(ItemDB.id == item_id).first()

def get_items(db: Session, skip: int = 0, limit: int = 100) -> List[ItemDB]:
    return db.query(ItemDB).offset(skip).limit(limit).all()

def update_item(db: Session, item_id: int, item: ItemUpdate) -> Optional[ItemDB]:
    db_item = db.query(ItemDB).filter(ItemDB.id == item_id).first()
    if db_item:
        update_data = item.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(db_item, field, value)
        db.commit()
        db.refresh(db_item)
    return db_item

def delete_item(db: Session, item_id: int) -> bool:
    db_item = db.query(ItemDB).filter(ItemDB.id == item_id).first()
    if db_item:
        db.delete(db_item)
        db.commit()
        return True
    return False
```

## 完全なAPI実装

```python
# main.py
from fastapi import FastAPI, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional
from models import Item, ItemCreate, ItemUpdate, ItemList
from database import get_db
import crud

# FastAPIアプリケーションの作成
app = FastAPI(
    title="アイテム管理API",
    description="アイテムのCRUD操作を行うAPI",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# ルートエンドポイント
@app.get("/", tags=["Root"])
def read_root():
    """
    ルートエンドポイント
    
    アプリケーションの基本情報を返します。
    """
    return {
        "message": "アイテム管理APIへようこそ",
        "version": "1.0.0",
        "docs": "/docs",
        "redoc": "/redoc"
    }

# アイテム作成
@app.post("/items/", response_model=Item, status_code=status.HTTP_201_CREATED, tags=["Items"])
def create_item(
    item: ItemCreate,
    db: Session = Depends(get_db)
):
    """
    新しいアイテムを作成します。
    
    - **name**: アイテム名（必須、1-100文字）
    - **description**: アイテムの説明（任意、最大500文字）
    - **price**: 価格（必須、0より大きい値）
    - **status**: アイテムのステータス（デフォルト: active）
    """
    return crud.create_item(db=db, item=item)

# アイテム一覧取得
@app.get("/items/", response_model=ItemList, tags=["Items"])
def read_items(
    skip: int = Query(0, ge=0, description="スキップするアイテム数"),
    limit: int = Query(100, ge=1, le=1000, description="取得するアイテム数"),
    db: Session = Depends(get_db)
):
    """
    アイテムの一覧を取得します。
    
    - **skip**: スキップするアイテム数（デフォルト: 0）
    - **limit**: 取得するアイテム数（デフォルト: 100、最大: 1000）
    """
    items = crud.get_items(db=db, skip=skip, limit=limit)
    total = len(items)
    
    return ItemList(
        items=items,
        total=total,
        page=skip // limit + 1,
        per_page=limit
    )

# アイテム詳細取得
@app.get("/items/{item_id}", response_model=Item, tags=["Items"])
def read_item(
    item_id: int = Query(..., description="アイテムID"),
    db: Session = Depends(get_db)
):
    """
    指定されたIDのアイテムを取得します。
    
    - **item_id**: 取得するアイテムのID
    """
    item = crud.get_item(db=db, item_id=item_id)
    if item is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="アイテムが見つかりません"
        )
    return item

# アイテム更新
@app.put("/items/{item_id}", response_model=Item, tags=["Items"])
def update_item(
    item_id: int = Query(..., description="更新するアイテムのID"),
    item: ItemUpdate = None,
    db: Session = Depends(get_db)
):
    """
    指定されたIDのアイテムを更新します。
    
    - **item_id**: 更新するアイテムのID
    - **item**: 更新するアイテムの情報
    """
    db_item = crud.update_item(db=db, item_id=item_id, item=item)
    if db_item is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="アイテムが見つかりません"
        )
    return db_item

# アイテム削除
@app.delete("/items/{item_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Items"])
def delete_item(
    item_id: int = Query(..., description="削除するアイテムのID"),
    db: Session = Depends(get_db)
):
    """
    指定されたIDのアイテムを削除します。
    
    - **item_id**: 削除するアイテムのID
    """
    if not crud.delete_item(db=db, item_id=item_id):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="アイテムが見つかりません"
        )
    return None

# ヘルスチェック
@app.get("/health", tags=["Health"])
def health_check():
    """
    アプリケーションのヘルスチェック
    
    アプリケーションが正常に動作しているかを確認します。
    """
    return {"status": "healthy", "message": "アプリケーションは正常に動作しています"}
```

## 認証とセキュリティ

### JWT認証の実装

```python
# auth.py
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel

SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
security = HTTPBearer()

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

class User(BaseModel):
    username: str
    email: Optional[str] = None
    full_name: Optional[str] = None
    disabled: Optional[bool] = None

class UserInDB(User):
    hashed_password: str

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def authenticate_user(username: str, password: str):
    # 実際の実装では、データベースからユーザー情報を取得
    user = get_user(username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user

def get_user(username: str):
    # 実際の実装では、データベースからユーザー情報を取得
    # ここでは簡単な例を示す
    fake_users_db = {
        "admin": {
            "username": "admin",
            "email": "admin@example.com",
            "full_name": "Administrator",
            "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
            "disabled": False,
        }
    }
    
    if username in fake_users_db:
        user_dict = fake_users_db[username]
        return UserInDB(**user_dict)
    return None

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="認証情報を確認できませんでした",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception
    user = get_user(username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(current_user: User = Depends(get_current_user)):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="無効なユーザーです")
    return current_user
```

### 認証付きエンドポイント

```python
# main.py（認証部分の追加）
from fastapi import FastAPI, Depends, HTTPException, status
from auth import Token, authenticate_user, create_access_token, get_current_active_user, User
from datetime import timedelta

# 認証エンドポイント
@app.post("/token", response_model=Token, tags=["Authentication"])
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
    """
    ユーザー認証を行い、アクセストークンを取得します。
    
    - **username**: ユーザー名
    - **password**: パスワード
    """
    user = authenticate_user(form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ユーザー名またはパスワードが正しくありません",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

# 認証が必要なエンドポイント
@app.get("/users/me/", response_model=User, tags=["Users"])
async def read_users_me(current_user: User = Depends(get_current_active_user)):
    """
    現在のユーザー情報を取得します。
    
    認証が必要なエンドポイントです。
    """
    return current_user

# 認証が必要なアイテム操作
@app.post("/items/", response_model=Item, status_code=status.HTTP_201_CREATED, tags=["Items"])
def create_item(
    item: ItemCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """
    新しいアイテムを作成します（認証が必要）。
    """
    return crud.create_item(db=db, item=item)
```

## カスタムレスポンスとエラーハンドリング

```python
# responses.py
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
import logging

# カスタムエラーハンドラー
@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(request: Request, exc: StarletteHTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": True,
            "message": exc.detail,
            "status_code": exc.status_code,
            "path": str(request.url)
        }
    )

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    return JSONResponse(
        status_code=422,
        content={
            "error": True,
            "message": "バリデーションエラー",
            "details": exc.errors(),
            "status_code": 422,
            "path": str(request.url)
        }
    )

# カスタムレスポンス
class CustomResponse(BaseModel):
    success: bool
    message: str
    data: Optional[dict] = None
    timestamp: datetime

@app.get("/custom-response", response_model=CustomResponse, tags=["Custom"])
def get_custom_response():
    """
    カスタムレスポンスの例
    """
    return CustomResponse(
        success=True,
        message="カスタムレスポンスが正常に返されました",
        data={"example": "data"},
        timestamp=datetime.utcnow()
    )
```

## テストの実装

```python
# test_main.py
from fastapi.testclient import TestClient
from main import app
import json

client = TestClient(app)

def test_read_root():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {
        "message": "アイテム管理APIへようこそ",
        "version": "1.0.0",
        "docs": "/docs",
        "redoc": "/redoc"
    }

def test_create_item():
    item_data = {
        "name": "テストアイテム",
        "description": "テスト用のアイテムです",
        "price": 100.0,
        "status": "active"
    }
    response = client.post("/items/", json=item_data)
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == item_data["name"]
    assert data["price"] == item_data["price"]
    assert "id" in data

def test_get_items():
    response = client.get("/items/")
    assert response.status_code == 200
    data = response.json()
    assert "items" in data
    assert "total" in data
    assert "page" in data
    assert "per_page" in data

def test_get_item_not_found():
    response = client.get("/items/999")
    assert response.status_code == 404
    assert response.json()["detail"] == "アイテムが見つかりません"

def test_validation_error():
    invalid_item = {
        "name": "",  # 空文字は無効
        "price": -10  # 負の値は無効
    }
    response = client.post("/items/", json=invalid_item)
    assert response.status_code == 422
```

## デプロイメント設定

```python
# config.py
from pydantic import BaseSettings

class Settings(BaseSettings):
    app_name: str = "アイテム管理API"
    debug: bool = False
    database_url: str = "sqlite:///./test.db"
    secret_key: str = "your-secret-key-here"
    access_token_expire_minutes: int = 30
    
    class Config:
        env_file = ".env"

settings = Settings()
```

```bash
# requirements.txt
fastapi==0.104.1
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
pydantic==2.5.0
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6
pytest==7.4.3
httpx==0.25.2
```

## まとめ

FastAPIとOpenAPIを組み合わせることで、以下のような強力なAPIを構築できます：

### FastAPIの主な利点

- **自動ドキュメント生成**: [FastAPI公式サイト](https://fastapi.tiangolo.com/ja/)で提供されるように、型ヒントから自動的にOpenAPIスキーマを生成
- **型安全性**: Pythonの型ヒントを活用した自動バリデーション
- **高性能**: Node.jsやGoと同等の高いパフォーマンス
- **標準準拠**: OpenAPI 3.0とJSON Schemaに完全準拠

### 実装のポイント

- **Pydanticモデル**: データの検証とシリアライゼーション
- **依存性注入**: データベース接続や認証の管理
- **自動ドキュメント**: Swagger UIとReDocによる対話的なAPIドキュメント
- **エラーハンドリング**: 適切なHTTPステータスコードとエラーメッセージ
- **テスト**: 包括的なテストの実装

### 学習のポイント

- **基本的なAPI設計**から始める
- **Pydanticモデル**の活用方法を学ぶ
- **認証とセキュリティ**の実装を理解する
- **テストの書き方**を習得する
- **実際のプロジェクト**で使用して経験を積む

FastAPIとOpenAPIを組み合わせることで、型安全で高性能、かつドキュメントが充実したAPIを効率的に開発できます。まずは基本的な使い方から始めて、徐々に高度な機能を学習していきましょう。
