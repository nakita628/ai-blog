---
date: 2025-10-29
title: Effect + Prisma完全入門：型安全なデータベース操作で堅牢なアプリケーションを構築する
description: EffectとPrismaを組み合わせた実践的なアプリケーション開発について、初心者向けに詳しく解説。Effectの型安全なエラーハンドリング、リトライ機能、並行処理とPrismaのORM機能を活用し、堅牢で保守性の高いデータベースアプリケーションを学ぶ実践的なガイド。
tags:
  - effect
  - prisma
  - typescript
  - database
  - orm
  - error-handling
  - functional-programming
  - type-safety
  - retry
  - concurrency
prev:
  text: 'Pinia完全入門：Vue.jsの直感的な状態管理ライブラリでアプリケーションを構築する'
  link: '/posts/2025/10/28'
next: false
---

# Effect + Prisma完全入門：型安全なデータベース操作で堅牢なアプリケーションを構築する

[Effect](https://effect.website/)とPrismaを組み合わせることで、型安全で堅牢なデータベースアプリケーションを構築できます。Effectの強力なエラーハンドリング、リトライ機能、並行処理とPrismaのORM機能を活用し、保守性の高いアプリケーションを実現します。この記事では、実践的なコード例を通じて、EffectとPrismaの組み合わせを詳しく解説します。

## EffectとPrismaの組み合わせの利点

EffectとPrismaを組み合わせることで、以下の利点が得られます：

- **型安全性**: データベース操作からエラーハンドリングまで完全な型安全性
- **エラーハンドリング**: データベースエラーを値として扱い、適切に処理
- **リトライ機能**: データベース接続エラーの自動リトライ
- **並行処理**: 安全な並行データベース操作
- **トレーシング**: データベース操作の可視化と監視
- **テスト容易性**: モック化しやすい設計

## プロジェクトのセットアップ

### 必要なパッケージのインストール

```bash
# EffectとPrismaのインストール
npm install effect @effect/platform @effect/platform-node
npm install prisma @prisma/client
npm install -D prisma

# 型定義
npm install -D @types/node
```

### Prismaスキーマの設定

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  posts     Post[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String
  published Boolean  @default(false)
  authorId  String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("posts")
}
```

### 基本的な設定

```typescript
// src/database.ts
import { PrismaClient } from '@prisma/client'
import { Effect, Layer, Context } from 'effect'

// データベースサービスのインターフェース
export interface DatabaseService {
  readonly user: {
    create: (data: CreateUserData) => Effect.Effect<User, DatabaseError>
    findById: (id: string) => Effect.Effect<User | null, DatabaseError>
    findByEmail: (email: string) => Effect.Effect<User | null, DatabaseError>
    update: (id: string, data: UpdateUserData) => Effect.Effect<User, DatabaseError>
    delete: (id: string) => Effect.Effect<void, DatabaseError>
  }
  readonly post: {
    create: (data: CreatePostData) => Effect.Effect<Post, DatabaseError>
    findById: (id: string) => Effect.Effect<Post | null, DatabaseError>
    findByAuthor: (authorId: string) => Effect.Effect<Post[], DatabaseError>
    update: (id: string, data: UpdatePostData) => Effect.Effect<Post, DatabaseError>
    delete: (id: string) => Effect.Effect<void, DatabaseError>
  }
}

// データベースエラーの定義
export class DatabaseError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly originalError?: unknown,
  ) {
    super(message)
    this.name = 'DatabaseError'
  }
}

// 型定義
export interface User {
  id: string
  email: string
  name: string
  createdAt: Date
  updatedAt: Date
}

export interface Post {
  id: string
  title: string
  content: string
  published: boolean
  authorId: string
  createdAt: Date
  updatedAt: Date
}

export interface CreateUserData {
  email: string
  name: string
}

export interface UpdateUserData {
  email?: string
  name?: string
}

export interface CreatePostData {
  title: string
  content: string
  authorId: string
  published?: boolean
}

export interface UpdatePostData {
  title?: string
  content?: string
  published?: boolean
}

// データベースサービスのタグ
export const DatabaseService = Context.GenericTag<DatabaseService>('DatabaseService')
```

## データベースサービスの実装

### 基本的なデータベースサービス

```typescript
// src/database-service.ts
import { PrismaClient } from '@prisma/client'
import { Effect, Layer, Context } from 'effect'
import {
  DatabaseService,
  DatabaseError,
  User,
  Post,
  CreateUserData,
  UpdateUserData,
  CreatePostData,
  UpdatePostData,
} from './database'

// Prismaクライアントのラッパー
class PrismaDatabaseService implements DatabaseService {
  constructor(private readonly prisma: PrismaClient) {}

  readonly user = {
    create: (data: CreateUserData) =>
      Effect.tryPromise({
        try: () => this.prisma.user.create({ data }),
        catch: (error) => new DatabaseError('Failed to create user', 'USER_CREATE_ERROR', error),
      }),

    findById: (id: string) =>
      Effect.tryPromise({
        try: () => this.prisma.user.findUnique({ where: { id } }),
        catch: (error) => new DatabaseError('Failed to find user by ID', 'USER_FIND_ERROR', error),
      }),

    findByEmail: (email: string) =>
      Effect.tryPromise({
        try: () => this.prisma.user.findUnique({ where: { email } }),
        catch: (error) =>
          new DatabaseError('Failed to find user by email', 'USER_FIND_ERROR', error),
      }),

    update: (id: string, data: UpdateUserData) =>
      Effect.tryPromise({
        try: () => this.prisma.user.update({ where: { id }, data }),
        catch: (error) => new DatabaseError('Failed to update user', 'USER_UPDATE_ERROR', error),
      }),

    delete: (id: string) =>
      Effect.tryPromise({
        try: () => this.prisma.user.delete({ where: { id } }).then(() => undefined),
        catch: (error) => new DatabaseError('Failed to delete user', 'USER_DELETE_ERROR', error),
      }),
  }

  readonly post = {
    create: (data: CreatePostData) =>
      Effect.tryPromise({
        try: () => this.prisma.post.create({ data }),
        catch: (error) => new DatabaseError('Failed to create post', 'POST_CREATE_ERROR', error),
      }),

    findById: (id: string) =>
      Effect.tryPromise({
        try: () => this.prisma.post.findUnique({ where: { id } }),
        catch: (error) => new DatabaseError('Failed to find post by ID', 'POST_FIND_ERROR', error),
      }),

    findByAuthor: (authorId: string) =>
      Effect.tryPromise({
        try: () => this.prisma.post.findMany({ where: { authorId } }),
        catch: (error) =>
          new DatabaseError('Failed to find posts by author', 'POST_FIND_ERROR', error),
      }),

    update: (id: string, data: UpdatePostData) =>
      Effect.tryPromise({
        try: () => this.prisma.post.update({ where: { id }, data }),
        catch: (error) => new DatabaseError('Failed to update post', 'POST_UPDATE_ERROR', error),
      }),

    delete: (id: string) =>
      Effect.tryPromise({
        try: () => this.prisma.post.delete({ where: { id } }).then(() => undefined),
        catch: (error) => new DatabaseError('Failed to delete post', 'POST_DELETE_ERROR', error),
      }),
  }
}

// データベースサービスのレイヤー
export const DatabaseServiceLive = Layer.succeed(
  DatabaseService,
  new PrismaDatabaseService(new PrismaClient()),
)
```

## 高度なデータベース操作

### リトライ機能付きデータベース操作

```typescript
// src/database-with-retry.ts
import { Effect, Schedule, RetryPolicy } from 'effect'
import { DatabaseService, DatabaseError } from './database'

// リトライポリシーの定義
const databaseRetryPolicy = Schedule.exponential('100 millis').pipe(
  Schedule.andThen(Schedule.recurs(3)),
)

// リトライ機能付きデータベース操作
export const withRetry = <A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>
  Effect.retry(effect, databaseRetryPolicy)

// 使用例
export const createUserWithRetry = (data: CreateUserData) =>
  Effect.gen(function* () {
    const db = yield* DatabaseService
    return yield* withRetry(db.user.create(data))
  })

export const findUserByIdWithRetry = (id: string) =>
  Effect.gen(function* () {
    const db = yield* DatabaseService
    return yield* withRetry(db.user.findById(id))
  })
```

### トランザクション処理

```typescript
// src/transaction.ts
import { Effect, Layer } from 'effect'
import { PrismaClient } from '@prisma/client'
import { DatabaseService, DatabaseError, User, Post } from './database'

// トランザクション用のデータベースサービス
export interface TransactionService {
  readonly execute: <A>(
    effect: Effect.Effect<A, DatabaseError, DatabaseService>,
  ) => Effect.Effect<A, DatabaseError>
}

export const TransactionService = Context.GenericTag<TransactionService>('TransactionService')

// トランザクションサービスの実装
class PrismaTransactionService implements TransactionService {
  constructor(private readonly prisma: PrismaClient) {}

  readonly execute = <A>(effect: Effect.Effect<A, DatabaseError, DatabaseService>) =>
    Effect.tryPromise({
      try: () =>
        this.prisma.$transaction(async (tx) => {
          // トランザクション内でのデータベースサービスを作成
          const dbService = new PrismaDatabaseService(tx as any)
          const layer = Layer.succeed(DatabaseService, dbService)

          // Effectを実行
          return Effect.runPromise(Effect.provide(effect, layer))
        }),
      catch: (error) => new DatabaseError('Transaction failed', 'TRANSACTION_ERROR', error),
    })
}

export const TransactionServiceLive = Layer.succeed(
  TransactionService,
  new PrismaTransactionService(new PrismaClient()),
)

// トランザクション使用例
export const createUserWithPost = (
  userData: CreateUserData,
  postData: Omit<CreatePostData, 'authorId'>,
) =>
  Effect.gen(function* () {
    const transaction = yield* TransactionService

    return yield* transaction.execute(
      Effect.gen(function* () {
        const db = yield* DatabaseService

        // ユーザー作成
        const user = yield* db.user.create(userData)

        // 投稿作成
        const post = yield* db.post.create({
          ...postData,
          authorId: user.id,
        })

        return { user, post }
      }),
    )
  })
```

## ビジネスロジックの実装

### ユーザー管理サービス

```typescript
// src/user-service.ts
import { Effect, Console } from 'effect'
import { DatabaseService, DatabaseError, User, CreateUserData } from './database'

// ビジネスエラーの定義
export class UserNotFoundError extends Error {
  constructor(public readonly userId: string) {
    super(`User with ID ${userId} not found`)
    this.name = 'UserNotFoundError'
  }
}

export class UserAlreadyExistsError extends Error {
  constructor(public readonly email: string) {
    super(`User with email ${email} already exists`)
    this.name = 'UserAlreadyExistsError'
  }
}

// ユーザーサービスの実装
export class UserService {
  // ユーザー作成（重複チェック付き）
  static createUser = (data: CreateUserData) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService

      // 既存ユーザーのチェック
      const existingUser = yield* db.user.findByEmail(data.email)
      if (existingUser) {
        yield* Effect.fail(new UserAlreadyExistsError(data.email))
      }

      // ユーザー作成
      const user = yield* db.user.create(data)

      yield* Console.log(`User created: ${user.email}`)
      return user
    })

  // ユーザー取得（存在チェック付き）
  static getUserById = (id: string) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService

      const user = yield* db.user.findById(id)
      if (!user) {
        yield* Effect.fail(new UserNotFoundError(id))
      }

      return user
    })

  // ユーザー更新
  static updateUser = (id: string, data: UpdateUserData) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService

      // ユーザーの存在確認
      yield* UserService.getUserById(id)

      // メールアドレスが変更される場合の重複チェック
      if (data.email) {
        const existingUser = yield* db.user.findByEmail(data.email)
        if (existingUser && existingUser.id !== id) {
          yield* Effect.fail(new UserAlreadyExistsError(data.email))
        }
      }

      // ユーザー更新
      const updatedUser = yield* db.user.update(id, data)

      yield* Console.log(`User updated: ${updatedUser.email}`)
      return updatedUser
    })

  // ユーザー削除
  static deleteUser = (id: string) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService

      // ユーザーの存在確認
      yield* UserService.getUserById(id)

      // ユーザー削除
      yield* db.user.delete(id)

      yield* Console.log(`User deleted: ${id}`)
    })
}
```

### 投稿管理サービス

```typescript
// src/post-service.ts
import { Effect, Console } from 'effect'
import { DatabaseService, DatabaseError, Post, CreatePostData } from './database'
import { UserService, UserNotFoundError } from './user-service'

export class PostNotFoundError extends Error {
  constructor(public readonly postId: string) {
    super(`Post with ID ${postId} not found`)
    this.name = 'PostNotFoundError'
  }
}

export class PostService {
  // 投稿作成
  static createPost = (data: CreatePostData) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService

      // 著者の存在確認
      yield* UserService.getUserById(data.authorId)

      // 投稿作成
      const post = yield* db.post.create(data)

      yield* Console.log(`Post created: ${post.title}`)
      return post
    })

  // 投稿取得
  static getPostById = (id: string) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService

      const post = yield* db.post.findById(id)
      if (!post) {
        yield* Effect.fail(new PostNotFoundError(id))
      }

      return post
    })

  // 著者の投稿一覧取得
  static getPostsByAuthor = (authorId: string) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService

      // 著者の存在確認
      yield* UserService.getUserById(authorId)

      // 投稿一覧取得
      const posts = yield* db.post.findByAuthor(authorId)

      yield* Console.log(`Found ${posts.length} posts for author ${authorId}`)
      return posts
    })

  // 投稿更新
  static updatePost = (id: string, data: UpdatePostData) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService

      // 投稿の存在確認
      yield* PostService.getPostById(id)

      // 投稿更新
      const updatedPost = yield* db.post.update(id, data)

      yield* Console.log(`Post updated: ${updatedPost.title}`)
      return updatedPost
    })

  // 投稿削除
  static deletePost = (id: string) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService

      // 投稿の存在確認
      yield* PostService.getPostById(id)

      // 投稿削除
      yield* db.post.delete(id)

      yield* Console.log(`Post deleted: ${id}`)
    })
}
```

## アプリケーションの実装

### メインアプリケーション

```typescript
// src/app.ts
import { Effect, Console, Exit } from 'effect'
import { DatabaseServiceLive } from './database-service'
import { TransactionServiceLive } from './transaction'
import { UserService } from './user-service'
import { PostService } from './post-service'

// アプリケーションの実行
const main = Effect.gen(function* () {
  yield* Console.log('Starting application...')

  try {
    // ユーザー作成
    const user = yield* UserService.createUser({
      email: 'john@example.com',
      name: 'John Doe',
    })

    yield* Console.log('User created:', user)

    // 投稿作成
    const post = yield* PostService.createPost({
      title: 'My First Post',
      content: 'This is my first post using Effect and Prisma!',
      authorId: user.id,
      published: true,
    })

    yield* Console.log('Post created:', post)

    // 投稿一覧取得
    const posts = yield* PostService.getPostsByAuthor(user.id)
    yield* Console.log('User posts:', posts)

    // 投稿更新
    const updatedPost = yield* PostService.updatePost(post.id, {
      title: 'Updated Post Title',
      content: 'This post has been updated!',
    })

    yield* Console.log('Post updated:', updatedPost)

    yield* Console.log('Application completed successfully!')
  } catch (error) {
    yield* Console.error('Application error:', error)
    throw error
  }
})

// アプリケーションの実行
const runApp = Effect.provide(main, Layer.mergeAll(DatabaseServiceLive, TransactionServiceLive))

// 実行
Effect.runPromise(runApp).then(
  (result) => {
    console.log('Application finished:', result)
    process.exit(0)
  },
  (error) => {
    console.error('Application failed:', error)
    process.exit(1)
  },
)
```

### エラーハンドリングの実装

```typescript
// src/error-handling.ts
import { Effect, Console } from 'effect'
import { DatabaseError } from './database'
import { UserNotFoundError, UserAlreadyExistsError } from './user-service'
import { PostNotFoundError } from './post-service'

// エラーハンドリングの実装
export const handleError = (error: unknown) =>
  Effect.gen(function* () {
    if (error instanceof UserNotFoundError) {
      yield* Console.error(`User not found: ${error.userId}`)
      return { type: 'user_not_found', message: error.message }
    }

    if (error instanceof UserAlreadyExistsError) {
      yield* Console.error(`User already exists: ${error.email}`)
      return { type: 'user_already_exists', message: error.message }
    }

    if (error instanceof PostNotFoundError) {
      yield* Console.error(`Post not found: ${error.postId}`)
      return { type: 'post_not_found', message: error.message }
    }

    if (error instanceof DatabaseError) {
      yield* Console.error(`Database error: ${error.message}`, error.originalError)
      return { type: 'database_error', message: error.message }
    }

    yield* Console.error('Unknown error:', error)
    return { type: 'unknown_error', message: 'An unknown error occurred' }
  })

// エラーハンドリング付きのアプリケーション実行
export const runAppWithErrorHandling = (app: Effect.Effect<any, any, any>) =>
  Effect.gen(function* () {
    const result = yield* Effect.either(app)

    if (result._tag === 'Left') {
      const errorInfo = yield* handleError(result.left)
      yield* Console.error('Application failed:', errorInfo)
      return errorInfo
    }

    return result.right
  })
```

## テストの実装

### モックデータベースサービス

```typescript
// src/test/mock-database.ts
import { Effect, Layer } from 'effect'
import { DatabaseService, User, Post } from '../database'

// モックデータ
const mockUsers: User[] = [
  {
    id: '1',
    email: 'test@example.com',
    name: 'Test User',
    createdAt: new Date(),
    updatedAt: new Date(),
  },
]

const mockPosts: Post[] = [
  {
    id: '1',
    title: 'Test Post',
    content: 'Test content',
    published: true,
    authorId: '1',
    createdAt: new Date(),
    updatedAt: new Date(),
  },
]

// モックデータベースサービス
class MockDatabaseService implements DatabaseService {
  readonly user = {
    create: (data: CreateUserData) =>
      Effect.succeed({
        id: '2',
        email: data.email,
        name: data.name,
        createdAt: new Date(),
        updatedAt: new Date(),
      }),

    findById: (id: string) => Effect.succeed(mockUsers.find((user) => user.id === id) || null),

    findByEmail: (email: string) =>
      Effect.succeed(mockUsers.find((user) => user.email === email) || null),

    update: (id: string, data: UpdateUserData) =>
      Effect.succeed({
        id,
        email: data.email || 'test@example.com',
        name: data.name || 'Test User',
        createdAt: new Date(),
        updatedAt: new Date(),
      }),

    delete: (id: string) => Effect.succeed(undefined),
  }

  readonly post = {
    create: (data: CreatePostData) =>
      Effect.succeed({
        id: '2',
        title: data.title,
        content: data.content,
        published: data.published || false,
        authorId: data.authorId,
        createdAt: new Date(),
        updatedAt: new Date(),
      }),

    findById: (id: string) => Effect.succeed(mockPosts.find((post) => post.id === id) || null),

    findByAuthor: (authorId: string) =>
      Effect.succeed(mockPosts.filter((post) => post.authorId === authorId)),

    update: (id: string, data: UpdatePostData) =>
      Effect.succeed({
        id,
        title: data.title || 'Test Post',
        content: data.content || 'Test content',
        published: data.published || false,
        authorId: '1',
        createdAt: new Date(),
        updatedAt: new Date(),
      }),

    delete: (id: string) => Effect.succeed(undefined),
  }
}

export const MockDatabaseServiceLive = Layer.succeed(DatabaseService, new MockDatabaseService())
```

### テストの実行

```typescript
// src/test/user-service.test.ts
import { Effect } from 'effect'
import { UserService } from '../user-service'
import { MockDatabaseServiceLive } from './mock-database'

// テストの実行
const testUserService = Effect.gen(function* () {
  // ユーザー作成のテスト
  const user = yield* UserService.createUser({
    email: 'test@example.com',
    name: 'Test User',
  })

  console.log('User created:', user)

  // ユーザー取得のテスト
  const foundUser = yield* UserService.getUserById(user.id)
  console.log('User found:', foundUser)

  // ユーザー更新のテスト
  const updatedUser = yield* UserService.updateUser(user.id, {
    name: 'Updated User',
  })
  console.log('User updated:', updatedUser)

  return { user, foundUser, updatedUser }
})

// テスト実行
Effect.runPromise(Effect.provide(testUserService, MockDatabaseServiceLive)).then(
  (result) => console.log('Test completed:', result),
  (error) => console.error('Test failed:', error),
)
```

## まとめ

EffectとPrismaを組み合わせることで、以下の利点が得られます：

### 主要な特徴

- **型安全性**: データベース操作からエラーハンドリングまで完全な型安全性
- **エラーハンドリング**: データベースエラーを値として扱い、適切に処理
- **リトライ機能**: データベース接続エラーの自動リトライ
- **並行処理**: 安全な並行データベース操作
- **テスト容易性**: モック化しやすい設計

### 実装のポイント

- **適切なエラー設計**: ビジネスロジックに応じたエラーの定義
- **リトライポリシー**: データベース操作の適切なリトライ設定
- **トランザクション処理**: 複数の操作を安全に実行
- **テスト設計**: モックを使った効果的なテスト

### 実践的な用途

- **大規模アプリケーション**: 複雑なデータベース操作の管理
- **マイクロサービス**: 堅牢なデータベースサービス
- **リアルタイムアプリケーション**: 並行処理を活用したアプリケーション
- **エンタープライズアプリケーション**: 高い信頼性が求められるシステム

[Effect公式サイト](https://effect.website/)を参考に、型安全で堅牢なデータベースアプリケーションを構築しましょう。Effectの強力な機能とPrismaのORM機能を組み合わせることで、保守性の高いアプリケーションを実現できます。
