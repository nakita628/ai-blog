---
date: 2025-10-29
title: Effect + Prisma完全入門：型安全なデータベース操作で堅牢なアプリケーションを構築する
description: EffectとPrismaを組み合わせた実践的なアプリケーション開発について、初心者向けに詳しく解説。Effectの型安全なエラーハンドリング、リトライ機能、並行処理とPrismaのORM機能を活用し、堅牢で保守性の高いデータベースアプリケーションを学ぶ実践的なガイド。
tags:
    - effect
    - prisma
    - typescript
    - database
    - orm
    - error-handling
    - functional-programming
    - type-safety
    - retry
    - concurrency
prev:
    text: "Pinia完全入門：Vue.jsの直感的な状態管理ライブラリでアプリケーションを構築する"
    link: "/posts/2025/10/28"
next: false
---

# Effect + Prisma完全入門：型安全なデータベース操作で堅牢なアプリケーションを構築する

[Effect](https://effect.website/)とPrismaを組み合わせることで、型安全で堅牢なデータベースアプリケーションを構築できます。Effectの強力なエラーハンドリング、リトライ機能、並行処理とPrismaのORM機能を活用し、保守性の高いアプリケーションを実現します。この記事では、実践的なコード例を通じて、EffectとPrismaの組み合わせを詳しく解説します。

## EffectとPrismaの組み合わせの利点

EffectとPrismaを組み合わせることで、以下の利点が得られます：

- **型安全性**: データベース操作からエラーハンドリングまで完全な型安全性
- **エラーハンドリング**: データベースエラーを値として扱い、適切に処理
- **リトライ機能**: データベース接続エラーの自動リトライ
- **並行処理**: 安全な並行データベース操作
- **トレーシング**: データベース操作の可視化と監視
- **テスト容易性**: モック化しやすい設計

## プロジェクトのセットアップ

### 必要なパッケージのインストール

```bash
# EffectとPrismaのインストール
npm install effect @effect/platform @effect/platform-node
npm install prisma @prisma/client
npm install -D prisma

# 型定義
npm install -D @types/node
```

### Prismaスキーマの設定

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  posts     Post[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String
  published Boolean  @default(false)
  authorId  String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("posts")
}
```

### 基本的な設定

```typescript
// src/database.ts
import { PrismaClient } from '@prisma/client';
import { Effect, Layer, Context } from 'effect';

// データベースサービスのインターフェース
export interface DatabaseService {
  readonly user: {
    create: (data: CreateUserData) => Effect.Effect<User, DatabaseError>;
    findById: (id: string) => Effect.Effect<User | null, DatabaseError>;
    findByEmail: (email: string) => Effect.Effect<User | null, DatabaseError>;
    update: (id: string, data: UpdateUserData) => Effect.Effect<User, DatabaseError>;
    delete: (id: string) => Effect.Effect<void, DatabaseError>;
  };
  readonly post: {
    create: (data: CreatePostData) => Effect.Effect<Post, DatabaseError>;
    findById: (id: string) => Effect.Effect<Post | null, DatabaseError>;
    findByAuthor: (authorId: string) => Effect.Effect<Post[], DatabaseError>;
    update: (id: string, data: UpdatePostData) => Effect.Effect<Post, DatabaseError>;
    delete: (id: string) => Effect.Effect<void, DatabaseError>;
  };
}

// データベースエラーの定義
export class DatabaseError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly originalError?: unknown
  ) {
    super(message);
    this.name = 'DatabaseError';
  }
}

// 型定義
export interface User {
  id: string;
  email: string;
  name: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface Post {
  id: string;
  title: string;
  content: string;
  published: boolean;
  authorId: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateUserData {
  email: string;
  name: string;
}

export interface UpdateUserData {
  email?: string;
  name?: string;
}

export interface CreatePostData {
  title: string;
  content: string;
  authorId: string;
  published?: boolean;
}

export interface UpdatePostData {
  title?: string;
  content?: string;
  published?: boolean;
}

// データベースサービスのタグ
export const DatabaseService = Context.GenericTag<DatabaseService>('DatabaseService');
```

## データベースサービスの実装

### 基本的なデータベースサービス

```typescript
// src/database-service.ts
import { PrismaClient } from '@prisma/client';
import { Effect, Layer, Context } from 'effect';
import { 
  DatabaseService, 
  DatabaseError, 
  User, 
  Post, 
  CreateUserData, 
  UpdateUserData, 
  CreatePostData, 
  UpdatePostData 
} from './database';

// Prismaクライアントのラッパー
class PrismaDatabaseService implements DatabaseService {
  constructor(private readonly prisma: PrismaClient) {}

  readonly user = {
    create: (data: CreateUserData) =>
      Effect.tryPromise({
        try: () => this.prisma.user.create({ data }),
        catch: (error) => new DatabaseError(
          'Failed to create user',
          'USER_CREATE_ERROR',
          error
        )
      }),

    findById: (id: string) =>
      Effect.tryPromise({
        try: () => this.prisma.user.findUnique({ where: { id } }),
        catch: (error) => new DatabaseError(
          'Failed to find user by ID',
          'USER_FIND_ERROR',
          error
        )
      }),

    findByEmail: (email: string) =>
      Effect.tryPromise({
        try: () => this.prisma.user.findUnique({ where: { email } }),
        catch: (error) => new DatabaseError(
          'Failed to find user by email',
          'USER_FIND_ERROR',
          error
        )
      }),

    update: (id: string, data: UpdateUserData) =>
      Effect.tryPromise({
        try: () => this.prisma.user.update({ where: { id }, data }),
        catch: (error) => new DatabaseError(
          'Failed to update user',
          'USER_UPDATE_ERROR',
          error
        )
      }),

    delete: (id: string) =>
      Effect.tryPromise({
        try: () => this.prisma.user.delete({ where: { id } }).then(() => undefined),
        catch: (error) => new DatabaseError(
          'Failed to delete user',
          'USER_DELETE_ERROR',
          error
        )
      })
  };

  readonly post = {
    create: (data: CreatePostData) =>
      Effect.tryPromise({
        try: () => this.prisma.post.create({ data }),
        catch: (error) => new DatabaseError(
          'Failed to create post',
          'POST_CREATE_ERROR',
          error
        )
      }),

    findById: (id: string) =>
      Effect.tryPromise({
        try: () => this.prisma.post.findUnique({ where: { id } }),
        catch: (error) => new DatabaseError(
          'Failed to find post by ID',
          'POST_FIND_ERROR',
          error
        )
      }),

    findByAuthor: (authorId: string) =>
      Effect.tryPromise({
        try: () => this.prisma.post.findMany({ where: { authorId } }),
        catch: (error) => new DatabaseError(
          'Failed to find posts by author',
          'POST_FIND_ERROR',
          error
        )
      }),

    update: (id: string, data: UpdatePostData) =>
      Effect.tryPromise({
        try: () => this.prisma.post.update({ where: { id }, data }),
        catch: (error) => new DatabaseError(
          'Failed to update post',
          'POST_UPDATE_ERROR',
          error
        )
      }),

    delete: (id: string) =>
      Effect.tryPromise({
        try: () => this.prisma.post.delete({ where: { id } }).then(() => undefined),
        catch: (error) => new DatabaseError(
          'Failed to delete post',
          'POST_DELETE_ERROR',
          error
        )
      })
  };
}

// データベースサービスのレイヤー
export const DatabaseServiceLive = Layer.succeed(
  DatabaseService,
  new PrismaDatabaseService(new PrismaClient())
);
```

## 高度なデータベース操作

### リトライ機能付きデータベース操作

```typescript
// src/database-with-retry.ts
import { Effect, Schedule, RetryPolicy } from 'effect';
import { DatabaseService, DatabaseError } from './database';

// リトライポリシーの定義
const databaseRetryPolicy = Schedule.exponential('100 millis').pipe(
  Schedule.andThen(Schedule.recurs(3))
);

// リトライ機能付きデータベース操作
export const withRetry = <A, E, R>(
  effect: Effect.Effect<A, E, R>
): Effect.Effect<A, E, R> =>
  Effect.retry(effect, databaseRetryPolicy);

// 使用例
export const createUserWithRetry = (data: CreateUserData) =>
  Effect.gen(function* () {
    const db = yield* DatabaseService;
    return yield* withRetry(db.user.create(data));
  });

export const findUserByIdWithRetry = (id: string) =>
  Effect.gen(function* () {
    const db = yield* DatabaseService;
    return yield* withRetry(db.user.findById(id));
  });
```

### トランザクション処理

```typescript
// src/transaction.ts
import { Effect, Layer } from 'effect';
import { PrismaClient } from '@prisma/client';
import { DatabaseService, DatabaseError, User, Post } from './database';

// トランザクション用のデータベースサービス
export interface TransactionService {
  readonly execute: <A>(
    effect: Effect.Effect<A, DatabaseError, DatabaseService>
  ) => Effect.Effect<A, DatabaseError>;
}

export const TransactionService = Context.GenericTag<TransactionService>('TransactionService');

// トランザクションサービスの実装
class PrismaTransactionService implements TransactionService {
  constructor(private readonly prisma: PrismaClient) {}

  readonly execute = <A>(
    effect: Effect.Effect<A, DatabaseError, DatabaseService>
  ) =>
    Effect.tryPromise({
      try: () =>
        this.prisma.$transaction(async (tx) => {
          // トランザクション内でのデータベースサービスを作成
          const dbService = new PrismaDatabaseService(tx as any);
          const layer = Layer.succeed(DatabaseService, dbService);
          
          // Effectを実行
          return Effect.runPromise(Effect.provide(effect, layer));
        }),
      catch: (error) => new DatabaseError(
        'Transaction failed',
        'TRANSACTION_ERROR',
        error
      )
    });
}

export const TransactionServiceLive = Layer.succeed(
  TransactionService,
  new PrismaTransactionService(new PrismaClient())
);

// トランザクション使用例
export const createUserWithPost = (
  userData: CreateUserData,
  postData: Omit<CreatePostData, 'authorId'>
) =>
  Effect.gen(function* () {
    const transaction = yield* TransactionService;
    
    return yield* transaction.execute(
      Effect.gen(function* () {
        const db = yield* DatabaseService;
        
        // ユーザー作成
        const user = yield* db.user.create(userData);
        
        // 投稿作成
        const post = yield* db.post.create({
          ...postData,
          authorId: user.id
        });
        
        return { user, post };
      })
    );
  });
```

## ビジネスロジックの実装

### ユーザー管理サービス

```typescript
// src/user-service.ts
import { Effect, Console } from 'effect';
import { DatabaseService, DatabaseError, User, CreateUserData } from './database';

// ビジネスエラーの定義
export class UserNotFoundError extends Error {
  constructor(public readonly userId: string) {
    super(`User with ID ${userId} not found`);
    this.name = 'UserNotFoundError';
  }
}

export class UserAlreadyExistsError extends Error {
  constructor(public readonly email: string) {
    super(`User with email ${email} already exists`);
    this.name = 'UserAlreadyExistsError';
  }
}

// ユーザーサービスの実装
export class UserService {
  // ユーザー作成（重複チェック付き）
  static createUser = (data: CreateUserData) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService;
      
      // 既存ユーザーのチェック
      const existingUser = yield* db.user.findByEmail(data.email);
      if (existingUser) {
        yield* Effect.fail(new UserAlreadyExistsError(data.email));
      }
      
      // ユーザー作成
      const user = yield* db.user.create(data);
      
      yield* Console.log(`User created: ${user.email}`);
      return user;
    });

  // ユーザー取得（存在チェック付き）
  static getUserById = (id: string) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService;
      
      const user = yield* db.user.findById(id);
      if (!user) {
        yield* Effect.fail(new UserNotFoundError(id));
      }
      
      return user;
    });

  // ユーザー更新
  static updateUser = (id: string, data: UpdateUserData) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService;
      
      // ユーザーの存在確認
      yield* UserService.getUserById(id);
      
      // メールアドレスが変更される場合の重複チェック
      if (data.email) {
        const existingUser = yield* db.user.findByEmail(data.email);
        if (existingUser && existingUser.id !== id) {
          yield* Effect.fail(new UserAlreadyExistsError(data.email));
        }
      }
      
      // ユーザー更新
      const updatedUser = yield* db.user.update(id, data);
      
      yield* Console.log(`User updated: ${updatedUser.email}`);
      return updatedUser;
    });

  // ユーザー削除
  static deleteUser = (id: string) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService;
      
      // ユーザーの存在確認
      yield* UserService.getUserById(id);
      
      // ユーザー削除
      yield* db.user.delete(id);
      
      yield* Console.log(`User deleted: ${id}`);
    });
}
```

### 投稿管理サービス

```typescript
// src/post-service.ts
import { Effect, Console } from 'effect';
import { DatabaseService, DatabaseError, Post, CreatePostData } from './database';
import { UserService, UserNotFoundError } from './user-service';

export class PostNotFoundError extends Error {
  constructor(public readonly postId: string) {
    super(`Post with ID ${postId} not found`);
    this.name = 'PostNotFoundError';
  }
}

export class PostService {
  // 投稿作成
  static createPost = (data: CreatePostData) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService;
      
      // 著者の存在確認
      yield* UserService.getUserById(data.authorId);
      
      // 投稿作成
      const post = yield* db.post.create(data);
      
      yield* Console.log(`Post created: ${post.title}`);
      return post;
    });

  // 投稿取得
  static getPostById = (id: string) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService;
      
      const post = yield* db.post.findById(id);
      if (!post) {
        yield* Effect.fail(new PostNotFoundError(id));
      }
      
      return post;
    });

  // 著者の投稿一覧取得
  static getPostsByAuthor = (authorId: string) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService;
      
      // 著者の存在確認
      yield* UserService.getUserById(authorId);
      
      // 投稿一覧取得
      const posts = yield* db.post.findByAuthor(authorId);
      
      yield* Console.log(`Found ${posts.length} posts for author ${authorId}`);
      return posts;
    });

  // 投稿更新
  static updatePost = (id: string, data: UpdatePostData) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService;
      
      // 投稿の存在確認
      yield* PostService.getPostById(id);
      
      // 投稿更新
      const updatedPost = yield* db.post.update(id, data);
      
      yield* Console.log(`Post updated: ${updatedPost.title}`);
      return updatedPost;
    });

  // 投稿削除
  static deletePost = (id: string) =>
    Effect.gen(function* () {
      const db = yield* DatabaseService;
      
      // 投稿の存在確認
      yield* PostService.getPostById(id);
      
      // 投稿削除
      yield* db.post.delete(id);
      
      yield* Console.log(`Post deleted: ${id}`);
    });
}
```

## アプリケーションの実装

### メインアプリケーション

```typescript
// src/app.ts
import { Effect, Console, Exit } from 'effect';
import { DatabaseServiceLive } from './database-service';
import { TransactionServiceLive } from './transaction';
import { UserService } from './user-service';
import { PostService } from './post-service';

// アプリケーションの実行
const main = Effect.gen(function* () {
  yield* Console.log('Starting application...');
  
  try {
    // ユーザー作成
    const user = yield* UserService.createUser({
      email: 'john@example.com',
      name: 'John Doe'
    });
    
    yield* Console.log('User created:', user);
    
    // 投稿作成
    const post = yield* PostService.createPost({
      title: 'My First Post',
      content: 'This is my first post using Effect and Prisma!',
      authorId: user.id,
      published: true
    });
    
    yield* Console.log('Post created:', post);
    
    // 投稿一覧取得
    const posts = yield* PostService.getPostsByAuthor(user.id);
    yield* Console.log('User posts:', posts);
    
    // 投稿更新
    const updatedPost = yield* PostService.updatePost(post.id, {
      title: 'Updated Post Title',
      content: 'This post has been updated!'
    });
    
    yield* Console.log('Post updated:', updatedPost);
    
    yield* Console.log('Application completed successfully!');
    
  } catch (error) {
    yield* Console.error('Application error:', error);
    throw error;
  }
});

// アプリケーションの実行
const runApp = Effect.provide(
  main,
  Layer.mergeAll(DatabaseServiceLive, TransactionServiceLive)
);

// 実行
Effect.runPromise(runApp).then(
  (result) => {
    console.log('Application finished:', result);
    process.exit(0);
  },
  (error) => {
    console.error('Application failed:', error);
    process.exit(1);
  }
);
```

### エラーハンドリングの実装

```typescript
// src/error-handling.ts
import { Effect, Console } from 'effect';
import { DatabaseError } from './database';
import { UserNotFoundError, UserAlreadyExistsError } from './user-service';
import { PostNotFoundError } from './post-service';

// エラーハンドリングの実装
export const handleError = (error: unknown) =>
  Effect.gen(function* () {
    if (error instanceof UserNotFoundError) {
      yield* Console.error(`User not found: ${error.userId}`);
      return { type: 'user_not_found', message: error.message };
    }
    
    if (error instanceof UserAlreadyExistsError) {
      yield* Console.error(`User already exists: ${error.email}`);
      return { type: 'user_already_exists', message: error.message };
    }
    
    if (error instanceof PostNotFoundError) {
      yield* Console.error(`Post not found: ${error.postId}`);
      return { type: 'post_not_found', message: error.message };
    }
    
    if (error instanceof DatabaseError) {
      yield* Console.error(`Database error: ${error.message}`, error.originalError);
      return { type: 'database_error', message: error.message };
    }
    
    yield* Console.error('Unknown error:', error);
    return { type: 'unknown_error', message: 'An unknown error occurred' };
  });

// エラーハンドリング付きのアプリケーション実行
export const runAppWithErrorHandling = (app: Effect.Effect<any, any, any>) =>
  Effect.gen(function* () {
    const result = yield* Effect.either(app);
    
    if (result._tag === 'Left') {
      const errorInfo = yield* handleError(result.left);
      yield* Console.error('Application failed:', errorInfo);
      return errorInfo;
    }
    
    return result.right;
  });
```

## テストの実装

### モックデータベースサービス

```typescript
// src/test/mock-database.ts
import { Effect, Layer } from 'effect';
import { DatabaseService, User, Post } from '../database';

// モックデータ
const mockUsers: User[] = [
  {
    id: '1',
    email: 'test@example.com',
    name: 'Test User',
    createdAt: new Date(),
    updatedAt: new Date()
  }
];

const mockPosts: Post[] = [
  {
    id: '1',
    title: 'Test Post',
    content: 'Test content',
    published: true,
    authorId: '1',
    createdAt: new Date(),
    updatedAt: new Date()
  }
];

// モックデータベースサービス
class MockDatabaseService implements DatabaseService {
  readonly user = {
    create: (data: CreateUserData) =>
      Effect.succeed({
        id: '2',
        email: data.email,
        name: data.name,
        createdAt: new Date(),
        updatedAt: new Date()
      }),

    findById: (id: string) =>
      Effect.succeed(mockUsers.find(user => user.id === id) || null),

    findByEmail: (email: string) =>
      Effect.succeed(mockUsers.find(user => user.email === email) || null),

    update: (id: string, data: UpdateUserData) =>
      Effect.succeed({
        id,
        email: data.email || 'test@example.com',
        name: data.name || 'Test User',
        createdAt: new Date(),
        updatedAt: new Date()
      }),

    delete: (id: string) => Effect.succeed(undefined)
  };

  readonly post = {
    create: (data: CreatePostData) =>
      Effect.succeed({
        id: '2',
        title: data.title,
        content: data.content,
        published: data.published || false,
        authorId: data.authorId,
        createdAt: new Date(),
        updatedAt: new Date()
      }),

    findById: (id: string) =>
      Effect.succeed(mockPosts.find(post => post.id === id) || null),

    findByAuthor: (authorId: string) =>
      Effect.succeed(mockPosts.filter(post => post.authorId === authorId)),

    update: (id: string, data: UpdatePostData) =>
      Effect.succeed({
        id,
        title: data.title || 'Test Post',
        content: data.content || 'Test content',
        published: data.published || false,
        authorId: '1',
        createdAt: new Date(),
        updatedAt: new Date()
      }),

    delete: (id: string) => Effect.succeed(undefined)
  };
}

export const MockDatabaseServiceLive = Layer.succeed(
  DatabaseService,
  new MockDatabaseService()
);
```

### テストの実行

```typescript
// src/test/user-service.test.ts
import { Effect } from 'effect';
import { UserService } from '../user-service';
import { MockDatabaseServiceLive } from './mock-database';

// テストの実行
const testUserService = Effect.gen(function* () {
  // ユーザー作成のテスト
  const user = yield* UserService.createUser({
    email: 'test@example.com',
    name: 'Test User'
  });
  
  console.log('User created:', user);
  
  // ユーザー取得のテスト
  const foundUser = yield* UserService.getUserById(user.id);
  console.log('User found:', foundUser);
  
  // ユーザー更新のテスト
  const updatedUser = yield* UserService.updateUser(user.id, {
    name: 'Updated User'
  });
  console.log('User updated:', updatedUser);
  
  return { user, foundUser, updatedUser };
});

// テスト実行
Effect.runPromise(
  Effect.provide(testUserService, MockDatabaseServiceLive)
).then(
  (result) => console.log('Test completed:', result),
  (error) => console.error('Test failed:', error)
);
```

## まとめ

EffectとPrismaを組み合わせることで、以下の利点が得られます：

### 主要な特徴
- **型安全性**: データベース操作からエラーハンドリングまで完全な型安全性
- **エラーハンドリング**: データベースエラーを値として扱い、適切に処理
- **リトライ機能**: データベース接続エラーの自動リトライ
- **並行処理**: 安全な並行データベース操作
- **テスト容易性**: モック化しやすい設計

### 実装のポイント
- **適切なエラー設計**: ビジネスロジックに応じたエラーの定義
- **リトライポリシー**: データベース操作の適切なリトライ設定
- **トランザクション処理**: 複数の操作を安全に実行
- **テスト設計**: モックを使った効果的なテスト

### 実践的な用途
- **大規模アプリケーション**: 複雑なデータベース操作の管理
- **マイクロサービス**: 堅牢なデータベースサービス
- **リアルタイムアプリケーション**: 並行処理を活用したアプリケーション
- **エンタープライズアプリケーション**: 高い信頼性が求められるシステム

[Effect公式サイト](https://effect.website/)を参考に、型安全で堅牢なデータベースアプリケーションを構築しましょう。Effectの強力な機能とPrismaのORM機能を組み合わせることで、保守性の高いアプリケーションを実現できます。
