---
date: 2025-10-01
title: Rust入門完全ガイド：安全で高速なシステムプログラミング言語を初心者向けに解説
description: Rustの基本から実践的な使い方まで、初心者向けに分かりやすく解説。所有権システム、メモリ安全性、パフォーマンス、実用的なコード例など、Rustの核心を実際のプログラムと共に詳しく説明する。
tags:
  - rust
  - programming
  - systems-programming
  - memory-safety
  - performance
  - beginner
  - tutorial
  - ownership
prev:
  text: 'Python機械学習入門完全ガイド：初心者でもわかる実践的な例と解説'
  link: '/posts/2025/09/30'
next: false
---

# Rust入門完全ガイド：安全で高速なシステムプログラミング言語を初心者向けに解説

[Rust](https://rust-lang.org/ja/)は、メモリ安全性とパフォーマンスを両立した現代的なシステムプログラミング言語です。C++の速度とPythonの安全性を兼ね備え、多くの企業で採用されています。初心者にも分かりやすいRustの基本から実践的な使い方まで詳しく解説します。

## Rustとは何か

Rustは、Mozillaが開発したシステムプログラミング言語です。以下の特徴があります：

- **メモリ安全性**: コンパイル時にメモリエラーを防ぐ
- **高パフォーマンス**: C++に匹敵する実行速度
- **所有権システム**: ガベージコレクタなしでメモリ管理
- **型安全性**: 強力な型システムによるバグの早期発見
- **並行性**: 安全な並行プログラミング
- **クロスプラットフォーム**: Windows、macOS、Linuxで動作

## Rustのインストール

### 公式インストーラーを使用

```bash
# Linux/macOS
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Windows
# https://rustup.rs/ からインストーラーをダウンロード
```

### インストールの確認

```bash
# Rustのバージョン確認
rustc --version

# Cargoのバージョン確認
cargo --version
```

### 開発環境のセットアップ

```bash
# Rustの更新
rustup update

# コンポーネントの追加
rustup component add rustfmt clippy

# エディタ用の言語サーバー
rustup component add rust-analyzer
```

## 最初のRustプログラム

### Hello, World!

```rust
// main.rs
fn main() {
    println!("Hello, World!");
}
```

### コンパイルと実行

```bash
# コンパイル
rustc main.rs

# 実行
./main

# または直接実行
rustc main.rs && ./main
```

### Cargoプロジェクトの作成

```bash
# 新しいプロジェクトの作成
cargo new hello_rust

# プロジェクトディレクトリに移動
cd hello_rust

# プロジェクトの実行
cargo run

# プロジェクトのビルド
cargo build

# リリースビルド
cargo build --release
```

## 基本的な構文

### 変数とデータ型

```rust
fn main() {
    // 不変変数（デフォルト）
    let x = 5;
    println!("x = {}", x);

    // 可変変数
    let mut y = 10;
    y = 20;
    println!("y = {}", y);

    // 型注釈
    let z: i32 = 30;
    let name: String = String::from("Rust");

    // 基本的なデータ型
    let integer: i32 = 42;
    let float: f64 = 3.14;
    let boolean: bool = true;
    let character: char = 'R';

    // 配列
    let array: [i32; 5] = [1, 2, 3, 4, 5];
    println!("配列: {:?}", array);

    // ベクター（動的配列）
    let mut vector: Vec<i32> = vec![1, 2, 3];
    vector.push(4);
    println!("ベクター: {:?}", vector);
}
```

### 関数の定義

```rust
// 関数の定義
fn add(a: i32, b: i32) -> i32 {
    a + b  // セミコロンなしで値を返す
}

// 複数の戻り値
fn get_name_and_age() -> (String, u32) {
    (String::from("Alice"), 25)
}

// 参照を取る関数
fn print_length(s: &String) {
    println!("文字列の長さ: {}", s.len());
}

fn main() {
    let result = add(5, 3);
    println!("5 + 3 = {}", result);

    let (name, age) = get_name_and_age();
    println!("名前: {}, 年齢: {}", name, age);

    let text = String::from("Hello, Rust!");
    print_length(&text);
}
```

### 制御構造

```rust
fn main() {
    let number = 7;

    // if文
    if number < 5 {
        println!("5より小さい");
    } else if number < 10 {
        println!("5以上10未満");
    } else {
        println!("10以上");
    }

    // 三項演算子的な使い方
    let result = if number > 5 { "大きい" } else { "小さい" };
    println!("結果: {}", result);

    // ループ
    let mut counter = 0;
    loop {
        counter += 1;
        if counter == 3 {
            break;
        }
    }
    println!("カウンター: {}", counter);

    // while文
    let mut count = 0;
    while count < 3 {
        println!("カウント: {}", count);
        count += 1;
    }

    // for文
    for i in 1..4 {
        println!("i = {}", i);
    }

    // 配列の反復
    let array = [10, 20, 30];
    for item in array.iter() {
        println!("アイテム: {}", item);
    }
}
```

## 所有権システム

### 所有権の基本概念

```rust
fn main() {
    // 所有権の移動
    let s1 = String::from("Hello");
    let s2 = s1;  // s1の所有権がs2に移動
    // println!("{}", s1);  // エラー！s1はもう使えない

    println!("{}", s2);  // OK

    // クローン（深いコピー）
    let s3 = String::from("World");
    let s4 = s3.clone();  // 所有権をコピー
    println!("{}", s3);   // OK
    println!("{}", s4);   // OK
}
```

### 参照と借用

```rust
fn main() {
    let s1 = String::from("Hello, Rust!");

    // 参照（借用）
    let len = calculate_length(&s1);
    println!("文字列 '{}' の長さは {} です。", s1, len);

    // 可変参照
    let mut s2 = String::from("Hello");
    change_string(&mut s2);
    println!("変更後: {}", s2);
}

fn calculate_length(s: &String) -> usize {
    s.len()  // 所有権を取らずに参照のみ
}

fn change_string(s: &mut String) {
    s.push_str(", World!");
}
```

### スライス

```rust
fn main() {
    let s = String::from("Hello, World!");

    // 文字列スライス
    let hello = &s[0..5];
    let world = &s[7..12];

    println!("{}", hello);  // "Hello"
    println!("{}", world);  // "World"

    // 配列のスライス
    let array = [1, 2, 3, 4, 5];
    let slice = &array[1..4];
    println!("{:?}", slice);  // [2, 3, 4]

    // スライスを引数に取る関数
    let word = first_word(&s);
    println!("最初の単語: {}", word);
}

fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

## 構造体と列挙型

### 構造体

```rust
// 構造体の定義
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

// 構造体のメソッド
impl User {
    // 関連関数（静的メソッド）
    fn new(username: String, email: String) -> User {
        User {
            username,
            email,
            sign_in_count: 1,
            active: true,
        }
    }

    // インスタンスメソッド
    fn get_username(&self) -> &String {
        &self.username
    }

    fn increment_sign_in(&mut self) {
        self.sign_in_count += 1;
    }

    fn deactivate(&mut self) {
        self.active = false;
    }
}

fn main() {
    // 構造体のインスタンス作成
    let mut user1 = User {
        username: String::from("alice"),
        email: String::from("alice@example.com"),
        sign_in_count: 1,
        active: true,
    };

    // フィールドのアクセス
    println!("ユーザー名: {}", user1.username);

    // メソッドの呼び出し
    user1.increment_sign_in();
    println!("サインイン回数: {}", user1.sign_in_count);

    // 関連関数の使用
    let user2 = User::new(
        String::from("bob"),
        String::from("bob@example.com")
    );
    println!("新しいユーザー: {}", user2.get_username());
}
```

### 列挙型

```rust
// 列挙型の定義
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

// 列挙型のメソッド
impl Message {
    fn call(&self) {
        match self {
            Message::Quit => println!("終了します"),
            Message::Move { x, y } => println!("移動: ({}, {})", x, y),
            Message::Write(text) => println!("メッセージ: {}", text),
            Message::ChangeColor(r, g, b) => println!("色変更: RGB({}, {}, {})", r, g, b),
        }
    }
}

// Option列挙型（Rustの標準ライブラリ）
fn divide(a: i32, b: i32) -> Option<i32> {
    if b != 0 {
        Some(a / b)
    } else {
        None
    }
}

// Result列挙型（エラーハンドリング）
fn read_file(filename: &str) -> Result<String, std::io::Error> {
    std::fs::read_to_string(filename)
}

fn main() {
    // 列挙型の使用
    let msg1 = Message::Write(String::from("Hello"));
    msg1.call();

    let msg2 = Message::Move { x: 10, y: 20 };
    msg2.call();

    // Optionの使用
    let result = divide(10, 2);
    match result {
        Some(value) => println!("結果: {}", value),
        None => println!("ゼロ除算エラー"),
    }

    // Resultの使用
    match read_file("example.txt") {
        Ok(content) => println!("ファイル内容: {}", content),
        Err(error) => println!("エラー: {}", error),
    }
}
```

## エラーハンドリング

### Result型の使用

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    // ファイルを開く
    let file_result = File::open("hello.txt");

    let file = match file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("ファイル作成に失敗: {:?}", e),
            },
            other_error => {
                panic!("ファイルを開く際に問題が発生: {:?}", other_error)
            }
        },
    };

    println!("ファイルが正常に開かれました");
}

// エラーを伝播する関数
fn read_username_from_file() -> Result<String, std::io::Error> {
    let mut s = String::new();

    // ?演算子を使用してエラーを伝播
    std::fs::File::open("hello.txt")?
        .read_to_string(&mut s)?;

    Ok(s)
}

// unwrap_or_elseの使用
fn get_file_size(filename: &str) -> usize {
    std::fs::read_to_string(filename)
        .unwrap_or_else(|_| String::from(""))
        .len()
}
```

### カスタムエラー型

```rust
use std::fmt;

// カスタムエラー型の定義
#[derive(Debug)]
enum MathError {
    DivisionByZero,
    NegativeSquareRoot,
}

impl fmt::Display for MathError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            MathError::DivisionByZero => write!(f, "ゼロ除算エラー"),
            MathError::NegativeSquareRoot => write!(f, "負の数の平方根"),
        }
    }
}

// カスタムエラーを使用する関数
fn safe_divide(a: f64, b: f64) -> Result<f64, MathError> {
    if b == 0.0 {
        Err(MathError::DivisionByZero)
    } else {
        Ok(a / b)
    }
}

fn safe_sqrt(x: f64) -> Result<f64, MathError> {
    if x < 0.0 {
        Err(MathError::NegativeSquareRoot)
    } else {
        Ok(x.sqrt())
    }
}

fn main() {
    // エラーハンドリングの例
    match safe_divide(10.0, 2.0) {
        Ok(result) => println!("10 / 2 = {}", result),
        Err(e) => println!("エラー: {}", e),
    }

    match safe_divide(10.0, 0.0) {
        Ok(result) => println!("結果: {}", result),
        Err(e) => println!("エラー: {}", e),
    }
}
```

## ジェネリクスとトレイト

### ジェネリクス

```rust
// ジェネリック関数
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

// ジェネリック構造体
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn new(x: T, y: T) -> Point<T> {
        Point { x, y }
    }

    fn x(&self) -> &T {
        &self.x
    }
}

// 特定の型に対する実装
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    // 整数のリスト
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest(&number_list);
    println!("最大値: {}", result);

    // 文字のリスト
    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest(&char_list);
    println!("最大文字: {}", result);

    // ジェネリック構造体の使用
    let integer_point = Point::new(5, 10);
    let float_point = Point::new(1.0, 4.0);

    println!("整数点: ({}, {})", integer_point.x(), integer_point.y());
    println!("浮動小数点: ({}, {})", float_point.x(), float_point.y());
    println!("原点からの距離: {}", float_point.distance_from_origin());
}
```

### トレイト

```rust
// トレイトの定義
trait Summary {
    fn summarize(&self) -> String;

    // デフォルト実装
    fn author(&self) -> String {
        String::from("不明")
    }
}

// ニュース記事構造体
struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }

    fn author(&self) -> String {
        self.author.clone()
    }
}

// ツイート構造体
struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}

// トレイト境界を使用した関数
fn notify<T: Summary>(item: &T) {
    println!("通知: {}", item.summarize());
}

// where句を使用した複雑なトレイト境界
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Summary + Clone,
    U: Clone + std::fmt::Debug,
{
    0
}

fn main() {
    let article = NewsArticle {
        headline: String::from("Rustの新機能"),
        location: String::from("東京"),
        author: String::from("田中太郎"),
        content: String::from("Rustに新しい機能が追加されました..."),
    };

    let tweet = Tweet {
        username: String::from("rust_lang"),
        content: String::from("Rust 1.70.0がリリースされました！"),
        reply: false,
        retweet: false,
    };

    println!("記事: {}", article.summarize());
    println!("ツイート: {}", tweet.summarize());

    notify(&article);
    notify(&tweet);
}
```

## 並行プログラミング

### スレッド

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // 基本的なスレッド作成
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("スレッド内の数値: {}", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("メインスレッドの数値: {}", i);
        thread::sleep(Duration::from_millis(1));
    }

    // スレッドの完了を待つ
    handle.join().unwrap();

    // データをスレッドに移動
    let v = vec![1, 2, 3];
    let handle = thread::spawn(move || {
        println!("ベクター: {:?}", v);
    });

    handle.join().unwrap();
}
```

### チャンネル

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    // チャンネルの作成
    let (tx, rx) = mpsc::channel();

    // 送信側スレッド
    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    // 別の送信側スレッド
    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    // 受信側
    for received in rx {
        println!("受信: {}", received);
    }
}
```

### MutexとArc

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    // Arc（Atomically Reference Counted）で共有
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("結果: {}", *counter.lock().unwrap());
}
```

## 実践的なプロジェクト例

### コマンドラインツール

```rust
use std::env;
use std::fs;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        eprintln!("使用方法: {} <ファイル名>", args[0]);
        process::exit(1);
    }

    let filename = &args[1];

    match read_file(filename) {
        Ok(content) => {
            let word_count = count_words(&content);
            let line_count = count_lines(&content);
            let char_count = content.len();

            println!("ファイル: {}", filename);
            println!("行数: {}", line_count);
            println!("単語数: {}", word_count);
            println!("文字数: {}", char_count);
        }
        Err(error) => {
            eprintln!("エラー: {}", error);
            process::exit(1);
        }
    }
}

fn read_file(filename: &str) -> Result<String, std::io::Error> {
    fs::read_to_string(filename)
}

fn count_words(content: &str) -> usize {
    content.split_whitespace().count()
}

fn count_lines(content: &str) -> usize {
    content.lines().count()
}
```

### HTTPサーバー（シンプル版）

```rust
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    println!("サーバーがポート7878で起動しました");

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let get = b"GET / HTTP/1.1\r\n";
    let (status_line, filename) = if buffer.starts_with(get) {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let response = format!(
        "{}\r\nContent-Length: {}\r\n\r\n{}",
        status_line,
        contents.len(),
        contents
    );

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
```

## Cargoとパッケージ管理

### Cargo.tomlの設定

```toml
[package]
name = "my_project"
version = "0.1.0"
edition = "2021"
authors = ["Your Name <your.email@example.com>"]
description = "A sample Rust project"

[dependencies]
serde = "1.0"
serde_json = "1.0"
tokio = { version = "1.0", features = ["full"] }

[dev-dependencies]
tempfile = "3.0"

[[bin]]
name = "main"
path = "src/main.rs"

[lib]
name = "my_project"
path = "src/lib.rs"
```

### 外部クレートの使用

```rust
// Cargo.tomlに追加: serde = "1.0", serde_json = "1.0"
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
struct Person {
    name: String,
    age: u32,
    email: String,
}

fn main() {
    let person = Person {
        name: String::from("Alice"),
        age: 30,
        email: String::from("alice@example.com"),
    };

    // JSONにシリアライズ
    let json = serde_json::to_string(&person).unwrap();
    println!("JSON: {}", json);

    // JSONからデシリアライズ
    let deserialized: Person = serde_json::from_str(&json).unwrap();
    println!("デシリアライズ: {:?}", deserialized);
}
```

## まとめ

Rustは、メモリ安全性とパフォーマンスを両立した現代的なシステムプログラミング言語です。主なポイントは以下の通りです：

- **所有権システム**: メモリ安全性をコンパイル時に保証
- **型安全性**: 強力な型システムによるバグの早期発見
- **高パフォーマンス**: C++に匹敵する実行速度
- **並行性**: 安全な並行プログラミング
- **豊富なエコシステム**: Cargoによる優れたパッケージ管理
- **クロスプラットフォーム**: 様々な環境で動作

Rustを学ぶことで、安全で高速なシステムソフトウェアを開発する能力を身につけることができます。

## 次のステップ

- より高度な所有権パターンの学習
- 非同期プログラミング（async/await）
- WebAssemblyでの使用
- システムプログラミング
- ネットワークプログラミング
- 組み込みシステム開発
- パフォーマンス最適化
