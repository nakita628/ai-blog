---
date: 2025-10-22
title: Amazon DynamoDB完全入門：サーバーレスNoSQLデータベースでスケーラブルなアプリケーションを構築する
description: Amazon DynamoDBの基本概念から実装方法まで、初心者向けに詳しく解説。従来のRDBMSとの違い、パーティションキーとソートキーの設計、グローバルセカンダリインデックス、実践的なアプリケーション構築を通じて、DynamoDBを使った効率的なデータベース設計を学ぶ実践的なガイド。
tags:
  - dynamodb
  - aws
  - nosql
  - database
  - serverless
  - scalability
  - cloud
  - backend
prev:
  text: 'tRPC完全入門：型安全なAPI開発でフルスタックTypeScriptを極める'
  link: '/posts/2025/10/17'
next: false
---

# Amazon DynamoDB完全入門：サーバーレスNoSQLデータベースでスケーラブルなアプリケーションを構築する

Amazon DynamoDBは、AWSが提供するフルマネージドのNoSQLデータベースサービスです。従来のリレーショナルデータベースとは異なる設計思想を持ち、スケーラビリティとパフォーマンスを重視したアーキテクチャを採用しています。この記事では、DynamoDBの基本概念から実装方法まで、初心者向けに詳しく解説します。

## DynamoDBとは

[Amazon DynamoDB](https://aws.amazon.com/jp/dynamodb/)は、AWSが提供するサーバーレスNoSQLデータベースサービスです。以下の特徴を持っています：

- **フルマネージド**: インフラストラクチャの管理が不要
- **サーバーレス**: 自動スケーリングとペイ・パー・ユース課金
- **高可用性**: 99.999%のSLAを提供
- **グローバル分散**: マルチリージョンでのデータレプリケーション

### 従来のRDBMSとの違い

| 項目             | RDBMS                              | DynamoDB                           |
| ---------------- | ---------------------------------- | ---------------------------------- |
| データモデル     | リレーショナル（テーブル・行・列） | ドキュメント（アイテム・属性）     |
| スキーマ         | 固定スキーマ                       | スキーマレス                       |
| スケーリング     | 垂直スケーリング                   | 水平スケーリング                   |
| クエリ           | SQL                                | パーティションキー・ソートキー     |
| トランザクション | ACID                               | 条件付き書き込み・トランザクション |

## DynamoDBの基本概念

### 1. テーブルとアイテム

```json
// DynamoDBのアイテム例
{
  "UserId": "user123",
  "OrderId": "order456",
  "OrderDate": "2025-10-22",
  "TotalAmount": 150.0,
  "Items": [
    {
      "ProductId": "prod789",
      "Quantity": 2,
      "Price": 75.0
    }
  ],
  "ShippingAddress": {
    "Street": "123 Main St",
    "City": "Tokyo",
    "PostalCode": "100-0001"
  }
}
```

### 2. パーティションキーとソートキー

DynamoDBでは、データの一意性とアクセスパターンを定義するためにキーを使用します：

- **パーティションキー（Primary Key）**: データの物理的な配置を決定
- **ソートキー（Sort Key）**: パーティション内での順序を決定

```typescript
// テーブル設計例
interface UserTable {
  // パーティションキーのみ
  UserId: string // PK
  Name: string
  Email: string
}

interface OrderTable {
  // パーティションキー + ソートキー
  UserId: string // PK
  OrderId: string // SK
  OrderDate: string
  TotalAmount: number
}
```

## 実践的なアプリケーション構築

### プロジェクトのセットアップ

```bash
# Node.jsプロジェクトを作成
mkdir dynamodb-app
cd dynamodb-app
npm init -y

# 必要なパッケージをインストール
npm install aws-sdk @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb
npm install express cors dotenv
npm install -D typescript @types/node @types/express ts-node nodemon

# TypeScript設定
npx tsc --init
```

### AWS SDKの設定

```typescript
// src/config/aws.ts
import { DynamoDBClient } from '@aws-sdk/client-dynamodb'
import { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb'

// DynamoDBクライアントの設定
const client = new DynamoDBClient({
  region: process.env.AWS_REGION || 'ap-northeast-1',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || '',
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || '',
  },
})

export const dynamoDB = DynamoDBDocumentClient.from(client)
```

### 基本的なCRUD操作

```typescript
// src/services/userService.ts
import { dynamoDB } from '../config/aws'
import {
  PutCommand,
  GetCommand,
  UpdateCommand,
  DeleteCommand,
  ScanCommand,
} from '@aws-sdk/lib-dynamodb'

export interface User {
  UserId: string
  Name: string
  Email: string
  CreatedAt: string
  UpdatedAt: string
}

export class UserService {
  private tableName = 'Users'

  // ユーザーを作成
  async createUser(user: Omit<User, 'CreatedAt' | 'UpdatedAt'>): Promise<User> {
    const now = new Date().toISOString()
    const newUser: User = {
      ...user,
      CreatedAt: now,
      UpdatedAt: now,
    }

    await dynamoDB.send(
      new PutCommand({
        TableName: this.tableName,
        Item: newUser,
      }),
    )

    return newUser
  }

  // ユーザーを取得
  async getUser(userId: string): Promise<User | null> {
    const result = await dynamoDB.send(
      new GetCommand({
        TableName: this.tableName,
        Key: { UserId: userId },
      }),
    )

    return (result.Item as User) || null
  }

  // ユーザーを更新
  async updateUser(
    userId: string,
    updates: Partial<Omit<User, 'UserId' | 'CreatedAt'>>,
  ): Promise<User | null> {
    const updateExpression: string[] = []
    const expressionAttributeNames: Record<string, string> = {}
    const expressionAttributeValues: Record<string, any> = {}

    // 更新するフィールドを動的に構築
    Object.keys(updates).forEach((key, index) => {
      if (key !== 'UserId' && key !== 'CreatedAt') {
        updateExpression.push(`#${key} = :val${index}`)
        expressionAttributeNames[`#${key}`] = key
        expressionAttributeValues[`:val${index}`] = updates[key as keyof typeof updates]
      }
    })

    // UpdatedAtを自動更新
    updateExpression.push('#UpdatedAt = :updatedAt')
    expressionAttributeNames['#UpdatedAt'] = 'UpdatedAt'
    expressionAttributeValues[':updatedAt'] = new Date().toISOString()

    const result = await dynamoDB.send(
      new UpdateCommand({
        TableName: this.tableName,
        Key: { UserId: userId },
        UpdateExpression: `SET ${updateExpression.join(', ')}`,
        ExpressionAttributeNames: expressionAttributeNames,
        ExpressionAttributeValues: expressionAttributeValues,
        ReturnValues: 'ALL_NEW',
      }),
    )

    return (result.Attributes as User) || null
  }

  // ユーザーを削除
  async deleteUser(userId: string): Promise<boolean> {
    await dynamoDB.send(
      new DeleteCommand({
        TableName: this.tableName,
        Key: { UserId: userId },
      }),
    )

    return true
  }

  // 全ユーザーを取得（スキャン）
  async getAllUsers(): Promise<User[]> {
    const result = await dynamoDB.send(
      new ScanCommand({
        TableName: this.tableName,
      }),
    )

    return (result.Items as User[]) || []
  }
}
```

### 注文管理システムの実装

```typescript
// src/services/orderService.ts
import { dynamoDB } from '../config/aws'
import { PutCommand, GetCommand, QueryCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb'

export interface Order {
  UserId: string // パーティションキー
  OrderId: string // ソートキー
  OrderDate: string
  TotalAmount: number
  Status: 'pending' | 'confirmed' | 'shipped' | 'delivered' | 'cancelled'
  Items: OrderItem[]
  ShippingAddress: Address
  CreatedAt: string
  UpdatedAt: string
}

export interface OrderItem {
  ProductId: string
  ProductName: string
  Quantity: number
  Price: number
}

export interface Address {
  Street: string
  City: string
  PostalCode: string
  Country: string
}

export class OrderService {
  private tableName = 'Orders'

  // 注文を作成
  async createOrder(order: Omit<Order, 'CreatedAt' | 'UpdatedAt'>): Promise<Order> {
    const now = new Date().toISOString()
    const newOrder: Order = {
      ...order,
      CreatedAt: now,
      UpdatedAt: now,
    }

    await dynamoDB.send(
      new PutCommand({
        TableName: this.tableName,
        Item: newOrder,
      }),
    )

    return newOrder
  }

  // 注文を取得
  async getOrder(userId: string, orderId: string): Promise<Order | null> {
    const result = await dynamoDB.send(
      new GetCommand({
        TableName: this.tableName,
        Key: {
          UserId: userId,
          OrderId: orderId,
        },
      }),
    )

    return (result.Item as Order) || null
  }

  // ユーザーの全注文を取得
  async getUserOrders(userId: string): Promise<Order[]> {
    const result = await dynamoDB.send(
      new QueryCommand({
        TableName: this.tableName,
        KeyConditionExpression: 'UserId = :userId',
        ExpressionAttributeValues: {
          ':userId': userId,
        },
        ScanIndexForward: false, // 新しい順でソート
      }),
    )

    return (result.Items as Order[]) || []
  }

  // 注文ステータスを更新
  async updateOrderStatus(
    userId: string,
    orderId: string,
    status: Order['Status'],
  ): Promise<Order | null> {
    const result = await dynamoDB.send(
      new UpdateCommand({
        TableName: this.tableName,
        Key: {
          UserId: userId,
          OrderId: orderId,
        },
        UpdateExpression: 'SET #Status = :status, #UpdatedAt = :updatedAt',
        ExpressionAttributeNames: {
          '#Status': 'Status',
          '#UpdatedAt': 'UpdatedAt',
        },
        ExpressionAttributeValues: {
          ':status': status,
          ':updatedAt': new Date().toISOString(),
        },
        ReturnValues: 'ALL_NEW',
      }),
    )

    return (result.Attributes as Order) || null
  }
}
```

### Express.js APIサーバーの実装

```typescript
// src/app.ts
import express from 'express'
import cors from 'cors'
import { UserService } from './services/userService'
import { OrderService } from './services/orderService'

const app = express()
const port = process.env.PORT || 3000

app.use(cors())
app.use(express.json())

const userService = new UserService()
const orderService = new OrderService()

// ユーザー関連のエンドポイント
app.post('/api/users', async (req, res) => {
  try {
    const user = await userService.createUser(req.body)
    res.status(201).json(user)
  } catch (error) {
    res.status(500).json({ error: 'Failed to create user' })
  }
})

app.get('/api/users/:userId', async (req, res) => {
  try {
    const user = await userService.getUser(req.params.userId)
    if (!user) {
      return res.status(404).json({ error: 'User not found' })
    }
    res.json(user)
  } catch (error) {
    res.status(500).json({ error: 'Failed to get user' })
  }
})

app.put('/api/users/:userId', async (req, res) => {
  try {
    const user = await userService.updateUser(req.params.userId, req.body)
    if (!user) {
      return res.status(404).json({ error: 'User not found' })
    }
    res.json(user)
  } catch (error) {
    res.status(500).json({ error: 'Failed to update user' })
  }
})

app.delete('/api/users/:userId', async (req, res) => {
  try {
    await userService.deleteUser(req.params.userId)
    res.status(204).send()
  } catch (error) {
    res.status(500).json({ error: 'Failed to delete user' })
  }
})

// 注文関連のエンドポイント
app.post('/api/orders', async (req, res) => {
  try {
    const order = await orderService.createOrder(req.body)
    res.status(201).json(order)
  } catch (error) {
    res.status(500).json({ error: 'Failed to create order' })
  }
})

app.get('/api/users/:userId/orders', async (req, res) => {
  try {
    const orders = await orderService.getUserOrders(req.params.userId)
    res.json(orders)
  } catch (error) {
    res.status(500).json({ error: 'Failed to get orders' })
  }
})

app.get('/api/users/:userId/orders/:orderId', async (req, res) => {
  try {
    const order = await orderService.getOrder(req.params.userId, req.params.orderId)
    if (!order) {
      return res.status(404).json({ error: 'Order not found' })
    }
    res.json(order)
  } catch (error) {
    res.status(500).json({ error: 'Failed to get order' })
  }
})

app.patch('/api/users/:userId/orders/:orderId/status', async (req, res) => {
  try {
    const { status } = req.body
    const order = await orderService.updateOrderStatus(
      req.params.userId,
      req.params.orderId,
      status,
    )
    if (!order) {
      return res.status(404).json({ error: 'Order not found' })
    }
    res.json(order)
  } catch (error) {
    res.status(500).json({ error: 'Failed to update order status' })
  }
})

app.listen(port, () => {
  console.log(`Server is running on port ${port}`)
})
```

## グローバルセカンダリインデックス（GSI）

GSIを使用することで、異なるパーティションキーでのクエリが可能になります：

```typescript
// src/services/productService.ts
export interface Product {
  ProductId: string // パーティションキー
  Category: string // GSIのパーティションキー
  Name: string
  Price: number
  Stock: number
  CreatedAt: string
}

export class ProductService {
  private tableName = 'Products'

  // カテゴリ別で商品を取得（GSIを使用）
  async getProductsByCategory(category: string): Promise<Product[]> {
    const result = await dynamoDB.send(
      new QueryCommand({
        TableName: this.tableName,
        IndexName: 'CategoryIndex', // GSI名
        KeyConditionExpression: 'Category = :category',
        ExpressionAttributeValues: {
          ':category': category,
        },
      }),
    )

    return (result.Items as Product[]) || []
  }

  // 価格範囲で商品を取得（GSI + ソートキー）
  async getProductsByPriceRange(
    category: string,
    minPrice: number,
    maxPrice: number,
  ): Promise<Product[]> {
    const result = await dynamoDB.send(
      new QueryCommand({
        TableName: this.tableName,
        IndexName: 'CategoryPriceIndex', // GSI名
        KeyConditionExpression: 'Category = :category AND Price BETWEEN :minPrice AND :maxPrice',
        ExpressionAttributeValues: {
          ':category': category,
          ':minPrice': minPrice,
          ':maxPrice': maxPrice,
        },
      }),
    )

    return (result.Items as Product[]) || []
  }
}
```

## 条件付き書き込みとトランザクション

### 条件付き書き込み

```typescript
// 在庫チェック付きの商品購入
async purchaseProduct(productId: string, quantity: number): Promise<boolean> {
  try {
    await dynamoDB.send(new UpdateCommand({
      TableName: 'Products',
      Key: { ProductId: productId },
      UpdateExpression: 'SET Stock = Stock - :quantity',
      ConditionExpression: 'Stock >= :quantity',
      ExpressionAttributeValues: {
        ':quantity': quantity,
      },
    }));
    return true;
  } catch (error) {
    if (error.name === 'ConditionalCheckFailedException') {
      throw new Error('Insufficient stock');
    }
    throw error;
  }
}
```

### トランザクション

```typescript
// 注文作成と在庫更新をトランザクションで実行
async createOrderWithInventoryUpdate(order: Order): Promise<Order> {
  const now = new Date().toISOString();
  const newOrder: Order = {
    ...order,
    CreatedAt: now,
    UpdatedAt: now,
  };

  // トランザクションアイテムを構築
  const transactionItems = [
    // 注文を作成
    {
      Put: {
        TableName: 'Orders',
        Item: newOrder,
      },
    },
  ];

  // 各商品の在庫を更新
  for (const item of order.Items) {
    transactionItems.push({
      Update: {
        TableName: 'Products',
        Key: { ProductId: item.ProductId },
        UpdateExpression: 'SET Stock = Stock - :quantity',
        ConditionExpression: 'Stock >= :quantity',
        ExpressionAttributeValues: {
          ':quantity': item.Quantity,
        },
      },
    });
  }

  await dynamoDB.send(new TransactWriteCommand({
    TransactItems: transactionItems,
  }));

  return newOrder;
}
```

## パフォーマンス最適化

### 1. バッチ操作

```typescript
// 複数のアイテムを一括取得
async getMultipleUsers(userIds: string[]): Promise<User[]> {
  const keys = userIds.map(id => ({ UserId: id }));

  const result = await dynamoDB.send(new BatchGetCommand({
    RequestItems: {
      'Users': {
        Keys: keys,
      },
    },
  }));

  return result.Responses?.['Users'] as User[] || [];
}

// 複数のアイテムを一括書き込み
async createMultipleUsers(users: Omit<User, 'CreatedAt' | 'UpdatedAt'>[]): Promise<void> {
  const now = new Date().toISOString();
  const items = users.map(user => ({
    ...user,
    CreatedAt: now,
    UpdatedAt: now,
  }));

  await dynamoDB.send(new BatchWriteCommand({
    RequestItems: {
      'Users': items.map(item => ({
        PutRequest: { Item: item },
      })),
    },
  }));
}
```

### 2. ページネーション

```typescript
// ページネーション付きのユーザー一覧取得
async getUsersPaginated(limit: number = 10, lastKey?: any): Promise<{
  users: User[];
  lastKey?: any;
}> {
  const result = await dynamoDB.send(new ScanCommand({
    TableName: 'Users',
    Limit: limit,
    ExclusiveStartKey: lastKey,
  }));

  return {
    users: result.Items as User[] || [],
    lastKey: result.LastEvaluatedKey,
  };
}
```

## 監視とログ

### CloudWatchメトリクス

```typescript
// カスタムメトリクスの送信
import { CloudWatchClient, PutMetricDataCommand } from '@aws-sdk/client-cloudwatch'

const cloudWatch = new CloudWatchClient({ region: 'ap-northeast-1' })

async function sendCustomMetric(metricName: string, value: number, unit: string = 'Count') {
  await cloudWatch.send(
    new PutMetricDataCommand({
      Namespace: 'DynamoDBApp',
      MetricData: [
        {
          MetricName: metricName,
          Value: value,
          Unit: unit,
          Timestamp: new Date(),
        },
      ],
    }),
  )
}

// 使用例
async function createUser(user: Omit<User, 'CreatedAt' | 'UpdatedAt'>) {
  const startTime = Date.now()

  try {
    const newUser = await userService.createUser(user)
    await sendCustomMetric('UserCreationSuccess', 1)
    return newUser
  } catch (error) {
    await sendCustomMetric('UserCreationError', 1)
    throw error
  } finally {
    const duration = Date.now() - startTime
    await sendCustomMetric('UserCreationDuration', duration, 'Milliseconds')
  }
}
```

## セキュリティのベストプラクティス

### 1. IAMロールの設定

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "dynamodb:GetItem",
        "dynamodb:PutItem",
        "dynamodb:UpdateItem",
        "dynamodb:DeleteItem",
        "dynamodb:Query",
        "dynamodb:Scan"
      ],
      "Resource": [
        "arn:aws:dynamodb:ap-northeast-1:123456789012:table/Users",
        "arn:aws:dynamodb:ap-northeast-1:123456789012:table/Orders"
      ]
    }
  ]
}
```

### 2. 暗号化

```typescript
// 機密データの暗号化
import crypto from 'crypto'

const algorithm = 'aes-256-gcm'
const secretKey = process.env.ENCRYPTION_KEY || ''

function encrypt(text: string): string {
  const iv = crypto.randomBytes(16)
  const cipher = crypto.createCipher(algorithm, secretKey)
  cipher.setAAD(Buffer.from('dynamodb-app', 'utf8'))

  let encrypted = cipher.update(text, 'utf8', 'hex')
  encrypted += cipher.final('hex')

  const authTag = cipher.getAuthTag()

  return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted
}

function decrypt(encryptedText: string): string {
  const [ivHex, authTagHex, encrypted] = encryptedText.split(':')
  const iv = Buffer.from(ivHex, 'hex')
  const authTag = Buffer.from(authTagHex, 'hex')

  const decipher = crypto.createDecipher(algorithm, secretKey)
  decipher.setAAD(Buffer.from('dynamodb-app', 'utf8'))
  decipher.setAuthTag(authTag)

  let decrypted = decipher.update(encrypted, 'hex', 'utf8')
  decrypted += decipher.final('utf8')

  return decrypted
}
```

## まとめ

Amazon DynamoDBは、スケーラブルで高性能なNoSQLデータベースサービスです。主なポイントは以下の通りです：

### 主要な特徴

- **サーバーレス**: インフラ管理不要で自動スケーリング
- **高可用性**: 99.999%のSLAとマルチリージョン対応
- **柔軟なスキーマ**: ドキュメント型データモデル
- **強力なクエリ機能**: GSI、LSI、条件付き書き込み

### 設計のポイント

- **アクセスパターンの分析**: クエリパターンに基づいたテーブル設計
- **適切なキー設計**: パーティションキーとソートキーの選択
- **GSIの活用**: 異なるアクセスパターンへの対応
- **条件付き書き込み**: データ整合性の保証

### 最適化の手法

- **バッチ操作**: 複数アイテムの効率的な処理
- **ページネーション**: 大量データの段階的取得
- **監視**: CloudWatchメトリクスでのパフォーマンス監視
- **セキュリティ**: IAMロールと暗号化の適切な設定

DynamoDBを活用することで、スケーラブルで高性能なアプリケーションを構築できます。従来のRDBMSとは異なる設計思想を理解し、適切なデータモデリングを行うことが重要です。

## 参考リンク

- [Amazon DynamoDB公式ドキュメント](https://aws.amazon.com/jp/dynamodb/)
- [DynamoDB開発者ガイド](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/)
- [AWS SDK for JavaScript](https://docs.aws.amazon.com/sdk-for-javascript/)
- [DynamoDBベストプラクティス](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/best-practices.html)
