---
date: 2025-10-22
title: Amazon DynamoDB完全入門：サーバーレスNoSQLデータベースでスケーラブルなアプリケーションを構築する
description: Amazon DynamoDBの基本概念から実装方法まで、初心者向けに詳しく解説。従来のRDBMSとの違い、パーティションキーとソートキーの設計、グローバルセカンダリインデックス、実践的なアプリケーション構築を通じて、DynamoDBを使った効率的なデータベース設計を学ぶ実践的なガイド。
tags:
    - dynamodb
    - aws
    - nosql
    - database
    - serverless
    - scalability
    - cloud
    - backend
prev:
    text: "tRPC完全入門：型安全なAPI開発でフルスタックTypeScriptを極める"
    link: "/posts/2025/10/17"
next: false
---

# Amazon DynamoDB完全入門：サーバーレスNoSQLデータベースでスケーラブルなアプリケーションを構築する

Amazon DynamoDBは、AWSが提供するフルマネージドのNoSQLデータベースサービスです。従来のリレーショナルデータベースとは異なる設計思想を持ち、スケーラビリティとパフォーマンスを重視したアーキテクチャを採用しています。この記事では、DynamoDBの基本概念から実装方法まで、初心者向けに詳しく解説します。

## DynamoDBとは

[Amazon DynamoDB](https://aws.amazon.com/jp/dynamodb/)は、AWSが提供するサーバーレスNoSQLデータベースサービスです。以下の特徴を持っています：

- **フルマネージド**: インフラストラクチャの管理が不要
- **サーバーレス**: 自動スケーリングとペイ・パー・ユース課金
- **高可用性**: 99.999%のSLAを提供
- **グローバル分散**: マルチリージョンでのデータレプリケーション

### 従来のRDBMSとの違い

| 項目 | RDBMS | DynamoDB |
|------|-------|----------|
| データモデル | リレーショナル（テーブル・行・列） | ドキュメント（アイテム・属性） |
| スキーマ | 固定スキーマ | スキーマレス |
| スケーリング | 垂直スケーリング | 水平スケーリング |
| クエリ | SQL | パーティションキー・ソートキー |
| トランザクション | ACID | 条件付き書き込み・トランザクション |

## DynamoDBの基本概念

### 1. テーブルとアイテム

```json
// DynamoDBのアイテム例
{
  "UserId": "user123",
  "OrderId": "order456",
  "OrderDate": "2025-10-22",
  "TotalAmount": 150.00,
  "Items": [
    {
      "ProductId": "prod789",
      "Quantity": 2,
      "Price": 75.00
    }
  ],
  "ShippingAddress": {
    "Street": "123 Main St",
    "City": "Tokyo",
    "PostalCode": "100-0001"
  }
}
```

### 2. パーティションキーとソートキー

DynamoDBでは、データの一意性とアクセスパターンを定義するためにキーを使用します：

- **パーティションキー（Primary Key）**: データの物理的な配置を決定
- **ソートキー（Sort Key）**: パーティション内での順序を決定

```typescript
// テーブル設計例
interface UserTable {
  // パーティションキーのみ
  UserId: string; // PK
  Name: string;
  Email: string;
}

interface OrderTable {
  // パーティションキー + ソートキー
  UserId: string;    // PK
  OrderId: string;   // SK
  OrderDate: string;
  TotalAmount: number;
}
```

## 実践的なアプリケーション構築

### プロジェクトのセットアップ

```bash
# Node.jsプロジェクトを作成
mkdir dynamodb-app
cd dynamodb-app
npm init -y

# 必要なパッケージをインストール
npm install aws-sdk @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb
npm install express cors dotenv
npm install -D typescript @types/node @types/express ts-node nodemon

# TypeScript設定
npx tsc --init
```

### AWS SDKの設定

```typescript
// src/config/aws.ts
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient } from '@aws-sdk/lib-dynamodb';

// DynamoDBクライアントの設定
const client = new DynamoDBClient({
  region: process.env.AWS_REGION || 'ap-northeast-1',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || '',
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || '',
  },
});

export const dynamoDB = DynamoDBDocumentClient.from(client);
```

### 基本的なCRUD操作

```typescript
// src/services/userService.ts
import { dynamoDB } from '../config/aws';
import { PutCommand, GetCommand, UpdateCommand, DeleteCommand, ScanCommand } from '@aws-sdk/lib-dynamodb';

export interface User {
  UserId: string;
  Name: string;
  Email: string;
  CreatedAt: string;
  UpdatedAt: string;
}

export class UserService {
  private tableName = 'Users';

  // ユーザーを作成
  async createUser(user: Omit<User, 'CreatedAt' | 'UpdatedAt'>): Promise<User> {
    const now = new Date().toISOString();
    const newUser: User = {
      ...user,
      CreatedAt: now,
      UpdatedAt: now,
    };

    await dynamoDB.send(new PutCommand({
      TableName: this.tableName,
      Item: newUser,
    }));

    return newUser;
  }

  // ユーザーを取得
  async getUser(userId: string): Promise<User | null> {
    const result = await dynamoDB.send(new GetCommand({
      TableName: this.tableName,
      Key: { UserId: userId },
    }));

    return result.Item as User || null;
  }

  // ユーザーを更新
  async updateUser(userId: string, updates: Partial<Omit<User, 'UserId' | 'CreatedAt'>>): Promise<User | null> {
    const updateExpression: string[] = [];
    const expressionAttributeNames: Record<string, string> = {};
    const expressionAttributeValues: Record<string, any> = {};

    // 更新するフィールドを動的に構築
    Object.keys(updates).forEach((key, index) => {
      if (key !== 'UserId' && key !== 'CreatedAt') {
        updateExpression.push(`#${key} = :val${index}`);
        expressionAttributeNames[`#${key}`] = key;
        expressionAttributeValues[`:val${index}`] = updates[key as keyof typeof updates];
      }
    });

    // UpdatedAtを自動更新
    updateExpression.push('#UpdatedAt = :updatedAt');
    expressionAttributeNames['#UpdatedAt'] = 'UpdatedAt';
    expressionAttributeValues[':updatedAt'] = new Date().toISOString();

    const result = await dynamoDB.send(new UpdateCommand({
      TableName: this.tableName,
      Key: { UserId: userId },
      UpdateExpression: `SET ${updateExpression.join(', ')}`,
      ExpressionAttributeNames: expressionAttributeNames,
      ExpressionAttributeValues: expressionAttributeValues,
      ReturnValues: 'ALL_NEW',
    }));

    return result.Attributes as User || null;
  }

  // ユーザーを削除
  async deleteUser(userId: string): Promise<boolean> {
    await dynamoDB.send(new DeleteCommand({
      TableName: this.tableName,
      Key: { UserId: userId },
    }));

    return true;
  }

  // 全ユーザーを取得（スキャン）
  async getAllUsers(): Promise<User[]> {
    const result = await dynamoDB.send(new ScanCommand({
      TableName: this.tableName,
    }));

    return result.Items as User[] || [];
  }
}
```

### 注文管理システムの実装

```typescript
// src/services/orderService.ts
import { dynamoDB } from '../config/aws';
import { PutCommand, GetCommand, QueryCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';

export interface Order {
  UserId: string;        // パーティションキー
  OrderId: string;       // ソートキー
  OrderDate: string;
  TotalAmount: number;
  Status: 'pending' | 'confirmed' | 'shipped' | 'delivered' | 'cancelled';
  Items: OrderItem[];
  ShippingAddress: Address;
  CreatedAt: string;
  UpdatedAt: string;
}

export interface OrderItem {
  ProductId: string;
  ProductName: string;
  Quantity: number;
  Price: number;
}

export interface Address {
  Street: string;
  City: string;
  PostalCode: string;
  Country: string;
}

export class OrderService {
  private tableName = 'Orders';

  // 注文を作成
  async createOrder(order: Omit<Order, 'CreatedAt' | 'UpdatedAt'>): Promise<Order> {
    const now = new Date().toISOString();
    const newOrder: Order = {
      ...order,
      CreatedAt: now,
      UpdatedAt: now,
    };

    await dynamoDB.send(new PutCommand({
      TableName: this.tableName,
      Item: newOrder,
    }));

    return newOrder;
  }

  // 注文を取得
  async getOrder(userId: string, orderId: string): Promise<Order | null> {
    const result = await dynamoDB.send(new GetCommand({
      TableName: this.tableName,
      Key: {
        UserId: userId,
        OrderId: orderId,
      },
    }));

    return result.Item as Order || null;
  }

  // ユーザーの全注文を取得
  async getUserOrders(userId: string): Promise<Order[]> {
    const result = await dynamoDB.send(new QueryCommand({
      TableName: this.tableName,
      KeyConditionExpression: 'UserId = :userId',
      ExpressionAttributeValues: {
        ':userId': userId,
      },
      ScanIndexForward: false, // 新しい順でソート
    }));

    return result.Items as Order[] || [];
  }

  // 注文ステータスを更新
  async updateOrderStatus(userId: string, orderId: string, status: Order['Status']): Promise<Order | null> {
    const result = await dynamoDB.send(new UpdateCommand({
      TableName: this.tableName,
      Key: {
        UserId: userId,
        OrderId: orderId,
      },
      UpdateExpression: 'SET #Status = :status, #UpdatedAt = :updatedAt',
      ExpressionAttributeNames: {
        '#Status': 'Status',
        '#UpdatedAt': 'UpdatedAt',
      },
      ExpressionAttributeValues: {
        ':status': status,
        ':updatedAt': new Date().toISOString(),
      },
      ReturnValues: 'ALL_NEW',
    }));

    return result.Attributes as Order || null;
  }
}
```

### Express.js APIサーバーの実装

```typescript
// src/app.ts
import express from 'express';
import cors from 'cors';
import { UserService } from './services/userService';
import { OrderService } from './services/orderService';

const app = express();
const port = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());

const userService = new UserService();
const orderService = new OrderService();

// ユーザー関連のエンドポイント
app.post('/api/users', async (req, res) => {
  try {
    const user = await userService.createUser(req.body);
    res.status(201).json(user);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create user' });
  }
});

app.get('/api/users/:userId', async (req, res) => {
  try {
    const user = await userService.getUser(req.params.userId);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: 'Failed to get user' });
  }
});

app.put('/api/users/:userId', async (req, res) => {
  try {
    const user = await userService.updateUser(req.params.userId, req.body);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: 'Failed to update user' });
  }
});

app.delete('/api/users/:userId', async (req, res) => {
  try {
    await userService.deleteUser(req.params.userId);
    res.status(204).send();
  } catch (error) {
    res.status(500).json({ error: 'Failed to delete user' });
  }
});

// 注文関連のエンドポイント
app.post('/api/orders', async (req, res) => {
  try {
    const order = await orderService.createOrder(req.body);
    res.status(201).json(order);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create order' });
  }
});

app.get('/api/users/:userId/orders', async (req, res) => {
  try {
    const orders = await orderService.getUserOrders(req.params.userId);
    res.json(orders);
  } catch (error) {
    res.status(500).json({ error: 'Failed to get orders' });
  }
});

app.get('/api/users/:userId/orders/:orderId', async (req, res) => {
  try {
    const order = await orderService.getOrder(req.params.userId, req.params.orderId);
    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }
    res.json(order);
  } catch (error) {
    res.status(500).json({ error: 'Failed to get order' });
  }
});

app.patch('/api/users/:userId/orders/:orderId/status', async (req, res) => {
  try {
    const { status } = req.body;
    const order = await orderService.updateOrderStatus(req.params.userId, req.params.orderId, status);
    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }
    res.json(order);
  } catch (error) {
    res.status(500).json({ error: 'Failed to update order status' });
  }
});

app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
});
```

## グローバルセカンダリインデックス（GSI）

GSIを使用することで、異なるパーティションキーでのクエリが可能になります：

```typescript
// src/services/productService.ts
export interface Product {
  ProductId: string;     // パーティションキー
  Category: string;      // GSIのパーティションキー
  Name: string;
  Price: number;
  Stock: number;
  CreatedAt: string;
}

export class ProductService {
  private tableName = 'Products';

  // カテゴリ別で商品を取得（GSIを使用）
  async getProductsByCategory(category: string): Promise<Product[]> {
    const result = await dynamoDB.send(new QueryCommand({
      TableName: this.tableName,
      IndexName: 'CategoryIndex', // GSI名
      KeyConditionExpression: 'Category = :category',
      ExpressionAttributeValues: {
        ':category': category,
      },
    }));

    return result.Items as Product[] || [];
  }

  // 価格範囲で商品を取得（GSI + ソートキー）
  async getProductsByPriceRange(category: string, minPrice: number, maxPrice: number): Promise<Product[]> {
    const result = await dynamoDB.send(new QueryCommand({
      TableName: this.tableName,
      IndexName: 'CategoryPriceIndex', // GSI名
      KeyConditionExpression: 'Category = :category AND Price BETWEEN :minPrice AND :maxPrice',
      ExpressionAttributeValues: {
        ':category': category,
        ':minPrice': minPrice,
        ':maxPrice': maxPrice,
      },
    }));

    return result.Items as Product[] || [];
  }
}
```

## 条件付き書き込みとトランザクション

### 条件付き書き込み

```typescript
// 在庫チェック付きの商品購入
async purchaseProduct(productId: string, quantity: number): Promise<boolean> {
  try {
    await dynamoDB.send(new UpdateCommand({
      TableName: 'Products',
      Key: { ProductId: productId },
      UpdateExpression: 'SET Stock = Stock - :quantity',
      ConditionExpression: 'Stock >= :quantity',
      ExpressionAttributeValues: {
        ':quantity': quantity,
      },
    }));
    return true;
  } catch (error) {
    if (error.name === 'ConditionalCheckFailedException') {
      throw new Error('Insufficient stock');
    }
    throw error;
  }
}
```

### トランザクション

```typescript
// 注文作成と在庫更新をトランザクションで実行
async createOrderWithInventoryUpdate(order: Order): Promise<Order> {
  const now = new Date().toISOString();
  const newOrder: Order = {
    ...order,
    CreatedAt: now,
    UpdatedAt: now,
  };

  // トランザクションアイテムを構築
  const transactionItems = [
    // 注文を作成
    {
      Put: {
        TableName: 'Orders',
        Item: newOrder,
      },
    },
  ];

  // 各商品の在庫を更新
  for (const item of order.Items) {
    transactionItems.push({
      Update: {
        TableName: 'Products',
        Key: { ProductId: item.ProductId },
        UpdateExpression: 'SET Stock = Stock - :quantity',
        ConditionExpression: 'Stock >= :quantity',
        ExpressionAttributeValues: {
          ':quantity': item.Quantity,
        },
      },
    });
  }

  await dynamoDB.send(new TransactWriteCommand({
    TransactItems: transactionItems,
  }));

  return newOrder;
}
```

## パフォーマンス最適化

### 1. バッチ操作

```typescript
// 複数のアイテムを一括取得
async getMultipleUsers(userIds: string[]): Promise<User[]> {
  const keys = userIds.map(id => ({ UserId: id }));
  
  const result = await dynamoDB.send(new BatchGetCommand({
    RequestItems: {
      'Users': {
        Keys: keys,
      },
    },
  }));

  return result.Responses?.['Users'] as User[] || [];
}

// 複数のアイテムを一括書き込み
async createMultipleUsers(users: Omit<User, 'CreatedAt' | 'UpdatedAt'>[]): Promise<void> {
  const now = new Date().toISOString();
  const items = users.map(user => ({
    ...user,
    CreatedAt: now,
    UpdatedAt: now,
  }));

  await dynamoDB.send(new BatchWriteCommand({
    RequestItems: {
      'Users': items.map(item => ({
        PutRequest: { Item: item },
      })),
    },
  }));
}
```

### 2. ページネーション

```typescript
// ページネーション付きのユーザー一覧取得
async getUsersPaginated(limit: number = 10, lastKey?: any): Promise<{
  users: User[];
  lastKey?: any;
}> {
  const result = await dynamoDB.send(new ScanCommand({
    TableName: 'Users',
    Limit: limit,
    ExclusiveStartKey: lastKey,
  }));

  return {
    users: result.Items as User[] || [],
    lastKey: result.LastEvaluatedKey,
  };
}
```

## 監視とログ

### CloudWatchメトリクス

```typescript
// カスタムメトリクスの送信
import { CloudWatchClient, PutMetricDataCommand } from '@aws-sdk/client-cloudwatch';

const cloudWatch = new CloudWatchClient({ region: 'ap-northeast-1' });

async function sendCustomMetric(metricName: string, value: number, unit: string = 'Count') {
  await cloudWatch.send(new PutMetricDataCommand({
    Namespace: 'DynamoDBApp',
    MetricData: [{
      MetricName: metricName,
      Value: value,
      Unit: unit,
      Timestamp: new Date(),
    }],
  }));
}

// 使用例
async function createUser(user: Omit<User, 'CreatedAt' | 'UpdatedAt'>) {
  const startTime = Date.now();
  
  try {
    const newUser = await userService.createUser(user);
    await sendCustomMetric('UserCreationSuccess', 1);
    return newUser;
  } catch (error) {
    await sendCustomMetric('UserCreationError', 1);
    throw error;
  } finally {
    const duration = Date.now() - startTime;
    await sendCustomMetric('UserCreationDuration', duration, 'Milliseconds');
  }
}
```

## セキュリティのベストプラクティス

### 1. IAMロールの設定

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "dynamodb:GetItem",
        "dynamodb:PutItem",
        "dynamodb:UpdateItem",
        "dynamodb:DeleteItem",
        "dynamodb:Query",
        "dynamodb:Scan"
      ],
      "Resource": [
        "arn:aws:dynamodb:ap-northeast-1:123456789012:table/Users",
        "arn:aws:dynamodb:ap-northeast-1:123456789012:table/Orders"
      ]
    }
  ]
}
```

### 2. 暗号化

```typescript
// 機密データの暗号化
import crypto from 'crypto';

const algorithm = 'aes-256-gcm';
const secretKey = process.env.ENCRYPTION_KEY || '';

function encrypt(text: string): string {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipher(algorithm, secretKey);
  cipher.setAAD(Buffer.from('dynamodb-app', 'utf8'));
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted;
}

function decrypt(encryptedText: string): string {
  const [ivHex, authTagHex, encrypted] = encryptedText.split(':');
  const iv = Buffer.from(ivHex, 'hex');
  const authTag = Buffer.from(authTagHex, 'hex');
  
  const decipher = crypto.createDecipher(algorithm, secretKey);
  decipher.setAAD(Buffer.from('dynamodb-app', 'utf8'));
  decipher.setAuthTag(authTag);
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}
```

## まとめ

Amazon DynamoDBは、スケーラブルで高性能なNoSQLデータベースサービスです。主なポイントは以下の通りです：

### 主要な特徴
- **サーバーレス**: インフラ管理不要で自動スケーリング
- **高可用性**: 99.999%のSLAとマルチリージョン対応
- **柔軟なスキーマ**: ドキュメント型データモデル
- **強力なクエリ機能**: GSI、LSI、条件付き書き込み

### 設計のポイント
- **アクセスパターンの分析**: クエリパターンに基づいたテーブル設計
- **適切なキー設計**: パーティションキーとソートキーの選択
- **GSIの活用**: 異なるアクセスパターンへの対応
- **条件付き書き込み**: データ整合性の保証

### 最適化の手法
- **バッチ操作**: 複数アイテムの効率的な処理
- **ページネーション**: 大量データの段階的取得
- **監視**: CloudWatchメトリクスでのパフォーマンス監視
- **セキュリティ**: IAMロールと暗号化の適切な設定

DynamoDBを活用することで、スケーラブルで高性能なアプリケーションを構築できます。従来のRDBMSとは異なる設計思想を理解し、適切なデータモデリングを行うことが重要です。

## 参考リンク

- [Amazon DynamoDB公式ドキュメント](https://aws.amazon.com/jp/dynamodb/)
- [DynamoDB開発者ガイド](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/)
- [AWS SDK for JavaScript](https://docs.aws.amazon.com/sdk-for-javascript/)
- [DynamoDBベストプラクティス](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/best-practices.html)
