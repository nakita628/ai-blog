---
date: 2025-10-24
title: p-queue完全入門：Promiseキューの並行制御で効率的な非同期処理を実現する
description: p-queueライブラリを使ったPromiseキューの並行制御について、初心者向けに詳しく解説。基本的な使い方から高度な機能まで、実践的なコード例を通じて、API呼び出しの制限、CPU集約的なタスクの管理、レート制限の実装方法を学ぶ実践的なガイド。
tags:
  - p-queue
  - promise
  - concurrency
  - rate-limiting
  - async
  - queue
  - javascript
  - typescript
  - performance
prev:
  text: 'NestJS/Swagger完全入門：OpenAPI仕様でAPIドキュメントを自動生成する'
  link: '/posts/2025/10/23'
next: false
---

# p-queue完全入門：Promiseキューの並行制御で効率的な非同期処理を実現する

[p-queue](https://github.com/sindresorhus/p-queue)は、Promiseベースの非同期処理を効率的に管理するためのライブラリです。並行制御、レート制限、優先度付きキューなどの機能を提供し、API呼び出しの制限やCPU集約的なタスクの管理に最適です。この記事では、p-queueの基本的な使い方から高度な機能まで、実践的なコード例を通じて詳しく解説します。

## p-queueとは

p-queueは、非同期処理の並行数を制御し、効率的なリソース管理を実現するPromiseキューのライブラリです。主な用途は以下の通りです：

- **API呼び出しの制限**: 外部APIのレート制限に対応
- **リソース管理**: CPUやメモリの使用量を制御
- **バッチ処理**: 大量のデータを効率的に処理
- **優先度制御**: 重要なタスクを優先実行

### 主な特徴

- **並行制御**: 同時実行数を制限
- **レート制限**: 時間あたりの実行回数を制限
- **優先度制御**: タスクの優先度を設定
- **タイムアウト**: タスクの実行時間制限
- **イベント監視**: キューの状態を監視

## 基本的なセットアップ

### インストール

```bash
# p-queueをインストール
npm install p-queue

# TypeScriptを使用する場合
npm install -D @types/node
```

### 基本的な使い方

```typescript
import PQueue from 'p-queue'

// 基本的なキューの作成
const queue = new PQueue({ concurrency: 1 })

// タスクを追加
const task = async () => {
  console.log('タスクを実行中...')
  await new Promise((resolve) => setTimeout(resolve, 1000))
  return '完了'
}

// タスクを実行
queue.add(task).then((result) => {
  console.log('結果:', result)
})
```

## 並行制御の実装

### 基本的な並行制御

```typescript
import PQueue from 'p-queue'

// 同時実行数を2に制限
const queue = new PQueue({ concurrency: 2 })

// 複数のタスクを追加
const tasks = [
  () => fetchData(1),
  () => fetchData(2),
  () => fetchData(3),
  () => fetchData(4),
  () => fetchData(5),
]

// タスクを並行実行
tasks.forEach((task, index) => {
  queue.add(task).then((result) => {
    console.log(`タスク${index + 1}完了:`, result)
  })
})
```

### 動的な並行制御

```typescript
import PQueue from 'p-queue'

class DynamicQueue {
  private queue: PQueue
  private maxConcurrency: number

  constructor(maxConcurrency: number = 5) {
    this.maxConcurrency = maxConcurrency
    this.queue = new PQueue({ concurrency: maxConcurrency })
  }

  // 並行数を動的に調整
  adjustConcurrency(newConcurrency: number) {
    this.queue.concurrency = newConcurrency
    console.log(`並行数を${newConcurrency}に調整`)
  }

  // タスクを追加
  async addTask<T>(task: () => Promise<T>): Promise<T> {
    return this.queue.add(task)
  }

  // キューの状態を取得
  getStatus() {
    return {
      pending: this.queue.pending,
      size: this.queue.size,
      isPaused: this.queue.isPaused,
    }
  }
}

// 使用例
const dynamicQueue = new DynamicQueue(3)

// 並行数を動的に調整
setTimeout(() => {
  dynamicQueue.adjustConcurrency(1) // 並行数を1に減らす
}, 5000)

setTimeout(() => {
  dynamicQueue.adjustConcurrency(5) // 並行数を5に増やす
}, 10000)
```

## レート制限の実装

### 基本的なレート制限

```typescript
import PQueue from 'p-queue'

// レート制限付きキュー
const rateLimitedQueue = new PQueue({
  concurrency: 1, // 同時実行数
  interval: 1000, // 1秒間隔
  intervalCap: 5, // 1秒間に5回まで
})

// API呼び出しの例
const apiCall = async (endpoint: string) => {
  console.log(`API呼び出し: ${endpoint}`)
  const response = await fetch(endpoint)
  return response.json()
}

// レート制限付きでAPI呼び出し
const endpoints = [
  'https://api.example.com/users/1',
  'https://api.example.com/users/2',
  'https://api.example.com/users/3',
  'https://api.example.com/users/4',
  'https://api.example.com/users/5',
  'https://api.example.com/users/6',
  'https://api.example.com/users/7',
  'https://api.example.com/users/8',
]

endpoints.forEach((endpoint, index) => {
  rateLimitedQueue
    .add(() => apiCall(endpoint))
    .then((result) => {
      console.log(`API呼び出し${index + 1}完了:`, result)
    })
})
```

### 高度なレート制限

```typescript
import PQueue from 'p-queue'

class RateLimitedAPI {
  private queue: PQueue
  private requestCount: number = 0
  private resetTime: number = 0

  constructor(requestsPerMinute: number = 60) {
    this.queue = new PQueue({
      concurrency: 1,
      interval: 60000, // 1分間隔
      intervalCap: requestsPerMinute,
    })
  }

  // API呼び出し
  async callAPI<T>(endpoint: string, options?: RequestInit): Promise<T> {
    return this.queue.add(async () => {
      const now = Date.now()

      // レート制限のチェック
      if (now > this.resetTime) {
        this.requestCount = 0
        this.resetTime = now + 60000 // 1分後にリセット
      }

      if (this.requestCount >= 60) {
        const waitTime = this.resetTime - now
        console.log(`レート制限に達しました。${waitTime}ms待機します。`)
        await new Promise((resolve) => setTimeout(resolve, waitTime))
      }

      this.requestCount++
      console.log(`API呼び出し: ${endpoint} (${this.requestCount}/60)`)

      const response = await fetch(endpoint, options)
      if (!response.ok) {
        throw new Error(`API呼び出し失敗: ${response.status}`)
      }

      return response.json()
    })
  }
}

// 使用例
const api = new RateLimitedAPI(60) // 1分間に60回まで

// 複数のAPI呼び出し
const apiCalls = [
  () => api.callAPI('https://api.example.com/users/1'),
  () => api.callAPI('https://api.example.com/users/2'),
  () => api.callAPI('https://api.example.com/users/3'),
]

apiCalls.forEach((call, index) => {
  call()
    .then((result) => {
      console.log(`API呼び出し${index + 1}完了:`, result)
    })
    .catch((error) => {
      console.error(`API呼び出し${index + 1}失敗:`, error)
    })
})
```

## 優先度制御の実装

### 基本的な優先度制御

```typescript
import PQueue from 'p-queue'

// 優先度付きキュー
const priorityQueue = new PQueue({ concurrency: 2 })

// 優先度付きタスク
const addTaskWithPriority = async (task: () => Promise<any>, priority: number = 0) => {
  return priorityQueue.add(task, { priority })
}

// 高優先度タスク
const highPriorityTask = async () => {
  console.log('高優先度タスク実行中...')
  await new Promise((resolve) => setTimeout(resolve, 1000))
  return '高優先度タスク完了'
}

// 低優先度タスク
const lowPriorityTask = async () => {
  console.log('低優先度タスク実行中...')
  await new Promise((resolve) => setTimeout(resolve, 1000))
  return '低優先度タスク完了'
}

// タスクを優先度付きで追加
addTaskWithPriority(lowPriorityTask, 1) // 低優先度
addTaskWithPriority(highPriorityTask, 10) // 高優先度
addTaskWithPriority(lowPriorityTask, 1) // 低優先度
addTaskWithPriority(highPriorityTask, 10) // 高優先度
```

### 高度な優先度制御

```typescript
import PQueue from 'p-queue'

interface Task {
  id: string
  priority: number
  task: () => Promise<any>
  createdAt: number
}

class PriorityTaskQueue {
  private queue: PQueue
  private tasks: Map<string, Task> = new Map()

  constructor(concurrency: number = 3) {
    this.queue = new PQueue({ concurrency })
  }

  // タスクを追加
  async addTask<T>(id: string, task: () => Promise<T>, priority: number = 0): Promise<T> {
    const taskObj: Task = {
      id,
      priority,
      task,
      createdAt: Date.now(),
    }

    this.tasks.set(id, taskObj)

    return this.queue.add(taskObj.task, {
      priority: priority,
      id: id,
    })
  }

  // タスクをキャンセル
  cancelTask(id: string): boolean {
    if (this.tasks.has(id)) {
      this.tasks.delete(id)
      return true
    }
    return false
  }

  // キューの状態を取得
  getStatus() {
    return {
      pending: this.queue.pending,
      size: this.queue.size,
      tasks: Array.from(this.tasks.values()),
    }
  }
}

// 使用例
const priorityQueue = new PriorityTaskQueue(2)

// タスクを追加
priorityQueue.addTask(
  'task1',
  async () => {
    console.log('タスク1実行中...')
    await new Promise((resolve) => setTimeout(resolve, 2000))
    return 'タスク1完了'
  },
  1,
)

priorityQueue.addTask(
  'task2',
  async () => {
    console.log('タスク2実行中...')
    await new Promise((resolve) => setTimeout(resolve, 1000))
    return 'タスク2完了'
  },
  10,
) // 高優先度

priorityQueue.addTask(
  'task3',
  async () => {
    console.log('タスク3実行中...')
    await new Promise((resolve) => setTimeout(resolve, 1500))
    return 'タスク3完了'
  },
  5,
)
```

## タイムアウトとエラーハンドリング

### 基本的なタイムアウト

```typescript
import PQueue from 'p-queue'

// タイムアウト付きキュー
const timeoutQueue = new PQueue({
  concurrency: 2,
  timeout: 5000, // 5秒でタイムアウト
})

// タイムアウト付きタスク
const addTaskWithTimeout = async (task: () => Promise<any>, timeout: number = 5000) => {
  return timeoutQueue.add(task, { timeout })
}

// 長時間実行されるタスク
const longRunningTask = async () => {
  console.log('長時間実行タスク開始...')
  await new Promise((resolve) => setTimeout(resolve, 3000))
  return '長時間実行タスク完了'
}

// タイムアウトするタスク
const timeoutTask = async () => {
  console.log('タイムアウトタスク開始...')
  await new Promise((resolve) => setTimeout(resolve, 10000))
  return 'タイムアウトタスク完了'
}

// タスクを実行
addTaskWithTimeout(longRunningTask)
  .then((result) => {
    console.log('結果:', result)
  })
  .catch((error) => {
    console.error('エラー:', error.message)
  })

addTaskWithTimeout(timeoutTask)
  .then((result) => {
    console.log('結果:', result)
  })
  .catch((error) => {
    console.error('エラー:', error.message)
  })
```

### 高度なエラーハンドリング

```typescript
import PQueue from 'p-queue'

class RobustQueue {
  private queue: PQueue
  private retryCount: number = 0
  private maxRetries: number = 3

  constructor(concurrency: number = 2) {
    this.queue = new PQueue({ concurrency })

    // エラーイベントの監視
    this.queue.on('error', (error) => {
      console.error('キューエラー:', error)
    })
  }

  // リトライ付きタスク
  async addTaskWithRetry<T>(task: () => Promise<T>, maxRetries: number = 3): Promise<T> {
    let lastError: Error

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await this.queue.add(task, {
          timeout: 10000,
          id: `task-${Date.now()}-${attempt}`,
        })
      } catch (error) {
        lastError = error as Error
        console.warn(`タスク実行失敗 (試行${attempt + 1}/${maxRetries + 1}):`, error.message)

        if (attempt < maxRetries) {
          const delay = Math.pow(2, attempt) * 1000 // 指数バックオフ
          console.log(`${delay}ms後にリトライします...`)
          await new Promise((resolve) => setTimeout(resolve, delay))
        }
      }
    }

    throw new Error(`タスクが${maxRetries + 1}回の試行後に失敗: ${lastError.message}`)
  }

  // バッチ処理
  async processBatch<T>(
    items: T[],
    processor: (item: T) => Promise<any>,
    batchSize: number = 5,
  ): Promise<any[]> {
    const results: any[] = []

    for (let i = 0; i < items.length; i += batchSize) {
      const batch = items.slice(i, i + batchSize)
      console.log(`バッチ${Math.floor(i / batchSize) + 1}を処理中...`)

      const batchResults = await Promise.allSettled(
        batch.map((item) => this.addTaskWithRetry(() => processor(item))),
      )

      results.push(
        ...batchResults.map((result) => (result.status === 'fulfilled' ? result.value : null)),
      )
    }

    return results
  }
}

// 使用例
const robustQueue = new RobustQueue(3)

// 失敗する可能性のあるタスク
const unreliableTask = async (id: number) => {
  console.log(`タスク${id}実行中...`)

  // ランダムに失敗
  if (Math.random() < 0.3) {
    throw new Error(`タスク${id}がランダムに失敗`)
  }

  await new Promise((resolve) => setTimeout(resolve, 1000))
  return `タスク${id}完了`
}

// バッチ処理
const items = Array.from({ length: 10 }, (_, i) => i + 1)
robustQueue
  .processBatch(items, unreliableTask, 3)
  .then((results) => {
    console.log('バッチ処理完了:', results)
  })
  .catch((error) => {
    console.error('バッチ処理エラー:', error)
  })
```

## 実践的なアプリケーション例

### API呼び出しの制限

```typescript
import PQueue from 'p-queue'

class APIClient {
  private queue: PQueue
  private baseURL: string

  constructor(baseURL: string, requestsPerSecond: number = 10) {
    this.baseURL = baseURL
    this.queue = new PQueue({
      concurrency: 1,
      interval: 1000,
      intervalCap: requestsPerSecond,
    })
  }

  // GETリクエスト
  async get<T>(endpoint: string): Promise<T> {
    return this.queue.add(async () => {
      const response = await fetch(`${this.baseURL}${endpoint}`)
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      return response.json()
    })
  }

  // POSTリクエスト
  async post<T>(endpoint: string, data: any): Promise<T> {
    return this.queue.add(async () => {
      const response = await fetch(`${this.baseURL}${endpoint}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      })
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      return response.json()
    })
  }
}

// 使用例
const apiClient = new APIClient('https://api.example.com', 5) // 1秒間に5回まで

// 複数のAPI呼び出し
const apiCalls = [
  () => apiClient.get('/users/1'),
  () => apiClient.get('/users/2'),
  () => apiClient.get('/users/3'),
  () => apiClient.get('/users/4'),
  () => apiClient.get('/users/5'),
]

apiCalls.forEach((call, index) => {
  call()
    .then((result) => {
      console.log(`API呼び出し${index + 1}完了:`, result)
    })
    .catch((error) => {
      console.error(`API呼び出し${index + 1}失敗:`, error)
    })
})
```

### ファイル処理の制限

```typescript
import PQueue from 'p-queue'
import fs from 'fs/promises'
import path from 'path'

class FileProcessor {
  private queue: PQueue
  private processedFiles: Set<string> = new Set()

  constructor(concurrency: number = 3) {
    this.queue = new PQueue({ concurrency })
  }

  // ファイルを処理
  async processFile(filePath: string): Promise<any> {
    if (this.processedFiles.has(filePath)) {
      console.log(`ファイル${filePath}は既に処理済みです`)
      return null
    }

    return this.queue.add(async () => {
      console.log(`ファイル処理開始: ${filePath}`)

      try {
        const content = await fs.readFile(filePath, 'utf-8')
        const stats = await fs.stat(filePath)

        // ファイルの内容を処理（例：JSON解析）
        const data = JSON.parse(content)

        this.processedFiles.add(filePath)
        console.log(`ファイル処理完了: ${filePath}`)

        return {
          path: filePath,
          size: stats.size,
          data: data,
        }
      } catch (error) {
        console.error(`ファイル処理エラー: ${filePath}`, error)
        throw error
      }
    })
  }

  // ディレクトリ内の全ファイルを処理
  async processDirectory(dirPath: string): Promise<any[]> {
    const files = await fs.readdir(dirPath)
    const jsonFiles = files.filter((file) => file.endsWith('.json'))

    console.log(`${jsonFiles.length}個のJSONファイルを処理します`)

    const results = await Promise.allSettled(
      jsonFiles.map((file) => this.processFile(path.join(dirPath, file))),
    )

    return results
      .filter((result) => result.status === 'fulfilled')
      .map((result) => (result as PromiseFulfilledResult<any>).value)
  }
}

// 使用例
const fileProcessor = new FileProcessor(2) // 同時に2ファイルまで処理

// 単一ファイルの処理
fileProcessor
  .processFile('./data/sample.json')
  .then((result) => {
    console.log('ファイル処理結果:', result)
  })
  .catch((error) => {
    console.error('ファイル処理エラー:', error)
  })

// ディレクトリ内の全ファイルを処理
fileProcessor
  .processDirectory('./data')
  .then((results) => {
    console.log('全ファイル処理完了:', results)
  })
  .catch((error) => {
    console.error('ディレクトリ処理エラー:', error)
  })
```

## 監視とデバッグ

### キューの状態監視

```typescript
import PQueue from 'p-queue'

class MonitoredQueue {
  private queue: PQueue
  private metrics: {
    completed: number
    failed: number
    totalTime: number
  } = {
    completed: 0,
    failed: 0,
    totalTime: 0,
  }

  constructor(concurrency: number = 3) {
    this.queue = new PQueue({ concurrency })

    // イベントリスナーの設定
    this.queue.on('completed', (result) => {
      this.metrics.completed++
      console.log('タスク完了:', result)
    })

    this.queue.on('error', (error) => {
      this.metrics.failed++
      console.error('タスクエラー:', error)
    })
  }

  // タスクを追加
  async addTask<T>(task: () => Promise<T>): Promise<T> {
    const startTime = Date.now()

    try {
      const result = await this.queue.add(task)
      this.metrics.totalTime += Date.now() - startTime
      return result
    } catch (error) {
      this.metrics.totalTime += Date.now() - startTime
      throw error
    }
  }

  // メトリクスを取得
  getMetrics() {
    return {
      ...this.metrics,
      pending: this.queue.pending,
      size: this.queue.size,
      isPaused: this.queue.isPaused,
      averageTime: this.metrics.completed > 0 ? this.metrics.totalTime / this.metrics.completed : 0,
    }
  }

  // キューの状態をログ出力
  logStatus() {
    const metrics = this.getMetrics()
    console.log('キュー状態:', {
      pending: metrics.pending,
      size: metrics.size,
      completed: metrics.completed,
      failed: metrics.failed,
      averageTime: Math.round(metrics.averageTime),
    })
  }
}

// 使用例
const monitoredQueue = new MonitoredQueue(2)

// 定期的に状態をログ出力
setInterval(() => {
  monitoredQueue.logStatus()
}, 5000)

// タスクを追加
for (let i = 0; i < 10; i++) {
  monitoredQueue.addTask(async () => {
    console.log(`タスク${i + 1}実行中...`)
    await new Promise((resolve) => setTimeout(resolve, 1000))
    return `タスク${i + 1}完了`
  })
}
```

## まとめ

p-queueは、非同期処理の並行制御とレート制限を実現する強力なライブラリです。主なポイントは以下の通りです：

### 主要な機能

- **並行制御**: 同時実行数の制限
- **レート制限**: 時間あたりの実行回数制限
- **優先度制御**: タスクの優先度設定
- **タイムアウト**: タスクの実行時間制限
- **エラーハンドリング**: リトライ機能とエラー監視

### 実装のポイント

- **適切な並行数設定**: リソースに応じた並行数の調整
- **レート制限の活用**: API呼び出しの制限に対応
- **エラーハンドリング**: リトライ機能とエラー監視の実装
- **監視機能**: キューの状態とメトリクスの監視

### 実践的な用途

- **API呼び出しの制限**: 外部APIのレート制限に対応
- **ファイル処理**: 大量ファイルの効率的な処理
- **バッチ処理**: データの一括処理
- **リソース管理**: CPUやメモリの使用量制御

[p-queue公式リポジトリ](https://github.com/sindresorhus/p-queue)を参考に、効率的な非同期処理の実装を学びましょう。適切な設計と実装により、スケーラブルで安定したアプリケーションを構築できます。
