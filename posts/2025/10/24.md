---
date: 2025-10-24
title: p-queue完全入門：Promiseキューの並行制御で効率的な非同期処理を実現する
description: p-queueライブラリを使ったPromiseキューの並行制御について、初心者向けに詳しく解説。基本的な使い方から高度な機能まで、実践的なコード例を通じて、API呼び出しの制限、CPU集約的なタスクの管理、レート制限の実装方法を学ぶ実践的なガイド。
tags:
    - p-queue
    - promise
    - concurrency
    - rate-limiting
    - async
    - queue
    - javascript
    - typescript
    - performance
prev:
    text: "NestJS/Swagger完全入門：OpenAPI仕様でAPIドキュメントを自動生成する"
    link: "/posts/2025/10/23"
next: false
---

# p-queue完全入門：Promiseキューの並行制御で効率的な非同期処理を実現する

[p-queue](https://github.com/sindresorhus/p-queue)は、Promiseベースの非同期処理を効率的に管理するためのライブラリです。並行制御、レート制限、優先度付きキューなどの機能を提供し、API呼び出しの制限やCPU集約的なタスクの管理に最適です。この記事では、p-queueの基本的な使い方から高度な機能まで、実践的なコード例を通じて詳しく解説します。

## p-queueとは

p-queueは、非同期処理の並行数を制御し、効率的なリソース管理を実現するPromiseキューのライブラリです。主な用途は以下の通りです：

- **API呼び出しの制限**: 外部APIのレート制限に対応
- **リソース管理**: CPUやメモリの使用量を制御
- **バッチ処理**: 大量のデータを効率的に処理
- **優先度制御**: 重要なタスクを優先実行

### 主な特徴

- **並行制御**: 同時実行数を制限
- **レート制限**: 時間あたりの実行回数を制限
- **優先度制御**: タスクの優先度を設定
- **タイムアウト**: タスクの実行時間制限
- **イベント監視**: キューの状態を監視

## 基本的なセットアップ

### インストール

```bash
# p-queueをインストール
npm install p-queue

# TypeScriptを使用する場合
npm install -D @types/node
```

### 基本的な使い方

```typescript
import PQueue from 'p-queue';

// 基本的なキューの作成
const queue = new PQueue({ concurrency: 1 });

// タスクを追加
const task = async () => {
  console.log('タスクを実行中...');
  await new Promise(resolve => setTimeout(resolve, 1000));
  return '完了';
};

// タスクを実行
queue.add(task).then(result => {
  console.log('結果:', result);
});
```

## 並行制御の実装

### 基本的な並行制御

```typescript
import PQueue from 'p-queue';

// 同時実行数を2に制限
const queue = new PQueue({ concurrency: 2 });

// 複数のタスクを追加
const tasks = [
  () => fetchData(1),
  () => fetchData(2),
  () => fetchData(3),
  () => fetchData(4),
  () => fetchData(5),
];

// タスクを並行実行
tasks.forEach((task, index) => {
  queue.add(task).then(result => {
    console.log(`タスク${index + 1}完了:`, result);
  });
});
```

### 動的な並行制御

```typescript
import PQueue from 'p-queue';

class DynamicQueue {
  private queue: PQueue;
  private maxConcurrency: number;

  constructor(maxConcurrency: number = 5) {
    this.maxConcurrency = maxConcurrency;
    this.queue = new PQueue({ concurrency: maxConcurrency });
  }

  // 並行数を動的に調整
  adjustConcurrency(newConcurrency: number) {
    this.queue.concurrency = newConcurrency;
    console.log(`並行数を${newConcurrency}に調整`);
  }

  // タスクを追加
  async addTask<T>(task: () => Promise<T>): Promise<T> {
    return this.queue.add(task);
  }

  // キューの状態を取得
  getStatus() {
    return {
      pending: this.queue.pending,
      size: this.queue.size,
      isPaused: this.queue.isPaused,
    };
  }
}

// 使用例
const dynamicQueue = new DynamicQueue(3);

// 並行数を動的に調整
setTimeout(() => {
  dynamicQueue.adjustConcurrency(1); // 並行数を1に減らす
}, 5000);

setTimeout(() => {
  dynamicQueue.adjustConcurrency(5); // 並行数を5に増やす
}, 10000);
```

## レート制限の実装

### 基本的なレート制限

```typescript
import PQueue from 'p-queue';

// レート制限付きキュー
const rateLimitedQueue = new PQueue({
  concurrency: 1,        // 同時実行数
  interval: 1000,        // 1秒間隔
  intervalCap: 5,        // 1秒間に5回まで
});

// API呼び出しの例
const apiCall = async (endpoint: string) => {
  console.log(`API呼び出し: ${endpoint}`);
  const response = await fetch(endpoint);
  return response.json();
};

// レート制限付きでAPI呼び出し
const endpoints = [
  'https://api.example.com/users/1',
  'https://api.example.com/users/2',
  'https://api.example.com/users/3',
  'https://api.example.com/users/4',
  'https://api.example.com/users/5',
  'https://api.example.com/users/6',
  'https://api.example.com/users/7',
  'https://api.example.com/users/8',
];

endpoints.forEach((endpoint, index) => {
  rateLimitedQueue.add(() => apiCall(endpoint)).then(result => {
    console.log(`API呼び出し${index + 1}完了:`, result);
  });
});
```

### 高度なレート制限

```typescript
import PQueue from 'p-queue';

class RateLimitedAPI {
  private queue: PQueue;
  private requestCount: number = 0;
  private resetTime: number = 0;

  constructor(requestsPerMinute: number = 60) {
    this.queue = new PQueue({
      concurrency: 1,
      interval: 60000, // 1分間隔
      intervalCap: requestsPerMinute,
    });
  }

  // API呼び出し
  async callAPI<T>(endpoint: string, options?: RequestInit): Promise<T> {
    return this.queue.add(async () => {
      const now = Date.now();
      
      // レート制限のチェック
      if (now > this.resetTime) {
        this.requestCount = 0;
        this.resetTime = now + 60000; // 1分後にリセット
      }

      if (this.requestCount >= 60) {
        const waitTime = this.resetTime - now;
        console.log(`レート制限に達しました。${waitTime}ms待機します。`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }

      this.requestCount++;
      console.log(`API呼び出し: ${endpoint} (${this.requestCount}/60)`);
      
      const response = await fetch(endpoint, options);
      if (!response.ok) {
        throw new Error(`API呼び出し失敗: ${response.status}`);
      }
      
      return response.json();
    });
  }
}

// 使用例
const api = new RateLimitedAPI(60); // 1分間に60回まで

// 複数のAPI呼び出し
const apiCalls = [
  () => api.callAPI('https://api.example.com/users/1'),
  () => api.callAPI('https://api.example.com/users/2'),
  () => api.callAPI('https://api.example.com/users/3'),
];

apiCalls.forEach((call, index) => {
  call().then(result => {
    console.log(`API呼び出し${index + 1}完了:`, result);
  }).catch(error => {
    console.error(`API呼び出し${index + 1}失敗:`, error);
  });
});
```

## 優先度制御の実装

### 基本的な優先度制御

```typescript
import PQueue from 'p-queue';

// 優先度付きキュー
const priorityQueue = new PQueue({ concurrency: 2 });

// 優先度付きタスク
const addTaskWithPriority = async (
  task: () => Promise<any>,
  priority: number = 0
) => {
  return priorityQueue.add(task, { priority });
};

// 高優先度タスク
const highPriorityTask = async () => {
  console.log('高優先度タスク実行中...');
  await new Promise(resolve => setTimeout(resolve, 1000));
  return '高優先度タスク完了';
};

// 低優先度タスク
const lowPriorityTask = async () => {
  console.log('低優先度タスク実行中...');
  await new Promise(resolve => setTimeout(resolve, 1000));
  return '低優先度タスク完了';
};

// タスクを優先度付きで追加
addTaskWithPriority(lowPriorityTask, 1);  // 低優先度
addTaskWithPriority(highPriorityTask, 10); // 高優先度
addTaskWithPriority(lowPriorityTask, 1);  // 低優先度
addTaskWithPriority(highPriorityTask, 10); // 高優先度
```

### 高度な優先度制御

```typescript
import PQueue from 'p-queue';

interface Task {
  id: string;
  priority: number;
  task: () => Promise<any>;
  createdAt: number;
}

class PriorityTaskQueue {
  private queue: PQueue;
  private tasks: Map<string, Task> = new Map();

  constructor(concurrency: number = 3) {
    this.queue = new PQueue({ concurrency });
  }

  // タスクを追加
  async addTask<T>(
    id: string,
    task: () => Promise<T>,
    priority: number = 0
  ): Promise<T> {
    const taskObj: Task = {
      id,
      priority,
      task,
      createdAt: Date.now(),
    };

    this.tasks.set(id, taskObj);

    return this.queue.add(taskObj.task, { 
      priority: priority,
      id: id 
    });
  }

  // タスクをキャンセル
  cancelTask(id: string): boolean {
    if (this.tasks.has(id)) {
      this.tasks.delete(id);
      return true;
    }
    return false;
  }

  // キューの状態を取得
  getStatus() {
    return {
      pending: this.queue.pending,
      size: this.queue.size,
      tasks: Array.from(this.tasks.values()),
    };
  }
}

// 使用例
const priorityQueue = new PriorityTaskQueue(2);

// タスクを追加
priorityQueue.addTask('task1', async () => {
  console.log('タスク1実行中...');
  await new Promise(resolve => setTimeout(resolve, 2000));
  return 'タスク1完了';
}, 1);

priorityQueue.addTask('task2', async () => {
  console.log('タスク2実行中...');
  await new Promise(resolve => setTimeout(resolve, 1000));
  return 'タスク2完了';
}, 10); // 高優先度

priorityQueue.addTask('task3', async () => {
  console.log('タスク3実行中...');
  await new Promise(resolve => setTimeout(resolve, 1500));
  return 'タスク3完了';
}, 5);
```

## タイムアウトとエラーハンドリング

### 基本的なタイムアウト

```typescript
import PQueue from 'p-queue';

// タイムアウト付きキュー
const timeoutQueue = new PQueue({ 
  concurrency: 2,
  timeout: 5000, // 5秒でタイムアウト
});

// タイムアウト付きタスク
const addTaskWithTimeout = async (
  task: () => Promise<any>,
  timeout: number = 5000
) => {
  return timeoutQueue.add(task, { timeout });
};

// 長時間実行されるタスク
const longRunningTask = async () => {
  console.log('長時間実行タスク開始...');
  await new Promise(resolve => setTimeout(resolve, 3000));
  return '長時間実行タスク完了';
};

// タイムアウトするタスク
const timeoutTask = async () => {
  console.log('タイムアウトタスク開始...');
  await new Promise(resolve => setTimeout(resolve, 10000));
  return 'タイムアウトタスク完了';
};

// タスクを実行
addTaskWithTimeout(longRunningTask).then(result => {
  console.log('結果:', result);
}).catch(error => {
  console.error('エラー:', error.message);
});

addTaskWithTimeout(timeoutTask).then(result => {
  console.log('結果:', result);
}).catch(error => {
  console.error('エラー:', error.message);
});
```

### 高度なエラーハンドリング

```typescript
import PQueue from 'p-queue';

class RobustQueue {
  private queue: PQueue;
  private retryCount: number = 0;
  private maxRetries: number = 3;

  constructor(concurrency: number = 2) {
    this.queue = new PQueue({ concurrency });
    
    // エラーイベントの監視
    this.queue.on('error', (error) => {
      console.error('キューエラー:', error);
    });
  }

  // リトライ付きタスク
  async addTaskWithRetry<T>(
    task: () => Promise<T>,
    maxRetries: number = 3
  ): Promise<T> {
    let lastError: Error;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await this.queue.add(task, { 
          timeout: 10000,
          id: `task-${Date.now()}-${attempt}`
        });
      } catch (error) {
        lastError = error as Error;
        console.warn(`タスク実行失敗 (試行${attempt + 1}/${maxRetries + 1}):`, error.message);
        
        if (attempt < maxRetries) {
          const delay = Math.pow(2, attempt) * 1000; // 指数バックオフ
          console.log(`${delay}ms後にリトライします...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    throw new Error(`タスクが${maxRetries + 1}回の試行後に失敗: ${lastError.message}`);
  }

  // バッチ処理
  async processBatch<T>(
    items: T[],
    processor: (item: T) => Promise<any>,
    batchSize: number = 5
  ): Promise<any[]> {
    const results: any[] = [];
    
    for (let i = 0; i < items.length; i += batchSize) {
      const batch = items.slice(i, i + batchSize);
      console.log(`バッチ${Math.floor(i / batchSize) + 1}を処理中...`);
      
      const batchResults = await Promise.allSettled(
        batch.map(item => this.addTaskWithRetry(() => processor(item)))
      );
      
      results.push(...batchResults.map(result => 
        result.status === 'fulfilled' ? result.value : null
      ));
    }
    
    return results;
  }
}

// 使用例
const robustQueue = new RobustQueue(3);

// 失敗する可能性のあるタスク
const unreliableTask = async (id: number) => {
  console.log(`タスク${id}実行中...`);
  
  // ランダムに失敗
  if (Math.random() < 0.3) {
    throw new Error(`タスク${id}がランダムに失敗`);
  }
  
  await new Promise(resolve => setTimeout(resolve, 1000));
  return `タスク${id}完了`;
};

// バッチ処理
const items = Array.from({ length: 10 }, (_, i) => i + 1);
robustQueue.processBatch(items, unreliableTask, 3).then(results => {
  console.log('バッチ処理完了:', results);
}).catch(error => {
  console.error('バッチ処理エラー:', error);
});
```

## 実践的なアプリケーション例

### API呼び出しの制限

```typescript
import PQueue from 'p-queue';

class APIClient {
  private queue: PQueue;
  private baseURL: string;

  constructor(baseURL: string, requestsPerSecond: number = 10) {
    this.baseURL = baseURL;
    this.queue = new PQueue({
      concurrency: 1,
      interval: 1000,
      intervalCap: requestsPerSecond,
    });
  }

  // GETリクエスト
  async get<T>(endpoint: string): Promise<T> {
    return this.queue.add(async () => {
      const response = await fetch(`${this.baseURL}${endpoint}`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return response.json();
    });
  }

  // POSTリクエスト
  async post<T>(endpoint: string, data: any): Promise<T> {
    return this.queue.add(async () => {
      const response = await fetch(`${this.baseURL}${endpoint}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return response.json();
    });
  }
}

// 使用例
const apiClient = new APIClient('https://api.example.com', 5); // 1秒間に5回まで

// 複数のAPI呼び出し
const apiCalls = [
  () => apiClient.get('/users/1'),
  () => apiClient.get('/users/2'),
  () => apiClient.get('/users/3'),
  () => apiClient.get('/users/4'),
  () => apiClient.get('/users/5'),
];

apiCalls.forEach((call, index) => {
  call().then(result => {
    console.log(`API呼び出し${index + 1}完了:`, result);
  }).catch(error => {
    console.error(`API呼び出し${index + 1}失敗:`, error);
  });
});
```

### ファイル処理の制限

```typescript
import PQueue from 'p-queue';
import fs from 'fs/promises';
import path from 'path';

class FileProcessor {
  private queue: PQueue;
  private processedFiles: Set<string> = new Set();

  constructor(concurrency: number = 3) {
    this.queue = new PQueue({ concurrency });
  }

  // ファイルを処理
  async processFile(filePath: string): Promise<any> {
    if (this.processedFiles.has(filePath)) {
      console.log(`ファイル${filePath}は既に処理済みです`);
      return null;
    }

    return this.queue.add(async () => {
      console.log(`ファイル処理開始: ${filePath}`);
      
      try {
        const content = await fs.readFile(filePath, 'utf-8');
        const stats = await fs.stat(filePath);
        
        // ファイルの内容を処理（例：JSON解析）
        const data = JSON.parse(content);
        
        this.processedFiles.add(filePath);
        console.log(`ファイル処理完了: ${filePath}`);
        
        return {
          path: filePath,
          size: stats.size,
          data: data,
        };
      } catch (error) {
        console.error(`ファイル処理エラー: ${filePath}`, error);
        throw error;
      }
    });
  }

  // ディレクトリ内の全ファイルを処理
  async processDirectory(dirPath: string): Promise<any[]> {
    const files = await fs.readdir(dirPath);
    const jsonFiles = files.filter(file => file.endsWith('.json'));
    
    console.log(`${jsonFiles.length}個のJSONファイルを処理します`);
    
    const results = await Promise.allSettled(
      jsonFiles.map(file => 
        this.processFile(path.join(dirPath, file))
      )
    );
    
    return results
      .filter(result => result.status === 'fulfilled')
      .map(result => (result as PromiseFulfilledResult<any>).value);
  }
}

// 使用例
const fileProcessor = new FileProcessor(2); // 同時に2ファイルまで処理

// 単一ファイルの処理
fileProcessor.processFile('./data/sample.json').then(result => {
  console.log('ファイル処理結果:', result);
}).catch(error => {
  console.error('ファイル処理エラー:', error);
});

// ディレクトリ内の全ファイルを処理
fileProcessor.processDirectory('./data').then(results => {
  console.log('全ファイル処理完了:', results);
}).catch(error => {
  console.error('ディレクトリ処理エラー:', error);
});
```

## 監視とデバッグ

### キューの状態監視

```typescript
import PQueue from 'p-queue';

class MonitoredQueue {
  private queue: PQueue;
  private metrics: {
    completed: number;
    failed: number;
    totalTime: number;
  } = {
    completed: 0,
    failed: 0,
    totalTime: 0,
  };

  constructor(concurrency: number = 3) {
    this.queue = new PQueue({ concurrency });
    
    // イベントリスナーの設定
    this.queue.on('completed', (result) => {
      this.metrics.completed++;
      console.log('タスク完了:', result);
    });
    
    this.queue.on('error', (error) => {
      this.metrics.failed++;
      console.error('タスクエラー:', error);
    });
  }

  // タスクを追加
  async addTask<T>(task: () => Promise<T>): Promise<T> {
    const startTime = Date.now();
    
    try {
      const result = await this.queue.add(task);
      this.metrics.totalTime += Date.now() - startTime;
      return result;
    } catch (error) {
      this.metrics.totalTime += Date.now() - startTime;
      throw error;
    }
  }

  // メトリクスを取得
  getMetrics() {
    return {
      ...this.metrics,
      pending: this.queue.pending,
      size: this.queue.size,
      isPaused: this.queue.isPaused,
      averageTime: this.metrics.completed > 0 
        ? this.metrics.totalTime / this.metrics.completed 
        : 0,
    };
  }

  // キューの状態をログ出力
  logStatus() {
    const metrics = this.getMetrics();
    console.log('キュー状態:', {
      pending: metrics.pending,
      size: metrics.size,
      completed: metrics.completed,
      failed: metrics.failed,
      averageTime: Math.round(metrics.averageTime),
    });
  }
}

// 使用例
const monitoredQueue = new MonitoredQueue(2);

// 定期的に状態をログ出力
setInterval(() => {
  monitoredQueue.logStatus();
}, 5000);

// タスクを追加
for (let i = 0; i < 10; i++) {
  monitoredQueue.addTask(async () => {
    console.log(`タスク${i + 1}実行中...`);
    await new Promise(resolve => setTimeout(resolve, 1000));
    return `タスク${i + 1}完了`;
  });
}
```

## まとめ

p-queueは、非同期処理の並行制御とレート制限を実現する強力なライブラリです。主なポイントは以下の通りです：

### 主要な機能
- **並行制御**: 同時実行数の制限
- **レート制限**: 時間あたりの実行回数制限
- **優先度制御**: タスクの優先度設定
- **タイムアウト**: タスクの実行時間制限
- **エラーハンドリング**: リトライ機能とエラー監視

### 実装のポイント
- **適切な並行数設定**: リソースに応じた並行数の調整
- **レート制限の活用**: API呼び出しの制限に対応
- **エラーハンドリング**: リトライ機能とエラー監視の実装
- **監視機能**: キューの状態とメトリクスの監視

### 実践的な用途
- **API呼び出しの制限**: 外部APIのレート制限に対応
- **ファイル処理**: 大量ファイルの効率的な処理
- **バッチ処理**: データの一括処理
- **リソース管理**: CPUやメモリの使用量制御

[p-queue公式リポジトリ](https://github.com/sindresorhus/p-queue)を参考に、効率的な非同期処理の実装を学びましょう。適切な設計と実装により、スケーラブルで安定したアプリケーションを構築できます。
