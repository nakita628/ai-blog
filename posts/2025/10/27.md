---
date: 2025-10-27
title: 依存性注入（DI）完全入門：疎結合で保守性の高いアプリケーションを構築する
description: 依存性注入（DI）の基本概念から実装方法まで、初心者向けに詳しく解説。従来の依存関係の問題点、DIパターンの利点、TypeScriptでの実装例、フレームワークでの活用方法を通じて、疎結合で保守性の高いアプリケーション設計を学ぶ実践的なガイド。
tags:
  - dependency-injection
  - di
  - design-patterns
  - typescript
  - architecture
  - ioc
  - inversion-of-control
  - clean-code
  - maintainability
prev:
  text: 'ElysiaJS完全入門：Bun最適化のTypeScriptフレームワークで高速API開発を実現する'
  link: '/posts/2025/10/26'
next: false
---

# 依存性注入（DI）完全入門：疎結合で保守性の高いアプリケーションを構築する

依存性注入（Dependency Injection, DI）は、オブジェクト指向プログラミングにおける重要な設計パターンです。クラス間の依存関係を外部から注入することで、疎結合で保守性の高いアプリケーションを構築できます。この記事では、DIの基本概念から実装方法まで、実践的なコード例を通じて詳しく解説します。

## 依存性注入とは

依存性注入（DI）は、オブジェクトが依存する他のオブジェクトを外部から注入する設計パターンです。これにより、クラス間の結合度を下げ、テスタビリティと保守性を向上させることができます。

### 従来の依存関係の問題点

```typescript
// 問題のあるコード例
class EmailService {
  sendEmail(to: string, subject: string, body: string): void {
    console.log(`Sending email to ${to}: ${subject}`)
    // 実際のメール送信処理
  }
}

class UserService {
  private emailService: EmailService

  constructor() {
    // 直接インスタンス化（強い結合）
    this.emailService = new EmailService()
  }

  createUser(name: string, email: string): void {
    console.log(`Creating user: ${name}`)
    // ユーザー作成処理

    // メール送信
    this.emailService.sendEmail(email, 'Welcome', 'Welcome to our service!')
  }
}

// 使用例
const userService = new UserService()
userService.createUser('John Doe', 'john@example.com')
```

**問題点:**

- **強い結合**: UserServiceがEmailServiceに直接依存
- **テスト困難**: EmailServiceをモック化できない
- **柔軟性の欠如**: 異なるメールサービスに切り替えられない
- **責任の混在**: UserServiceがEmailServiceの作成を担当

## 依存性注入の基本実装

### コンストラクタインジェクション

```typescript
// インターフェースの定義
interface IEmailService {
  sendEmail(to: string, subject: string, body: string): void
}

// 実装クラス
class EmailService implements IEmailService {
  sendEmail(to: string, subject: string, body: string): void {
    console.log(`Sending email to ${to}: ${subject}`)
    // 実際のメール送信処理
  }
}

// 依存性注入を使用したUserService
class UserService {
  private emailService: IEmailService

  constructor(emailService: IEmailService) {
    // 依存性を外部から注入
    this.emailService = emailService
  }

  createUser(name: string, email: string): void {
    console.log(`Creating user: ${name}`)
    // ユーザー作成処理

    // メール送信
    this.emailService.sendEmail(email, 'Welcome', 'Welcome to our service!')
  }
}

// 使用例
const emailService = new EmailService()
const userService = new UserService(emailService)
userService.createUser('John Doe', 'john@example.com')
```

### セッターインジェクション

```typescript
class UserService {
  private emailService?: IEmailService

  // セッターインジェクション
  setEmailService(emailService: IEmailService): void {
    this.emailService = emailService
  }

  createUser(name: string, email: string): void {
    console.log(`Creating user: ${name}`)

    if (!this.emailService) {
      throw new Error('EmailService is not set')
    }

    this.emailService.sendEmail(email, 'Welcome', 'Welcome to our service!')
  }
}

// 使用例
const userService = new UserService()
userService.setEmailService(new EmailService())
userService.createUser('John Doe', 'john@example.com')
```

### メソッドインジェクション

```typescript
class UserService {
  createUser(name: string, email: string, emailService: IEmailService): void {
    console.log(`Creating user: ${name}`)
    // ユーザー作成処理

    // メソッドの引数として依存性を注入
    emailService.sendEmail(email, 'Welcome', 'Welcome to our service!')
  }
}

// 使用例
const userService = new UserService()
const emailService = new EmailService()
userService.createUser('John Doe', 'john@example.com', emailService)
```

## 依存性注入コンテナの実装

### 基本的なDIコンテナ

```typescript
interface ServiceContainer {
  register<T>(token: string, factory: () => T): void
  resolve<T>(token: string): T
}

class DIContainer implements ServiceContainer {
  private services = new Map<string, () => any>()

  register<T>(token: string, factory: () => T): void {
    this.services.set(token, factory)
  }

  resolve<T>(token: string): T {
    const factory = this.services.get(token)
    if (!factory) {
      throw new Error(`Service ${token} not found`)
    }
    return factory()
  }
}

// 使用例
const container = new DIContainer()

// サービスの登録
container.register('emailService', () => new EmailService())
container.register(
  'userService',
  () => new UserService(container.resolve<IEmailService>('emailService')),
)

// サービスの取得
const userService = container.resolve<UserService>('userService')
userService.createUser('John Doe', 'john@example.com')
```

### シングルトンパターンの実装

```typescript
class DIContainer {
  private services = new Map<string, () => any>()
  private instances = new Map<string, any>()

  register<T>(token: string, factory: () => T, singleton: boolean = false): void {
    this.services.set(token, { factory, singleton })
  }

  resolve<T>(token: string): T {
    const serviceConfig = this.services.get(token)
    if (!serviceConfig) {
      throw new Error(`Service ${token} not found`)
    }

    // シングルトンの場合、既存のインスタンスを返す
    if (serviceConfig.singleton) {
      if (!this.instances.has(token)) {
        this.instances.set(token, serviceConfig.factory())
      }
      return this.instances.get(token)
    }

    // 毎回新しいインスタンスを作成
    return serviceConfig.factory()
  }
}

// 使用例
const container = new DIContainer()

// シングルトンとして登録
container.register('emailService', () => new EmailService(), true)
container.register(
  'userService',
  () => new UserService(container.resolve<IEmailService>('emailService')),
  true,
)

// 同じインスタンスが返される
const userService1 = container.resolve<UserService>('userService')
const userService2 = container.resolve<UserService>('userService')
console.log(userService1 === userService2) // true
```

## 実践的なアプリケーション例

### ユーザー管理システム

```typescript
// インターフェースの定義
interface IUserRepository {
  save(user: User): Promise<User>
  findById(id: string): Promise<User | null>
  findByEmail(email: string): Promise<User | null>
}

interface IEmailService {
  sendEmail(to: string, subject: string, body: string): Promise<void>
}

interface ILogger {
  log(message: string): void
  error(message: string, error?: Error): void
}

// 実装クラス
class User {
  constructor(
    public id: string,
    public name: string,
    public email: string,
    public createdAt: Date = new Date(),
  ) {}
}

class UserRepository implements IUserRepository {
  private users: User[] = []

  async save(user: User): Promise<User> {
    this.users.push(user)
    return user
  }

  async findById(id: string): Promise<User | null> {
    return this.users.find((user) => user.id === id) || null
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.users.find((user) => user.email === email) || null
  }
}

class EmailService implements IEmailService {
  async sendEmail(to: string, subject: string, body: string): Promise<void> {
    console.log(`Sending email to ${to}: ${subject}`)
    // 実際のメール送信処理
  }
}

class Logger implements ILogger {
  log(message: string): void {
    console.log(`[LOG] ${new Date().toISOString()}: ${message}`)
  }

  error(message: string, error?: Error): void {
    console.error(`[ERROR] ${new Date().toISOString()}: ${message}`, error)
  }
}

// ユーザーサービス
class UserService {
  constructor(
    private userRepository: IUserRepository,
    private emailService: IEmailService,
    private logger: ILogger,
  ) {}

  async createUser(name: string, email: string): Promise<User> {
    try {
      this.logger.log(`Creating user: ${name} (${email})`)

      // メールアドレスの重複チェック
      const existingUser = await this.userRepository.findByEmail(email)
      if (existingUser) {
        throw new Error('User with this email already exists')
      }

      // ユーザー作成
      const user = new User(Date.now().toString(), name, email)

      const savedUser = await this.userRepository.save(user)

      // ウェルカムメール送信
      await this.emailService.sendEmail(email, 'Welcome!', `Hello ${name}, welcome to our service!`)

      this.logger.log(`User created successfully: ${savedUser.id}`)
      return savedUser
    } catch (error) {
      this.logger.error('Failed to create user', error as Error)
      throw error
    }
  }

  async getUserById(id: string): Promise<User | null> {
    this.logger.log(`Getting user by ID: ${id}`)
    return await this.userRepository.findById(id)
  }
}

// DIコンテナの設定
class AppContainer {
  private container = new DIContainer()

  constructor() {
    this.setupServices()
  }

  private setupServices(): void {
    // サービスの登録
    this.container.register('logger', () => new Logger(), true)
    this.container.register('userRepository', () => new UserRepository(), true)
    this.container.register('emailService', () => new EmailService(), true)

    this.container.register(
      'userService',
      () =>
        new UserService(
          this.container.resolve<IUserRepository>('userRepository'),
          this.container.resolve<IEmailService>('emailService'),
          this.container.resolve<ILogger>('logger'),
        ),
      true,
    )
  }

  resolve<T>(token: string): T {
    return this.container.resolve<T>(token)
  }
}

// アプリケーションの使用例
async function main() {
  const app = new AppContainer()
  const userService = app.resolve<UserService>('userService')

  try {
    // ユーザー作成
    const user = await userService.createUser('John Doe', 'john@example.com')
    console.log('User created:', user)

    // ユーザー取得
    const retrievedUser = await userService.getUserById(user.id)
    console.log('Retrieved user:', retrievedUser)
  } catch (error) {
    console.error('Application error:', error)
  }
}

main()
```

## フレームワークでの依存性注入

### NestJSでのDI

```typescript
// user.service.ts
import { Injectable } from '@nestjs/common'
import { InjectRepository } from '@nestjs/typeorm'
import { Repository } from 'typeorm'
import { User } from './user.entity'
import { EmailService } from './email.service'
import { Logger } from './logger.service'

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>,
    private emailService: EmailService,
    private logger: Logger,
  ) {}

  async createUser(name: string, email: string): Promise<User> {
    this.logger.log(`Creating user: ${name}`)

    const user = this.userRepository.create({ name, email })
    const savedUser = await this.userRepository.save(user)

    await this.emailService.sendEmail(email, 'Welcome', 'Welcome!')

    return savedUser
  }
}

// user.module.ts
import { Module } from '@nestjs/common'
import { TypeOrmModule } from '@nestjs/typeorm'
import { UserService } from './user.service'
import { UserController } from './user.controller'
import { EmailService } from './email.service'
import { Logger } from './logger.service'

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  controllers: [UserController],
  providers: [UserService, EmailService, Logger],
  exports: [UserService],
})
export class UserModule {}
```

### AngularでのDI

```typescript
// user.service.ts
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { Observable } from 'rxjs'

@Injectable({
  providedIn: 'root',
})
export class UserService {
  constructor(private http: HttpClient) {}

  getUsers(): Observable<User[]> {
    return this.http.get<User[]>('/api/users')
  }

  createUser(user: User): Observable<User> {
    return this.http.post<User>('/api/users', user)
  }
}

// user.component.ts
import { Component } from '@angular/core'
import { UserService } from './user.service'

@Component({
  selector: 'app-user',
  template: ` <div *ngFor="let user of users">{{ user.name }} - {{ user.email }}</div> `,
})
export class UserComponent {
  users: User[] = []

  constructor(private userService: UserService) {}

  ngOnInit() {
    this.userService.getUsers().subscribe((users) => {
      this.users = users
    })
  }
}
```

## テストでの活用

### モックを使ったテスト

```typescript
// user.service.test.ts
import { UserService } from './user.service'
import { IUserRepository } from './interfaces/user-repository.interface'
import { IEmailService } from './interfaces/email-service.interface'
import { ILogger } from './interfaces/logger.interface'

describe('UserService', () => {
  let userService: UserService
  let mockUserRepository: jest.Mocked<IUserRepository>
  let mockEmailService: jest.Mocked<IEmailService>
  let mockLogger: jest.Mocked<ILogger>

  beforeEach(() => {
    // モックの作成
    mockUserRepository = {
      save: jest.fn(),
      findById: jest.fn(),
      findByEmail: jest.fn(),
    }

    mockEmailService = {
      sendEmail: jest.fn(),
    }

    mockLogger = {
      log: jest.fn(),
      error: jest.fn(),
    }

    // 依存性注入でテスト対象を初期化
    userService = new UserService(mockUserRepository, mockEmailService, mockLogger)
  })

  describe('createUser', () => {
    it('should create user successfully', async () => {
      // Arrange
      const name = 'John Doe'
      const email = 'john@example.com'
      const expectedUser = new User('1', name, email)

      mockUserRepository.findByEmail.mockResolvedValue(null)
      mockUserRepository.save.mockResolvedValue(expectedUser)
      mockEmailService.sendEmail.mockResolvedValue(undefined)

      // Act
      const result = await userService.createUser(name, email)

      // Assert
      expect(result).toEqual(expectedUser)
      expect(mockUserRepository.findByEmail).toHaveBeenCalledWith(email)
      expect(mockUserRepository.save).toHaveBeenCalled()
      expect(mockEmailService.sendEmail).toHaveBeenCalledWith(
        email,
        'Welcome!',
        `Hello ${name}, welcome to our service!`,
      )
      expect(mockLogger.log).toHaveBeenCalledWith(`Creating user: ${name} (${email})`)
    })

    it('should throw error when user already exists', async () => {
      // Arrange
      const name = 'John Doe'
      const email = 'john@example.com'
      const existingUser = new User('1', 'Existing User', email)

      mockUserRepository.findByEmail.mockResolvedValue(existingUser)

      // Act & Assert
      await expect(userService.createUser(name, email)).rejects.toThrow(
        'User with this email already exists',
      )
    })
  })
})
```

## 依存性注入のベストプラクティス

### 1. インターフェースの活用

```typescript
// 良い例: インターフェースを使用
interface IUserRepository {
  save(user: User): Promise<User>
  findById(id: string): Promise<User | null>
}

class UserService {
  constructor(private userRepository: IUserRepository) {}
}

// 悪い例: 具象クラスに直接依存
class UserService {
  constructor(private userRepository: UserRepository) {} // 避ける
}
```

### 2. 循環依存の回避

```typescript
// 問題のあるコード（循環依存）
class UserService {
  constructor(private orderService: OrderService) {}
}

class OrderService {
  constructor(private userService: UserService) {} // 循環依存
}

// 解決策: イベントやコールバックを使用
class UserService {
  private onUserCreated: ((user: User) => void)[] = []

  addUserCreatedListener(callback: (user: User) => void) {
    this.onUserCreated.push(callback)
  }

  async createUser(user: User) {
    // ユーザー作成処理
    this.onUserCreated.forEach((callback) => callback(user))
  }
}

class OrderService {
  constructor() {
    // イベントリスナーとして登録
    // userService.addUserCreatedListener(this.handleUserCreated.bind(this));
  }
}
```

### 3. 適切なスコープの設定

```typescript
class DIContainer {
  register<T>(
    token: string,
    factory: () => T,
    scope: 'singleton' | 'transient' = 'transient'
  ): void {
    this.services.set(token, { factory, scope });
  }
}

// 使用例
container.register('logger', () => new Logger(), 'singleton');
container.register('userService', () => new UserService(...), 'transient');
```

## まとめ

依存性注入（DI）は、保守性とテスタビリティを向上させる重要な設計パターンです。主なポイントは以下の通りです：

### 主要な利点

- **疎結合**: クラス間の依存関係を外部化
- **テスタビリティ**: モックを使った簡単なテスト
- **柔軟性**: 実装の切り替えが容易
- **保守性**: コードの変更影響を局所化

### 実装のポイント

- **インターフェースの活用**: 具象クラスではなく抽象に依存
- **適切なスコープ**: シングルトンとトランジェントの使い分け
- **循環依存の回避**: イベントやコールバックの活用
- **DIコンテナの活用**: 依存関係の管理を自動化

### 実践的な用途

- **大規模アプリケーション**: 複雑な依存関係の管理
- **テスト駆動開発**: モックを使った単体テスト
- **プラグインシステム**: 動的な機能の追加
- **マイクロサービス**: サービス間の疎結合

依存性注入を適切に活用することで、保守性が高く、テストしやすい、柔軟なアプリケーションを構築できます。設計の初期段階からDIを考慮し、適切な抽象化を行うことが重要です。
