---
date: 2025-09-03
title: TanStack Router × Zod：型安全なルーティングとバリデーションの完全ガイド
description: TanStack RouterとZodを組み合わせた、型安全で堅牢なReactアプリケーションの構築方法を解説。ルーティング、データフェッチング、バリデーションを統合した実践的な開発パターン。
tags:
  - react
  - tanstack-router
  - zod
  - typescript
  - routing
  - validation
  - frontend
  - web-development
prev:
  text: 'React Hook Form完全ガイド：初心者向けフォーム管理の実践テクニック'
  link: '/posts/2025/09/02'
next: false
---

# TanStack Router × Zod：型安全なルーティングとバリデーションの完全ガイド

[TanStack Router](https://tanstack.com/router/latest)と[Zod](https://zod.dev/)は、現代のReactアプリケーション開発において、型安全性と堅牢性を提供する強力な組み合わせです。この記事では、両者を統合した開発パターンと実践的な使い方を解説します。

## TanStack RouterとZodとは

### TanStack Router

[TanStack Router](https://tanstack.com/router/latest)は、Reactアプリケーションのための型安全なルーターです。以下の特徴があります：

- **100%型安全**: TypeScriptとの完全な統合
- **データフェッチング**: ルートローダーによる効率的なデータ取得
- **検索パラメータ**: 状態管理レベルの検索パラメータAPI
- **軽量**: 12kbのバンドルサイズ
- **Suspense対応**: React 18の最新機能との統合

### Zod

[Zod](https://zod.dev/)は、TypeScriptファーストのスキーマバリデーションライブラリです：

- **型推論**: スキーマから自動的にTypeScript型を生成
- **実行時バリデーション**: データの整合性を保証
- **エラーハンドリング**: 詳細なバリデーションエラー
- **軽量**: 2kbのコアバンドル
- **豊富なエコシステム**: 様々なライブラリとの統合

## 基本的なセットアップ

### 1. インストール

```bash
# TanStack Router
npm install @tanstack/react-router

# Zod
npm install zod

# 開発用ツール
npm install -D @tanstack/router-devtools
```

### 2. プロジェクト構造

```
src/
├── routes/
│   ├── __root.tsx
│   ├── index.tsx
│   ├── users/
│   │   ├── $userId.tsx
│   │   └── index.tsx
│   └── posts/
│       ├── $postId.tsx
│       └── index.tsx
├── schemas/
│   ├── user.ts
│   ├── post.ts
│   └── common.ts
├── lib/
│   ├── router.ts
│   └── api.ts
└── main.tsx
```

## スキーマ定義（Zod）

### 1. 基本的なスキーマ

```ts
// src/schemas/common.ts
import { z } from 'zod'

// 共通のスキーマ
export const PaginationSchema = z.object({
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(20),
})

export const SearchParamsSchema = z.object({
  q: z.string().optional(),
  category: z.string().optional(),
  sort: z.enum(['asc', 'desc']).default('desc'),
})

// エラーレスポンス
export const ErrorResponseSchema = z.object({
  message: z.string(),
  code: z.string().optional(),
  details: z.record(z.any()).optional(),
})

// 成功レスポンス
export const SuccessResponseSchema = z.object({
  success: z.literal(true),
  data: z.any(),
  message: z.string().optional(),
})
```

### 2. ユーザー関連スキーマ

```ts
// src/schemas/user.ts
import { z } from 'zod'

// ユーザー基本情報
export const UserSchema = z.object({
  id: z.string().uuid(),
  username: z.string().min(3).max(50),
  email: z.string().email(),
  firstName: z.string().min(1).max(50),
  lastName: z.string().min(1).max(50),
  avatar: z.string().url().optional(),
  isActive: z.boolean().default(true),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
})

// ユーザー作成
export const CreateUserSchema = UserSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true,
})
  .extend({
    password: z
      .string()
      .min(8)
      .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, {
        message: 'パスワードは小文字、大文字、数字を含む必要があります',
      }),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: 'パスワードが一致しません',
    path: ['confirmPassword'],
  })

// ユーザー更新
export const UpdateUserSchema = UserSchema.partial().omit({
  id: true,
  createdAt: true,
  updatedAt: true,
})

// ユーザー一覧取得
export const UsersQuerySchema = z.object({
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(20),
  search: z.string().optional(),
  role: z.enum(['admin', 'user', 'moderator']).optional(),
  isActive: z.coerce.boolean().optional(),
})

// 型エクスポート
export type User = z.infer<typeof UserSchema>
export type CreateUser = z.infer<typeof CreateUserSchema>
export type UpdateUser = z.infer<typeof UpdateUserSchema>
export type UsersQuery = z.infer<typeof UsersQuerySchema>
```

### 3. 投稿関連スキーマ

```ts
// src/schemas/post.ts
import { z } from 'zod'

// 投稿スキーマ
export const PostSchema = z.object({
  id: z.string().uuid(),
  title: z.string().min(1).max(200),
  content: z.string().min(1).max(10000),
  excerpt: z.string().max(500).optional(),
  authorId: z.string().uuid(),
  author: z.object({
    id: z.string().uuid(),
    username: z.string(),
    avatar: z.string().url().optional(),
  }),
  tags: z.array(z.string()).max(10),
  status: z.enum(['draft', 'published', 'archived']).default('draft'),
  publishedAt: z.string().datetime().optional(),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
})

// 投稿作成
export const CreatePostSchema = PostSchema.omit({
  id: true,
  authorId: true,
  author: true,
  createdAt: true,
  updatedAt: true,
  publishedAt: true,
})

// 投稿更新
export const UpdatePostSchema = CreatePostSchema.partial()

// 投稿一覧取得
export const PostsQuerySchema = z.object({
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(50).default(20),
  search: z.string().optional(),
  authorId: z.string().uuid().optional(),
  status: z.enum(['draft', 'published', 'archived']).optional(),
  tags: z.array(z.string()).optional(),
  sortBy: z.enum(['createdAt', 'updatedAt', 'publishedAt', 'title']).default('createdAt'),
  sortOrder: z.enum(['asc', 'desc']).default('desc'),
})

// 型エクスポート
export type Post = z.infer<typeof PostSchema>
export type CreatePost = z.infer<typeof CreatePostSchema>
export type UpdatePost = z.infer<typeof UpdatePostSchema>
export type PostsQuery = z.infer<typeof PostsQuerySchema>
```

## ルーター設定（TanStack Router）

### 1. ルーターの初期化

```tsx
// src/lib/router.ts
import { createRouter, createRoute, createRootRoute } from '@tanstack/react-router'
import { z } from 'zod'
import { UsersQuerySchema, PostsQuerySchema } from '../schemas'

// ルート定義
const rootRoute = createRootRoute({
  component: () => <RootComponent />,
})

// インデックスルート
const indexRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: '/',
  component: () => <HomePage />,
})

// ユーザー一覧ルート
const usersRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: '/users',
  validateSearch: (search: Record<string, unknown>) => {
    return UsersQuerySchema.parse(search)
  },
  loader: async ({ search }) => {
    // 検索パラメータのバリデーション済み
    const query = search

    // API呼び出し
    const response = await fetch(
      `/api/users?${new URLSearchParams({
        page: query.page.toString(),
        limit: query.limit.toString(),
        ...(query.search && { search: query.search }),
        ...(query.role && { role: query.role }),
        ...(query.isActive !== undefined && { isActive: query.isActive.toString() }),
      })}`,
    )

    if (!response.ok) {
      throw new Error('Failed to fetch users')
    }

    const data = await response.json()
    return data
  },
  component: () => <UsersPage />,
})

// ユーザー詳細ルート
const userRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: '/users/$userId',
  parseParams: (params) => ({
    userId: z.string().uuid().parse(params.userId),
  }),
  loader: async ({ params }) => {
    const { userId } = params

    const response = await fetch(`/api/users/${userId}`)
    if (!response.ok) {
      throw new Error('User not found')
    }

    const data = await response.json()
    return data
  },
  component: () => <UserDetailPage />,
})

// 投稿一覧ルート
const postsRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: '/posts',
  validateSearch: (search: Record<string, unknown>) => {
    return PostsQuerySchema.parse(search)
  },
  loader: async ({ search }) => {
    const query = search

    const response = await fetch(
      `/api/posts?${new URLSearchParams({
        page: query.page.toString(),
        limit: query.limit.toString(),
        ...(query.search && { search: query.search }),
        ...(query.authorId && { authorId: query.authorId }),
        ...(query.status && { status: query.status }),
        ...(query.tags && { tags: query.tags.join(',') }),
        sortBy: query.sortBy,
        sortOrder: query.sortOrder,
      })}`,
    )

    if (!response.ok) {
      throw new Error('Failed to fetch posts')
    }

    const data = await response.json()
    return data
  },
  component: () => <PostsPage />,
})

// 投稿詳細ルート
const postRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: '/posts/$postId',
  parseParams: (params) => ({
    postId: z.string().uuid().parse(params.postId),
  }),
  loader: async ({ params }) => {
    const { postId } = params

    const response = await fetch(`/api/posts/${postId}`)
    if (!response.ok) {
      throw new Error('Post not found')
    }

    const data = await response.json()
    return data
  },
  component: () => <PostDetailPage />,
})

// ルーター作成
const routeTree = rootRoute.addChildren([indexRoute, usersRoute, userRoute, postsRoute, postRoute])

export const router = createRouter({
  routeTree,
  defaultPreload: 'intent',
  context: {
    // コンテキストを追加
  },
})

// 型定義
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router
  }
}
```

### 2. メインアプリケーション

```tsx
// src/main.tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import { RouterProvider } from '@tanstack/react-router'
import { router } from './lib/router'
import { TanStackRouterDevtools } from '@tanstack/router-devtools'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <RouterProvider router={router} />
    {process.env.NODE_ENV === 'development' && <TanStackRouterDevtools router={router} />}
  </React.StrictMode>,
)
```

## 実践的なコンポーネント例

### 1. ユーザー一覧ページ

```tsx
// src/routes/users/index.tsx
import React from 'react'
import { useLoaderData, useSearch, Link } from '@tanstack/react-router'
import { UserSchema } from '../../schemas/user'

// ローダーデータの型
type LoaderData = {
  users: z.infer<typeof UserSchema>[]
  pagination: {
    page: number
    limit: number
    total: number
    totalPages: number
  }
}

const UsersPage: React.FC = () => {
  const { users, pagination } = useLoaderData({ from: '/users' })
  const search = useSearch({ from: '/users' })

  const handleSearchChange = (newSearch: Partial<typeof search>) => {
    // 検索パラメータの更新
    router.navigate({
      to: '/users',
      search: { ...search, ...newSearch, page: 1 }, // 検索時はページを1にリセット
    })
  }

  return (
    <div className="max-w-6xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6">ユーザー一覧</h1>

      {/* 検索フィルター */}
      <div className="bg-white p-4 rounded-lg shadow mb-6">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <input
            type="text"
            placeholder="ユーザー名で検索"
            value={search.search || ''}
            onChange={(e) => handleSearchChange({ search: e.target.value })}
            className="px-3 py-2 border border-gray-300 rounded-md"
          />

          <select
            value={search.role || ''}
            onChange={(e) => handleSearchChange({ role: e.target.value || undefined })}
            className="px-3 py-2 border border-gray-300 rounded-md"
          >
            <option value="">すべてのロール</option>
            <option value="admin">管理者</option>
            <option value="user">ユーザー</option>
            <option value="moderator">モデレーター</option>
          </select>

          <select
            value={search.isActive?.toString() || ''}
            onChange={(e) =>
              handleSearchChange({
                isActive: e.target.value === '' ? undefined : e.target.value === 'true',
              })
            }
            className="px-3 py-2 border border-gray-300 rounded-md"
          >
            <option value="">すべてのステータス</option>
            <option value="true">アクティブ</option>
            <option value="false">非アクティブ</option>
          </select>

          <select
            value={search.limit}
            onChange={(e) => handleSearchChange({ limit: Number(e.target.value) })}
            className="px-3 py-2 border border-gray-300 rounded-md"
          >
            <option value={20}>20件表示</option>
            <option value={50}>50件表示</option>
            <option value={100}>100件表示</option>
          </select>
        </div>
      </div>

      {/* ユーザー一覧 */}
      <div className="bg-white rounded-lg shadow overflow-hidden">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                ユーザー
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                メール
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                ステータス
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                作成日
              </th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {users.map((user) => (
              <tr key={user.id} className="hover:bg-gray-50">
                <td className="px-6 py-4 whitespace-nowrap">
                  <div className="flex items-center">
                    <div className="flex-shrink-0 h-10 w-10">
                      {user.avatar ? (
                        <img
                          className="h-10 w-10 rounded-full"
                          src={user.avatar}
                          alt={user.username}
                        />
                      ) : (
                        <div className="h-10 w-10 rounded-full bg-gray-300 flex items-center justify-center">
                          <span className="text-gray-600 font-medium">
                            {user.firstName.charAt(0)}
                            {user.lastName.charAt(0)}
                          </span>
                        </div>
                      )}
                    </div>
                    <div className="ml-4">
                      <div className="text-sm font-medium text-gray-900">
                        <Link
                          to="/users/$userId"
                          params={{ userId: user.id }}
                          className="hover:text-blue-600"
                        >
                          {user.firstName} {user.lastName}
                        </Link>
                      </div>
                      <div className="text-sm text-gray-500">@{user.username}</div>
                    </div>
                  </div>
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{user.email}</td>
                <td className="px-6 py-4 whitespace-nowrap">
                  <span
                    className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${
                      user.isActive ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
                    }`}
                  >
                    {user.isActive ? 'アクティブ' : '非アクティブ'}
                  </span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {new Date(user.createdAt).toLocaleDateString('ja-JP')}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* ページネーション */}
      {pagination.totalPages > 1 && (
        <div className="mt-6 flex items-center justify-between">
          <div className="text-sm text-gray-700">
            {pagination.total}件中 {(pagination.page - 1) * pagination.limit + 1}-
            {Math.min(pagination.page * pagination.limit, pagination.total)}件を表示
          </div>
          <div className="flex space-x-2">
            {Array.from({ length: pagination.totalPages }, (_, i) => i + 1).map((page) => (
              <button
                key={page}
                onClick={() => handleSearchChange({ page })}
                className={`px-3 py-2 text-sm font-medium rounded-md ${
                  page === pagination.page
                    ? 'bg-blue-600 text-white'
                    : 'bg-white text-gray-700 border border-gray-300 hover:bg-gray-50'
                }`}
              >
                {page}
              </button>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}

export default UsersPage
```

### 2. ユーザー詳細ページ

```tsx
// src/routes/users/$userId.tsx
import React from 'react'
import { useLoaderData, useParams, Link } from '@tanstack/react-router'
import { UserSchema } from '../../schemas/user'

const UserDetailPage: React.FC = () => {
  const user = useLoaderData({ from: '/users/$userId' })
  const { userId } = useParams({ from: '/users/$userId' })

  return (
    <div className="max-w-4xl mx-auto p-6">
      <div className="mb-6">
        <Link to="/users" className="text-blue-600 hover:text-blue-800 text-sm">
          ← ユーザー一覧に戻る
        </Link>
      </div>

      <div className="bg-white rounded-lg shadow overflow-hidden">
        <div className="px-6 py-4 border-b border-gray-200">
          <h1 className="text-2xl font-bold text-gray-900">ユーザー詳細</h1>
        </div>

        <div className="px-6 py-4">
          <div className="flex items-center space-x-6 mb-6">
            {user.avatar ? (
              <img src={user.avatar} alt={user.username} className="h-24 w-24 rounded-full" />
            ) : (
              <div className="h-24 w-24 rounded-full bg-gray-300 flex items-center justify-center">
                <span className="text-gray-600 text-2xl font-medium">
                  {user.firstName.charAt(0)}
                  {user.lastName.charAt(0)}
                </span>
              </div>
            )}

            <div>
              <h2 className="text-xl font-semibold text-gray-900">
                {user.firstName} {user.lastName}
              </h2>
              <p className="text-gray-600">@{user.username}</p>
              <p className="text-gray-600">{user.email}</p>
            </div>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
              <h3 className="text-lg font-medium text-gray-900 mb-4">基本情報</h3>
              <dl className="space-y-3">
                <div>
                  <dt className="text-sm font-medium text-gray-500">ユーザーID</dt>
                  <dd className="text-sm text-gray-900 font-mono">{user.id}</dd>
                </div>
                <div>
                  <dt className="text-sm font-medium text-gray-500">ステータス</dt>
                  <dd>
                    <span
                      className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${
                        user.isActive ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
                      }`}
                    >
                      {user.isActive ? 'アクティブ' : '非アクティブ'}
                    </span>
                  </dd>
                </div>
                <div>
                  <dt className="text-sm font-medium text-gray-500">作成日</dt>
                  <dd className="text-sm text-gray-900">
                    {new Date(user.createdAt).toLocaleString('ja-JP')}
                  </dd>
                </div>
                <div>
                  <dt className="text-sm font-medium text-gray-500">更新日</dt>
                  <dd className="text-sm text-gray-900">
                    {new Date(user.updatedAt).toLocaleString('ja-JP')}
                  </dd>
                </div>
              </dl>
            </div>

            <div>
              <h3 className="text-lg font-medium text-gray-900 mb-4">アクション</h3>
              <div className="space-y-3">
                <button className="w-full bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700">
                  編集
                </button>
                <button className="w-full bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700">
                  パスワードリセット
                </button>
                {user.isActive ? (
                  <button className="w-full bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">
                    無効化
                  </button>
                ) : (
                  <button className="w-full bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700">
                    有効化
                  </button>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

export default UserDetailPage
```

## 高度なパターン

### 1. 検索パラメータの永続化

```tsx
// src/hooks/usePersistentSearch.ts
import { useEffect, useRef } from 'react'
import { useSearch, useNavigate } from '@tanstack/react-router'

export function usePersistentSearch<T extends Record<string, any>>(
  routeId: string,
  defaultValues: T,
) {
  const search = useSearch({ from: routeId })
  const navigate = useNavigate()
  const isInitialized = useRef(false)

  useEffect(() => {
    if (!isInitialized.current) {
      // URLから検索パラメータを復元
      const urlParams = new URLSearchParams(window.location.search)
      const hasParams = Array.from(urlParams.keys()).length > 0

      if (!hasParams) {
        // デフォルト値を設定
        navigate({
          to: routeId as any,
          search: defaultValues,
          replace: true,
        })
      }
      isInitialized.current = true
    }
  }, [navigate, routeId, defaultValues])

  const updateSearch = (updates: Partial<T>) => {
    navigate({
      to: routeId as any,
      search: { ...search, ...updates },
      replace: true,
    })
  }

  return { search, updateSearch }
}
```

### 2. エラーバウンダリー

```tsx
// src/components/ErrorBoundary.tsx
import React from 'react'
import { useRouteError } from '@tanstack/react-router'
import { ErrorResponseSchema } from '../schemas/common'

const ErrorBoundary: React.FC = () => {
  const error = useRouteError()

  // エラーの型を推論
  const parsedError = ErrorResponseSchema.safeParse(error)

  if (parsedError.success) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="max-w-md w-full bg-white shadow-lg rounded-lg p-6">
          <div className="text-center">
            <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100">
              <svg
                className="h-6 w-6 text-red-600"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M6 18L18 6M6 6l12 12"
                />
              </svg>
            </div>
            <h3 className="mt-4 text-lg font-medium text-gray-900">エラーが発生しました</h3>
            <p className="mt-2 text-sm text-gray-500">{parsedError.data.message}</p>
            {parsedError.data.code && (
              <p className="mt-1 text-xs text-gray-400">エラーコード: {parsedError.data.code}</p>
            )}
            <div className="mt-6">
              <button
                onClick={() => window.location.reload()}
                className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700"
              >
                再読み込み
              </button>
            </div>
          </div>
        </div>
      </div>
    )
  }

  // 予期しないエラーの場合
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full bg-white shadow-lg rounded-lg p-6">
        <div className="text-center">
          <h3 className="text-lg font-medium text-gray-900">予期しないエラーが発生しました</h3>
          <p className="mt-2 text-sm text-gray-500">
            システムエラーが発生しました。しばらく時間をおいてから再度お試しください。
          </p>
          <div className="mt-6">
            <button
              onClick={() => (window.location.href = '/')}
              className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700"
            >
              ホームに戻る
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

export default ErrorBoundary
```

## パフォーマンス最適化

### 1. 遅延ローディング

```tsx
// src/routes/__root.tsx
import React, { Suspense } from 'react'
import { Outlet } from '@tanstack/react-router'
import { LoadingSpinner } from '../components/LoadingSpinner'

const RootComponent: React.FC = () => {
  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white shadow">{/* ヘッダーコンテンツ */}</header>

      <main>
        <Suspense fallback={<LoadingSpinner />}>
          <Outlet />
        </Suspense>
      </main>

      <footer className="bg-white border-t">{/* フッターコンテンツ */}</footer>
    </div>
  )
}

export default RootComponent
```

### 2. プリフェッチング

```tsx
// src/components/UserCard.tsx
import React from 'react'
import { Link, useNavigate } from '@tanstack/react-router'
import { User } from '../schemas/user'

interface UserCardProps {
  user: User
}

const UserCard: React.FC<UserCardProps> = ({ user }) => {
  const navigate = useNavigate()

  const handleMouseEnter = () => {
    // ユーザー詳細ページをプリフェッチ
    navigate({
      to: '/users/$userId',
      params: { userId: user.id },
      preload: 'intent',
    })
  }

  return (
    <Link
      to="/users/$userId"
      params={{ userId: user.id }}
      onMouseEnter={handleMouseEnter}
      className="block bg-white rounded-lg shadow hover:shadow-md transition-shadow duration-200"
    >
      <div className="p-4">
        <div className="flex items-center space-x-3">
          {user.avatar ? (
            <img src={user.avatar} alt={user.username} className="h-12 w-12 rounded-full" />
          ) : (
            <div className="h-12 w-12 rounded-full bg-gray-300 flex items-center justify-center">
              <span className="text-gray-600 font-medium text-sm">
                {user.firstName.charAt(0)}
                {user.lastName.charAt(0)}
              </span>
            </div>
          )}

          <div>
            <h3 className="text-lg font-medium text-gray-900">
              {user.firstName} {user.lastName}
            </h3>
            <p className="text-gray-600">@{user.username}</p>
          </div>
        </div>
      </div>
    </Link>
  )
}

export default UserCard
```

## まとめ

TanStack RouterとZodの組み合わせにより、以下のような利点が得られます：

### 主な利点

1. **型安全性**: ルーティング、データフェッチング、バリデーションの完全な型保証
2. **開発効率**: 自動補完とエラー検出による高速開発
3. **保守性**: スキーマ駆動の開発による一貫性の確保
4. **パフォーマンス**: 効率的なデータフェッチングとプリフェッチング
5. **ユーザビリティ**: 検索パラメータの永続化と状態管理

### 実践のポイント

- **スキーマファースト**: Zodスキーマを先に定義し、型安全性を確保
- **検索パラメータ**: URLでの状態管理を活用したユーザー体験の向上
- **エラーハンドリング**: 適切なエラーバウンダリーとユーザーフレンドリーな表示
- **パフォーマンス**: 遅延ローディングとプリフェッチングの活用

[TanStack Router](https://tanstack.com/router/latest)と[Zod](https://zod.dev/)の組み合わせは、現代のReactアプリケーション開発において、型安全性と堅牢性を両立させる最適なソリューションです。継続的に学習することで、より高度なパターンとテクニックを習得できるでしょう。
