---
date: 2025-09-06
title: tRPC完全ガイド：型安全なAPI開発で開発効率を最大化する方法
description: tRPCを使った型安全なAPI開発の基本から応用まで解説。フロントエンドとバックエンド間の型安全性を実現し、開発効率を大幅に向上させる実践的な手法。
tags:
    - trpc
    - typescript
    - api
    - fullstack
    - type-safety
    - backend
    - frontend
    - web-development
prev:
    text: "React Three Fiber完全ガイド：3DグラフィックスをReactで簡単に実現する方法"
    link: "/posts/2025/09/04"
next:
    text: "Google Cloud と GitHub Actions の組み合わせ方：初心者向け完全ガイド"
    link: "/posts/2025/09/07"
---

# tRPC完全ガイド：型安全なAPI開発で開発効率を最大化する方法

[tRPC](https://trpc.io/)は、TypeScriptの型推論を活用してフロントエンドとバックエンド間の型安全性を実現するライブラリです。この記事では、従来のAPI開発の課題を解決し、開発効率を大幅に向上させるtRPCの使い方を実践的に解説します。

## tRPCとは

### 概要
tRPCは「TypeScript Remote Procedure Call」の略で、以下の特徴を持つライブラリです：

- **型安全性**: フロントエンドとバックエンド間で完全な型安全性を実現
- **ゼロ設定**: ビルドステップやコード生成が不要
- **フレームワーク非依存**: React、Next.js、Express、Fastifyなどに対応
- **軽量**: 依存関係が少なく、バンドルサイズが小さい
- **優れたDX**: 自動補完とIntelliSenseを提供

### 従来のAPI開発の課題

**従来のREST API**
```typescript
// バックエンド
app.get('/api/users/:id', (req, res) => {
  const user = getUserById(req.params.id);
  res.json(user);
});

// フロントエンド
const response = await fetch('/api/users/123');
const user = await response.json(); // any型、型安全性なし
```

**tRPC**
```typescript
// バックエンド
const userRouter = t.router({
  getById: t.procedure
    .input(z.object({ id: z.string() }))
    .query(({ input }) => getUserById(input.id))
});

// フロントエンド
const user = await trpc.user.getById.query({ id: '123' }); // 完全な型安全性
```

## 基本的なセットアップ

### 1. インストール

```bash
# 基本パッケージ
npm install @trpc/server @trpc/client

# バリデーション用
npm install zod

# React用（オプション）
npm install @trpc/react-query @tanstack/react-query

# Next.js用（オプション）
npm install @trpc/next
```

### 2. プロジェクト構造

```
src/
├── server/
│   ├── routers/
│   │   ├── user.router.ts
│   │   ├── post.router.ts
│   │   └── index.ts
│   ├── trpc.ts
│   └── index.ts
├── client/
│   ├── trpc.ts
│   └── providers.tsx
├── shared/
│   ├── types.ts
│   └── validators.ts
└── pages/
    └── api/
        └── trpc/
            └── [trpc].ts
```

## 基本的なtRPC API

### 1. サーバー側の設定

```typescript
// src/server/trpc.ts
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

// tRPCインスタンスの作成
const t = initTRPC.create();

// ルーターとプロシージャの作成
export const router = t.router;
export const publicProcedure = t.procedure;

// ミドルウェアの例
const loggingMiddleware = t.middleware(async ({ next, path }) => {
  const start = Date.now();
  const result = await next();
  const duration = Date.now() - start;
  console.log(`${path} took ${duration}ms`);
  return result;
});

export const loggedProcedure = publicProcedure.use(loggingMiddleware);
```

### 2. ユーザールーター

```typescript
// src/server/routers/user.router.ts
import { z } from 'zod';
import { router, publicProcedure, loggedProcedure } from '../trpc';

// 仮想的なデータベース
const users = [
  { id: '1', name: 'Alice', email: 'alice@example.com', age: 25 },
  { id: '2', name: 'Bob', email: 'bob@example.com', age: 30 },
  { id: '3', name: 'Charlie', email: 'charlie@example.com', age: 35 },
];

export const userRouter = router({
  // 全ユーザー取得
  getAll: publicProcedure.query(() => {
    return users;
  }),

  // IDでユーザー取得
  getById: publicProcedure
    .input(z.object({ id: z.string() }))
    .query(({ input }) => {
      const user = users.find(u => u.id === input.id);
      if (!user) {
        throw new Error('User not found');
      }
      return user;
    }),

  // ユーザー作成
  create: loggedProcedure
    .input(z.object({
      name: z.string().min(1),
      email: z.string().email(),
      age: z.number().min(0).max(120)
    }))
    .mutation(({ input }) => {
      const newUser = {
        id: String(users.length + 1),
        ...input
      };
      users.push(newUser);
      return newUser;
    }),

  // ユーザー更新
  update: loggedProcedure
    .input(z.object({
      id: z.string(),
      name: z.string().min(1).optional(),
      email: z.string().email().optional(),
      age: z.number().min(0).max(120).optional()
    }))
    .mutation(({ input }) => {
      const userIndex = users.findIndex(u => u.id === input.id);
      if (userIndex === -1) {
        throw new Error('User not found');
      }
      
      users[userIndex] = { ...users[userIndex], ...input };
      return users[userIndex];
    }),

  // ユーザー削除
  delete: loggedProcedure
    .input(z.object({ id: z.string() }))
    .mutation(({ input }) => {
      const userIndex = users.findIndex(u => u.id === input.id);
      if (userIndex === -1) {
        throw new Error('User not found');
      }
      
      const deletedUser = users.splice(userIndex, 1)[0];
      return deletedUser;
    })
});
```

### 3. メインルーター

```typescript
// src/server/routers/index.ts
import { router } from '../trpc';
import { userRouter } from './user.router';
import { postRouter } from './post.router';

export const appRouter = router({
  user: userRouter,
  post: postRouter,
});

export type AppRouter = typeof appRouter;
```

### 4. サーバー起動

```typescript
// src/server/index.ts
import { createHTTPServer } from '@trpc/server/adapters/standalone';
import { appRouter } from './routers';

const server = createHTTPServer({
  router: appRouter,
});

const port = process.env.PORT || 3001;
server.listen(port, () => {
  console.log(`🚀 tRPC server running on port ${port}`);
});
```

## クライアント側の設定

### 1. tRPCクライアント

```typescript
// src/client/trpc.ts
import { createTRPCClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from '../server/routers';

export const trpc = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3001',
    }),
  ],
});
```

### 2. React用の設定

```typescript
// src/client/providers.tsx
import React, { useState } from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { trpc, createTRPCReact } from './trpc';
import type { AppRouter } from '../server/routers';

// React用のtRPCクライアント
export const trpcReact = createTRPCReact<AppRouter>();

export function TRPCProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient());
  const [trpcClient] = useState(() =>
    trpcReact.createClient({
      links: [
        httpBatchLink({
          url: 'http://localhost:3001',
        }),
      ],
    })
  );

  return (
    <trpcReact.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    </trpcReact.Provider>
  );
}
```

## 実践的な使用例

### 1. 基本的なクエリとミューテーション

```typescript
// src/components/UserList.tsx
import React from 'react';
import { trpcReact } from '../client/providers';

export function UserList() {
  // 全ユーザー取得（クエリ）
  const { data: users, isLoading, error } = trpcReact.user.getAll.useQuery();
  
  // ユーザー作成（ミューテーション）
  const createUser = trpcReact.user.create.useMutation({
    onSuccess: () => {
      // 成功時にユーザーリストを再取得
      trpcReact.user.getAll.invalidate();
    },
  });

  const handleCreateUser = () => {
    createUser.mutate({
      name: 'New User',
      email: 'newuser@example.com',
      age: 25
    });
  };

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <h2>Users</h2>
      <button onClick={handleCreateUser} disabled={createUser.isLoading}>
        {createUser.isLoading ? 'Creating...' : 'Create User'}
      </button>
      
      <ul>
        {users?.map((user) => (
          <li key={user.id}>
            {user.name} ({user.email}) - {user.age} years old
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### 2. 条件付きクエリ

```typescript
// src/components/UserDetail.tsx
import React, { useState } from 'react';
import { trpcReact } from '../client/providers';

export function UserDetail() {
  const [userId, setUserId] = useState<string>('');
  
  // 条件付きクエリ（userIdが空でない場合のみ実行）
  const { data: user, isLoading, error } = trpcReact.user.getById.useQuery(
    { id: userId },
    { enabled: !!userId } // userIdが存在する場合のみクエリを実行
  );

  return (
    <div>
      <input
        type="text"
        value={userId}
        onChange={(e) => setUserId(e.target.value)}
        placeholder="Enter user ID"
      />
      
      {userId && (
        <div>
          {isLoading && <div>Loading user...</div>}
          {error && <div>Error: {error.message}</div>}
          {user && (
            <div>
              <h3>{user.name}</h3>
              <p>Email: {user.email}</p>
              <p>Age: {user.age}</p>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
```

### 3. 楽観的更新

```typescript
// src/components/UserUpdate.tsx
import React, { useState } from 'react';
import { trpcReact } from '../client/providers';

interface UserUpdateProps {
  userId: string;
  initialUser: { name: string; email: string; age: number };
}

export function UserUpdate({ userId, initialUser }: UserUpdateProps) {
  const [formData, setFormData] = useState(initialUser);
  
  const utils = trpcReact.useUtils();
  
  const updateUser = trpcReact.user.update.useMutation({
    // 楽観的更新
    onMutate: async (newData) => {
      // 進行中のクエリをキャンセル
      await utils.user.getAll.cancel();
      
      // 現在のデータを取得
      const previousUsers = utils.user.getAll.getData();
      
      // 楽観的にデータを更新
      utils.user.getAll.setData(undefined, (old) =>
        old?.map((user) =>
          user.id === userId ? { ...user, ...newData } : user
        )
      );
      
      // ロールバック用のデータを返す
      return { previousUsers };
    },
    
    // エラー時のロールバック
    onError: (err, newData, context) => {
      if (context?.previousUsers) {
        utils.user.getAll.setData(undefined, context.previousUsers);
      }
    },
    
    // 成功時の処理
    onSettled: () => {
      utils.user.getAll.invalidate();
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    updateUser.mutate({
      id: userId,
      ...formData
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={formData.name}
        onChange={(e) => setFormData({ ...formData, name: e.target.value })}
        placeholder="Name"
      />
      <input
        type="email"
        value={formData.email}
        onChange={(e) => setFormData({ ...formData, email: e.target.value })}
        placeholder="Email"
      />
      <input
        type="number"
        value={formData.age}
        onChange={(e) => setFormData({ ...formData, age: Number(e.target.value) })}
        placeholder="Age"
      />
      <button type="submit" disabled={updateUser.isLoading}>
        {updateUser.isLoading ? 'Updating...' : 'Update User'}
      </button>
    </form>
  );
}
```

## 高度な機能

### 1. ミドルウェアとコンテキスト

```typescript
// src/server/trpc.ts
import { initTRPC, TRPCError } from '@trpc/server';
import { z } from 'zod';

// コンテキストの型定義
interface Context {
  user?: {
    id: string;
    name: string;
    role: 'admin' | 'user';
  };
}

// コンテキスト作成関数
const createContext = (): Context => {
  // 実際の実装では、JWTトークンやセッションからユーザー情報を取得
  return {
    user: {
      id: '1',
      name: 'Alice',
      role: 'admin'
    }
  };
};

const t = initTRPC.context<Context>().create();

export const router = t.router;
export const publicProcedure = t.procedure;

// 認証が必要なプロシージャ
export const protectedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.user) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'You must be logged in to access this resource',
    });
  }
  return next({
    ctx: {
      ...ctx,
      user: ctx.user, // 型安全性のため
    },
  });
});

// 管理者権限が必要なプロシージャ
export const adminProcedure = protectedProcedure.use(({ ctx, next }) => {
  if (ctx.user.role !== 'admin') {
    throw new TRPCError({
      code: 'FORBIDDEN',
      message: 'Admin access required',
    });
  }
  return next();
});
```

### 2. エラーハンドリング

```typescript
// src/server/routers/user.router.ts
import { TRPCError } from '@trpc/server';
import { z } from 'zod';

export const userRouter = router({
  getById: publicProcedure
    .input(z.object({ id: z.string() }))
    .query(({ input }) => {
      const user = users.find(u => u.id === input.id);
      
      if (!user) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'User not found',
          cause: { userId: input.id }
        });
      }
      
      return user;
    }),

  create: protectedProcedure
    .input(z.object({
      name: z.string().min(1, 'Name is required'),
      email: z.string().email('Invalid email format'),
      age: z.number().min(0, 'Age must be positive').max(120, 'Age must be less than 120')
    }))
    .mutation(({ input, ctx }) => {
      // メールアドレスの重複チェック
      const existingUser = users.find(u => u.email === input.email);
      if (existingUser) {
        throw new TRPCError({
          code: 'CONFLICT',
          message: 'User with this email already exists',
        });
      }

      const newUser = {
        id: String(users.length + 1),
        ...input,
        createdAt: new Date(),
        createdBy: ctx.user.id
      };
      
      users.push(newUser);
      return newUser;
    }),

  delete: adminProcedure
    .input(z.object({ id: z.string() }))
    .mutation(({ input }) => {
      const userIndex = users.findIndex(u => u.id === input.id);
      if (userIndex === -1) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'User not found',
        });
      }
      
      const deletedUser = users.splice(userIndex, 1)[0];
      return deletedUser;
    })
});
```

### 3. サブスクリプション（リアルタイム更新）

```typescript
// src/server/routers/notification.router.ts
import { EventEmitter } from 'events';
import { z } from 'zod';

// イベントエミッター（実際の実装ではRedis Pub/Subなどを使用）
const ee = new EventEmitter();

export const notificationRouter = router({
  // 通知の送信
  send: protectedProcedure
    .input(z.object({
      message: z.string(),
      userId: z.string()
    }))
    .mutation(({ input }) => {
      const notification = {
        id: Date.now().toString(),
        message: input.message,
        userId: input.userId,
        timestamp: new Date()
      };
      
      // イベントを発火
      ee.emit('notification', notification);
      
      return notification;
    }),

  // 通知の購読
  onNotification: protectedProcedure
    .input(z.object({ userId: z.string() }))
    .subscription(({ input }) => {
      return new Observable<{ message: string; timestamp: Date }>((emit) => {
        const onNotification = (notification: any) => {
          if (notification.userId === input.userId) {
            emit.next({
              message: notification.message,
              timestamp: notification.timestamp
            });
          }
        };

        ee.on('notification', onNotification);

        return () => {
          ee.off('notification', onNotification);
        };
      });
    })
});
```

## Next.jsとの統合

### 1. API Routes

```typescript
// pages/api/trpc/[trpc].ts
import { createNextApiHandler } from '@trpc/server/adapters/next';
import { appRouter } from '../../../server/routers';
import { createContext } from '../../../server/trpc';

export default createNextApiHandler({
  router: appRouter,
  createContext,
  onError:
    process.env.NODE_ENV === 'development'
      ? ({ path, error }) => {
          console.error(
            `❌ tRPC failed on ${path ?? '<no-path>'}: ${error.message}`
          );
        }
      : undefined,
});
```

### 2. App Router（Next.js 13+）

```typescript
// app/api/trpc/[trpc]/route.ts
import { fetchRequestHandler } from '@trpc/server/adapters/fetch';
import { appRouter } from '../../../../server/routers';
import { createContext } from '../../../../server/trpc';

const handler = (req: Request) =>
  fetchRequestHandler({
    endpoint: '/api/trpc',
    req,
    router: appRouter,
    createContext,
  });

export { handler as GET, handler as POST };
```

### 3. クライアント設定（Next.js）

```typescript
// src/client/trpc.ts
import { createTRPCNext } from '@trpc/next';
import { httpBatchLink } from '@trpc/client';
import type { AppRouter } from '../server/routers';

export const trpc = createTRPCNext<AppRouter>({
  config() {
    return {
      links: [
        httpBatchLink({
          url: '/api/trpc',
        }),
      ],
    };
  },
  ssr: false, // SSRを無効にする場合
});
```

## パフォーマンス最適化

### 1. バッチ処理

```typescript
// 複数のクエリを同時に実行
const [users, posts, comments] = await Promise.all([
  trpc.user.getAll.query(),
  trpc.post.getAll.query(),
  trpc.comment.getAll.query()
]);
```

### 2. キャッシュ戦略

```typescript
// src/components/OptimizedUserList.tsx
import React from 'react';
import { trpcReact } from '../client/providers';

export function OptimizedUserList() {
  const { data: users, isLoading } = trpcReact.user.getAll.useQuery(
    undefined,
    {
      staleTime: 5 * 60 * 1000, // 5分間キャッシュ
      cacheTime: 10 * 60 * 1000, // 10分間メモリに保持
      refetchOnWindowFocus: false, // ウィンドウフォーカス時の再取得を無効
    }
  );

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      <h2>Users ({users?.length})</h2>
      <ul>
        {users?.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

### 3. 無限スクロール

```typescript
// src/server/routers/post.router.ts
export const postRouter = router({
  getInfinite: publicProcedure
    .input(z.object({
      limit: z.number().min(1).max(100).default(10),
      cursor: z.string().nullish(),
    }))
    .query(async ({ input }) => {
      const { limit, cursor } = input;
      const items = await getPosts({
        limit: limit + 1,
        cursor,
      });
      
      let nextCursor: typeof cursor | undefined = undefined;
      if (items.length > limit) {
        const nextItem = items.pop();
        nextCursor = nextItem?.id;
      }

      return {
        items,
        nextCursor,
      };
    }),
});
```

## まとめ

tRPCを使うことで、以下のような利点が得られます：

### 主な利点

1. **型安全性**: フロントエンドとバックエンド間で完全な型安全性を実現
2. **開発効率**: 自動補完とIntelliSenseによる高速開発
3. **保守性**: 型定義の変更が自動的に全体に反映
4. **パフォーマンス**: バッチ処理とキャッシュによる最適化
5. **学習コスト**: 既存のTypeScript知識で始められる

### 実践のポイント

- **段階的な導入**: 既存プロジェクトに徐々に導入
- **適切なバリデーション**: Zodを使った入力検証
- **エラーハンドリング**: 適切なエラーコードとメッセージ
- **パフォーマンス**: キャッシュ戦略とバッチ処理の活用
- **セキュリティ**: 認証・認可の適切な実装

[tRPC公式サイト](https://trpc.io/)では、さらに詳細な情報と実践的な例が提供されています。型安全なAPI開発により、開発効率を大幅に向上させることができるでしょう。

従来のREST APIやGraphQLと比較して、tRPCはTypeScriptエコシステムに特化した優れた選択肢です。フルスタックTypeScriptアプリケーションの開発において、tRPCは強力なツールとなるでしょう。
