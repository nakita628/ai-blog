---
date: 2025-09-11
title: TypeScript 標準メソッド完全ガイド：配列・文字列・オブジェクトの実践的使い方
description: TypeScriptの標準メソッドを詳しく解説。配列操作、文字列処理、オブジェクト操作、数値計算など、日常的に使用されるメソッドを実践的な例と共に説明します。初心者から上級者まで役立つ内容です。
tags:
  - typescript
  - javascript
  - standard-methods
  - array-methods
  - string-methods
  - object-methods
  - programming
  - web-development
prev:
  text: 'Cloud Run に GitHub Actions で Next.js をデプロイする完全ガイド'
  link: '/posts/2025/09/10'
next:
  text: '簿記のアルゴリズムをTypeScriptで表現：会計システムの実装ガイド'
  link: '/posts/2025/09/12'
---

# TypeScript 標準メソッド完全ガイド：配列・文字列・オブジェクトの実践的使い方

TypeScriptは、JavaScriptの標準メソッドを型安全に使用できる言語です。この記事では、日常的に使用される重要なメソッドを実践的な例と共に詳しく解説します。

## 配列メソッド

### 基本的な配列操作

```typescript
// 配列の作成と初期化
const numbers: number[] = [1, 2, 3, 4, 5]
const fruits: string[] = ['apple', 'banana', 'orange']

// 配列の長さ
console.log(numbers.length) // 5

// 要素の追加
numbers.push(6) // 末尾に追加
numbers.unshift(0) // 先頭に追加

// 要素の削除
const lastElement = numbers.pop() // 末尾から削除
const firstElement = numbers.shift() // 先頭から削除

// 要素の検索
const index = numbers.indexOf(3) // インデックスを取得
const found = numbers.find((n) => n > 3) // 条件に合う最初の要素
const exists = numbers.includes(4) // 要素の存在確認
```

### 配列の変換メソッド

```typescript
// map: 各要素を変換
const doubled = numbers.map((n) => n * 2)
console.log(doubled) // [2, 4, 6, 8, 10]

// filter: 条件に合う要素を抽出
const evenNumbers = numbers.filter((n) => n % 2 === 0)
console.log(evenNumbers) // [2, 4]

// reduce: 配列を単一の値に集約
const sum = numbers.reduce((acc, curr) => acc + curr, 0)
console.log(sum) // 15

// reduceRight: 右から左に処理
const concatenated = numbers.reduceRight((acc, curr) => acc + curr.toString(), '')
console.log(concatenated) // "54321"
```

### 配列の検索と判定

```typescript
// some: 少なくとも1つの要素が条件を満たすか
const hasEven = numbers.some((n) => n % 2 === 0)
console.log(hasEven) // true

// every: すべての要素が条件を満たすか
const allPositive = numbers.every((n) => n > 0)
console.log(allPositive) // true

// findIndex: 条件に合う最初の要素のインデックス
const firstEvenIndex = numbers.findIndex((n) => n % 2 === 0)
console.log(firstEvenIndex) // 1

// findLast: 条件に合う最後の要素
const lastEven = numbers.findLast((n) => n % 2 === 0)
console.log(lastEven) // 4

// findLastIndex: 条件に合う最後の要素のインデックス
const lastEvenIndex = numbers.findLastIndex((n) => n % 2 === 0)
console.log(lastEvenIndex) // 3
```

### 配列の並び替えと操作

```typescript
// sort: 配列を並び替え
const unsorted = [3, 1, 4, 1, 5, 9, 2, 6]
const sorted = [...unsorted].sort((a, b) => a - b)
console.log(sorted) // [1, 1, 2, 3, 4, 5, 6, 9]

// reverse: 配列を逆順にする
const reversed = [...numbers].reverse()
console.log(reversed) // [5, 4, 3, 2, 1]

// slice: 配列の一部を抽出
const middle = numbers.slice(1, 4)
console.log(middle) // [2, 3, 4]

// splice: 配列の要素を削除・挿入
const copy = [...numbers]
const removed = copy.splice(1, 2, 10, 11) // インデックス1から2個削除し、10,11を挿入
console.log(copy) // [1, 10, 11, 4, 5]
console.log(removed) // [2, 3]
```

### 配列の結合と分割

```typescript
// concat: 配列を結合
const arr1 = [1, 2, 3]
const arr2 = [4, 5, 6]
const combined = arr1.concat(arr2)
console.log(combined) // [1, 2, 3, 4, 5, 6]

// join: 配列を文字列に結合
const joined = fruits.join(', ')
console.log(joined) // "apple, banana, orange"

// flat: 多次元配列を平坦化
const nested = [1, [2, 3], [4, [5, 6]]]
const flattened = nested.flat(2)
console.log(flattened) // [1, 2, 3, 4, 5, 6]

// flatMap: map + flat の組み合わせ
const words = ['hello world', 'typescript is great']
const letters = words.flatMap((word) => word.split(' '))
console.log(letters) // ['hello', 'world', 'typescript', 'is', 'great']
```

## 文字列メソッド

### 基本的な文字列操作

```typescript
const text = 'Hello, TypeScript!'
const name = '  John Doe  '

// 長さの取得
console.log(text.length) // 18

// 大文字・小文字の変換
console.log(text.toUpperCase()) // "HELLO, TYPESCRIPT!"
console.log(text.toLowerCase()) // "hello, typescript!"

// 前後の空白を削除
console.log(name.trim()) // "John Doe"
console.log(name.trimStart()) // "John Doe  "
console.log(name.trimEnd()) // "  John Doe"
```

### 文字列の検索と置換

```typescript
const sentence = 'The quick brown fox jumps over the lazy dog'

// 文字列の検索
console.log(sentence.indexOf('fox')) // 16
console.log(sentence.lastIndexOf('o')) // 42
console.log(sentence.includes('brown')) // true
console.log(sentence.startsWith('The')) // true
console.log(sentence.endsWith('dog')) // true

// 文字列の置換
const replaced = sentence.replace('fox', 'cat')
console.log(replaced) // "The quick brown cat jumps over the lazy dog"

// 正規表現を使った置換
const regexReplaced = sentence.replace(/o/g, '0')
console.log(regexReplaced) // "The quick br0wn f0x jumps 0ver the lazy d0g"
```

### 文字列の分割と結合

```typescript
const csv = 'apple,banana,orange,grape'
const words = 'hello world typescript'

// 文字列の分割
const fruits = csv.split(',')
console.log(fruits) // ['apple', 'banana', 'orange', 'grape']

const wordArray = words.split(' ')
console.log(wordArray) // ['hello', 'world', 'typescript']

// 文字列の結合
const joined = fruits.join(' | ')
console.log(joined) // "apple | banana | orange | grape"
```

### 文字列の抽出と部分文字列

```typescript
const fullText = 'TypeScript is awesome!'

// 部分文字列の取得
console.log(fullText.substring(0, 10)) // "TypeScript"
console.log(fullText.slice(0, 10)) // "TypeScript"
console.log(fullText.slice(-8)) // "awesome!"

// 文字の取得
console.log(fullText.charAt(0)) // "T"
console.log(fullText[0]) // "T" (配列記法)

// 文字コードの取得
console.log(fullText.charCodeAt(0)) // 84 (Tの文字コード)
```

## オブジェクトメソッド

### オブジェクトの基本操作

```typescript
interface User {
  id: number
  name: string
  email: string
  age: number
}

const user: User = {
  id: 1,
  name: 'John Doe',
  email: 'john@example.com',
  age: 30,
}

// キーの取得
const keys = Object.keys(user)
console.log(keys) // ['id', 'name', 'email', 'age']

// 値の取得
const values = Object.values(user)
console.log(values) // [1, 'John Doe', 'john@example.com', 30]

// キーと値のペアの取得
const entries = Object.entries(user)
console.log(entries) // [['id', 1], ['name', 'John Doe'], ...]

// オブジェクトの作成
const newUser = Object.fromEntries(entries)
console.log(newUser) // { id: 1, name: 'John Doe', ... }
```

### オブジェクトのコピーとマージ

```typescript
// 浅いコピー
const userCopy = { ...user }
const userCopy2 = Object.assign({}, user)

// 深いコピー（簡単な方法）
const deepCopy = JSON.parse(JSON.stringify(user))

// オブジェクトのマージ
const additionalInfo = { city: 'Tokyo', country: 'Japan' }
const mergedUser = { ...user, ...additionalInfo }
console.log(mergedUser) // { id: 1, name: 'John Doe', ..., city: 'Tokyo', country: 'Japan' }

// Object.assign を使ったマージ
const mergedUser2 = Object.assign({}, user, additionalInfo)
```

### オブジェクトの凍結と封印

```typescript
// Object.freeze: オブジェクトを凍結（変更不可）
const frozenUser = Object.freeze({ ...user })
// frozenUser.name = 'Jane'; // エラーまたは無視される

// Object.seal: オブジェクトを封印（プロパティの追加・削除不可）
const sealedUser = Object.seal({ ...user })
// sealedUser.newProp = 'value'; // エラーまたは無視される

// 凍結・封印の確認
console.log(Object.isFrozen(frozenUser)) // true
console.log(Object.isSealed(sealedUser)) // true
```

## 数値メソッド

### 数値の変換とフォーマット

```typescript
const num = 123.456789

// 小数点以下の桁数指定
console.log(num.toFixed(2)) // "123.46"
console.log(num.toFixed(0)) // "123"

// 指数表記
console.log(num.toExponential(2)) // "1.23e+2"

// 有効桁数指定
console.log(num.toPrecision(4)) // "123.5"

// 文字列への変換
console.log(num.toString()) // "123.456789"
console.log(num.toString(16)) // "7b.74bc6a7ef9db" (16進数)
```

### 数値の検証と変換

```typescript
// 数値の検証
console.log(Number.isInteger(42)) // true
console.log(Number.isInteger(42.5)) // false
console.log(Number.isNaN(NaN)) // true
console.log(Number.isFinite(42)) // true
console.log(Number.isFinite(Infinity)) // false

// 文字列から数値への変換
console.log(Number('123')) // 123
console.log(Number('123.45')) // 123.45
console.log(Number('abc')) // NaN

// parseInt, parseFloat
console.log(parseInt('123px')) // 123
console.log(parseFloat('123.45em')) // 123.45
```

## 日付メソッド

### 日付の作成と操作

```typescript
// 現在の日時
const now = new Date()
console.log(now) // 現在の日時

// 特定の日時の作成
const specificDate = new Date('2024-01-15')
const dateWithTime = new Date(2024, 0, 15, 14, 30, 0) // 年, 月(0-11), 日, 時, 分, 秒

// 日付の取得
console.log(now.getFullYear()) // 年
console.log(now.getMonth()) // 月 (0-11)
console.log(now.getDate()) // 日
console.log(now.getDay()) // 曜日 (0-6)
console.log(now.getHours()) // 時
console.log(now.getMinutes()) // 分
console.log(now.getSeconds()) // 秒
console.log(now.getMilliseconds()) // ミリ秒
```

### 日付のフォーマット

```typescript
const date = new Date('2024-01-15T14:30:00')

// 文字列への変換
console.log(date.toString()) // "Mon Jan 15 2024 14:30:00 GMT+0900 (JST)"
console.log(date.toDateString()) // "Mon Jan 15 2024"
console.log(date.toTimeString()) // "14:30:00 GMT+0900 (JST)"
console.log(date.toISOString()) // "2024-01-15T05:30:00.000Z"
console.log(date.toLocaleDateString('ja-JP')) // "2024/1/15"
console.log(date.toLocaleTimeString('ja-JP')) // "14:30:00"
```

## 実践的な使用例

### 配列操作の実例

```typescript
// ユーザーデータの処理
interface User {
  id: number
  name: string
  age: number
  email: string
  isActive: boolean
}

const users: User[] = [
  { id: 1, name: 'Alice', age: 25, email: 'alice@example.com', isActive: true },
  { id: 2, name: 'Bob', age: 30, email: 'bob@example.com', isActive: false },
  { id: 3, name: 'Charlie', age: 35, email: 'charlie@example.com', isActive: true },
  { id: 4, name: 'Diana', age: 28, email: 'diana@example.com', isActive: true },
]

// アクティブなユーザーの名前を取得
const activeUserNames = users.filter((user) => user.isActive).map((user) => user.name)
console.log(activeUserNames) // ['Alice', 'Charlie', 'Diana']

// 年齢の平均を計算
const averageAge = users.reduce((sum, user) => sum + user.age, 0) / users.length
console.log(averageAge) // 29.5

// ユーザーを年齢でグループ化
const usersByAge = users.reduce(
  (groups, user) => {
    const ageGroup = Math.floor(user.age / 10) * 10
    if (!groups[ageGroup]) {
      groups[ageGroup] = []
    }
    groups[ageGroup].push(user)
    return groups
  },
  {} as Record<number, User[]>,
)
console.log(usersByAge)
```

### 文字列処理の実例

```typescript
// テキストの正規化と検索
const text = '  Hello, World! This is a sample text.  '

// テキストの正規化
const normalizedText = text
  .trim()
  .toLowerCase()
  .replace(/[^\w\s]/g, '') // 句読点を削除
  .replace(/\s+/g, ' ') // 複数の空白を1つに
console.log(normalizedText) // "hello world this is a sample text"

// 単語の頻度を計算
const words = normalizedText.split(' ')
const wordFrequency = words.reduce(
  (freq, word) => {
    freq[word] = (freq[word] || 0) + 1
    return freq
  },
  {} as Record<string, number>,
)
console.log(wordFrequency) // { hello: 1, world: 1, this: 1, ... }
```

### オブジェクト操作の実例

```typescript
// 設定オブジェクトのマージ
interface Config {
  apiUrl: string
  timeout: number
  retries: number
  debug: boolean
}

const defaultConfig: Config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
  retries: 3,
  debug: false,
}

const userConfig: Partial<Config> = {
  apiUrl: 'https://api.myapp.com',
  debug: true,
}

// 設定のマージ
const finalConfig: Config = { ...defaultConfig, ...userConfig }
console.log(finalConfig)
// {
//   apiUrl: 'https://api.myapp.com',
//   timeout: 5000,
//   retries: 3,
//   debug: true
// }

// 設定の検証
const isValidConfig = (config: any): config is Config => {
  return (
    typeof config.apiUrl === 'string' &&
    typeof config.timeout === 'number' &&
    typeof config.retries === 'number' &&
    typeof config.debug === 'boolean'
  )
}

if (isValidConfig(finalConfig)) {
  console.log('設定が有効です')
}
```

## パフォーマンスの考慮事項

### 効率的な配列操作

```typescript
// 非効率な例
const numbers = [1, 2, 3, 4, 5]
const doubled = []
for (let i = 0; i < numbers.length; i++) {
  doubled.push(numbers[i] * 2)
}

// 効率的な例
const doubledEfficient = numbers.map((n) => n * 2)

// 大きな配列での処理
const largeArray = Array.from({ length: 1000000 }, (_, i) => i)

// メモリ効率的な処理
const processed = largeArray
  .filter((n) => n % 2 === 0)
  .map((n) => n * 2)
  .slice(0, 100) // 必要な分だけ取得
```

### 文字列操作の最適化

```typescript
// 非効率な文字列結合
let result = ''
for (let i = 0; i < 1000; i++) {
  result += 'item' + i + ','
}

// 効率的な文字列結合
const items = Array.from({ length: 1000 }, (_, i) => 'item' + i)
const resultEfficient = items.join(',')
```

## まとめ

TypeScriptの標準メソッドは、効率的で読みやすいコードを書くために不可欠です：

### 主要なカテゴリ

1. **配列メソッド**: データの変換、検索、フィルタリング
2. **文字列メソッド**: テキスト処理、検索、置換
3. **オブジェクトメソッド**: プロパティの操作、コピー、マージ
4. **数値メソッド**: 数値の変換、フォーマット、検証
5. **日付メソッド**: 日時の操作、フォーマット

### 実践のポイント

- **適切なメソッドの選択**: 目的に応じた最適なメソッドを使用
- **メソッドチェーン**: 複数のメソッドを組み合わせた効率的な処理
- **型安全性**: TypeScriptの型システムを活用した安全なコード
- **パフォーマンス**: 大量のデータ処理時の効率性を考慮

これらのメソッドを適切に使用することで、保守性が高く、効率的なTypeScriptコードを書くことができます。
