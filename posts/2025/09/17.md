---
date: 2025-09-17
title: ReactとDrizzleでカンバンボードのドラッグアンドドロップを実装する
description: React、Drizzle ORM、@dnd-kitを使用してカンバンボードのドラッグアンドドロップ機能を実装する方法を解説。型安全なデータベース操作とリアルタイムUI更新を組み合わせた実践的な開発ガイド。
tags:
  - react
  - drizzle-orm
  - drag-and-drop
  - kanban
  - typescript
  - database
prev:
  text: 'HTMLとCSSのみでサイドバーを実装する：JavaScript不要のレスポンシブデザイン'
  link: '/posts/2025/09/16'
next: false
---

# ReactとDrizzleでカンバンボードのドラッグアンドドロップを実装する

React、Drizzle ORM、@dnd-kitを使用してカンバンボードのドラッグアンドドロップ機能を実装する方法を解説します。型安全なデータベース操作とリアルタイムUI更新を組み合わせた実践的な開発ガイドです。

## なぜReactとDrizzleでカンバンボードなのか

ReactとDrizzleを組み合わせたカンバンボードには以下のメリットがあります：

- **型安全性**: TypeScriptとDrizzleの組み合わせで実行時エラーを削減
- **リアルタイム更新**: ドラッグアンドドロップ時の即座なUI反映
- **データベース同期**: 操作が自動的にデータベースに反映
- **アクセシビリティ**: @dnd-kitによるキーボード操作対応
- **パフォーマンス**: 最適化されたレンダリングとデータベースクエリ

## プロジェクト構成

まず、必要なパッケージをインストールします：

```bash
npm install react @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
npm install drizzle-orm drizzle-kit
npm install sqlite3 better-sqlite3
npm install -D @types/react @types/react-dom typescript
```

## データベーススキーマの定義

Drizzleでカンバンボードのデータ構造を定義します：

```typescript
// src/db/schema.ts
import { sqliteTable, text, integer, real } from 'drizzle-orm/sqlite-core'

export const boards = sqliteTable('boards', {
  id: text('id').primaryKey(),
  title: text('title').notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
})

export const columns = sqliteTable('columns', {
  id: text('id').primaryKey(),
  boardId: text('board_id')
    .notNull()
    .references(() => boards.id),
  title: text('title').notNull(),
  position: real('position').notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
})

export const tasks = sqliteTable('tasks', {
  id: text('id').primaryKey(),
  columnId: text('column_id')
    .notNull()
    .references(() => columns.id),
  title: text('title').notNull(),
  description: text('description'),
  position: real('position').notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
})
```

## データベース接続の設定

Drizzleのデータベース接続を設定します：

```typescript
// src/db/index.ts
import { drizzle } from 'drizzle-orm/better-sqlite3'
import Database from 'better-sqlite3'
import { boards, columns, tasks } from './schema'

const sqlite = new Database('kanban.db')
export const db = drizzle(sqlite)

// 初期データの挿入
export async function initializeDatabase() {
  // テーブル作成
  sqlite.exec(`
    CREATE TABLE IF NOT EXISTS boards (
      id TEXT PRIMARY KEY,
      title TEXT NOT NULL,
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL
    );
    
    CREATE TABLE IF NOT EXISTS columns (
      id TEXT PRIMARY KEY,
      board_id TEXT NOT NULL,
      title TEXT NOT NULL,
      position REAL NOT NULL,
      created_at INTEGER NOT NULL,
      FOREIGN KEY (board_id) REFERENCES boards (id)
    );
    
    CREATE TABLE IF NOT EXISTS tasks (
      id TEXT PRIMARY KEY,
      column_id TEXT NOT NULL,
      title TEXT NOT NULL,
      description TEXT,
      position REAL NOT NULL,
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL,
      FOREIGN KEY (column_id) REFERENCES columns (id)
    );
  `)
}
```

## Reactコンポーネントの実装

カンバンボードのメインコンポーネントを作成します：

```typescript
// src/components/KanbanBoard.tsx
import React, { useState, useEffect } from 'react';
import {
  DndContext,
  DragEndEvent,
  DragOverlay,
  DragStartEvent,
  PointerSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { Column } from './Column';
import { Task } from './Task';
import { db } from '../db';
import { columns, tasks } from '../db/schema';
import { eq } from 'drizzle-orm';

interface Board {
  id: string;
  title: string;
  columns: Column[];
}

interface Column {
  id: string;
  title: string;
  position: number;
  tasks: Task[];
}

interface Task {
  id: string;
  title: string;
  description?: string;
  position: number;
  columnId: string;
}

export const KanbanBoard: React.FC = () => {
  const [board, setBoard] = useState<Board | null>(null);
  const [activeTask, setActiveTask] = useState<Task | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    })
  );

  useEffect(() => {
    loadBoard();
  }, []);

  const loadBoard = async () => {
    try {
      // ボードデータを取得（実際の実装では動的に選択）
      const boardId = 'default-board';

      const boardColumns = await db
        .select()
        .from(columns)
        .where(eq(columns.boardId, boardId))
        .orderBy(columns.position);

      const boardWithTasks = await Promise.all(
        boardColumns.map(async (column) => {
          const columnTasks = await db
            .select()
            .from(tasks)
            .where(eq(tasks.columnId, column.id))
            .orderBy(tasks.position);

          return {
            ...column,
            tasks: columnTasks,
          };
        })
      );

      setBoard({
        id: boardId,
        title: 'My Kanban Board',
        columns: boardWithTasks,
      });
    } catch (error) {
      console.error('Failed to load board:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleDragStart = (event: DragStartEvent) => {
    const { active } = event;
    const task = findTask(active.id as string);
    setActiveTask(task);
  };

  const handleDragEnd = async (event: DragEndEvent) => {
    const { active, over } = event;
    setActiveTask(null);

    if (!over || !board) return;

    const activeTask = findTask(active.id as string);
    const overColumn = findColumn(over.id as string);

    if (!activeTask || !overColumn) return;

    // 同じカラム内での移動
    if (activeTask.columnId === overColumn.id) {
      const newPosition = calculateNewPosition(
        overColumn.tasks,
        active.id as string,
        over.id as string
      );

      await updateTaskPosition(active.id as string, newPosition);
    } else {
      // 異なるカラムへの移動
      const newPosition = calculateNewPosition(
        overColumn.tasks,
        active.id as string,
        over.id as string
      );

      await moveTaskToColumn(
        active.id as string,
        overColumn.id,
        newPosition
      );
    }

    // UIを更新
    loadBoard();
  };

  const findTask = (taskId: string): Task | null => {
    if (!board) return null;

    for (const column of board.columns) {
      const task = column.tasks.find(t => t.id === taskId);
      if (task) return task;
    }
    return null;
  };

  const findColumn = (columnId: string): Column | null => {
    if (!board) return null;
    return board.columns.find(c => c.id === columnId) || null;
  };

  const calculateNewPosition = (
    tasks: Task[],
    activeId: string,
    overId: string
  ): number => {
    const activeIndex = tasks.findIndex(t => t.id === activeId);
    const overIndex = tasks.findIndex(t => t.id === overId);

    if (activeIndex === -1) return tasks.length;

    if (overIndex === -1) {
      return activeIndex < tasks.length - 1
        ? (tasks[activeIndex + 1].position + tasks[activeIndex].position) / 2
        : tasks[activeIndex].position + 1;
    }

    return (tasks[overIndex].position +
      (overIndex > 0 ? tasks[overIndex - 1].position : 0)) / 2;
  };

  const updateTaskPosition = async (taskId: string, position: number) => {
    await db
      .update(tasks)
      .set({
        position,
        updatedAt: new Date()
      })
      .where(eq(tasks.id, taskId));
  };

  const moveTaskToColumn = async (
    taskId: string,
    columnId: string,
    position: number
  ) => {
    await db
      .update(tasks)
      .set({
        columnId,
        position,
        updatedAt: new Date()
      })
      .where(eq(tasks.id, taskId));
  };

  if (isLoading) {
    return <div className="kanban-loading">Loading...</div>;
  }

  if (!board) {
    return <div className="kanban-error">Failed to load board</div>;
  }

  return (
    <div className="kanban-board">
      <h1 className="kanban-title">{board.title}</h1>

      <DndContext
        sensors={sensors}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
      >
        <div className="kanban-columns">
          {board.columns.map((column) => (
            <Column key={column.id} column={column} />
          ))}
        </div>

        <DragOverlay>
          {activeTask ? <Task task={activeTask} isDragging /> : null}
        </DragOverlay>
      </DndContext>
    </div>
  );
};
```

## カラムコンポーネントの実装

カラム（列）を表示するコンポーネントを作成します：

```typescript
// src/components/Column.tsx
import React from 'react';
import { useDroppable } from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { Task } from './Task';

interface ColumnProps {
  column: {
    id: string;
    title: string;
    position: number;
    tasks: Array<{
      id: string;
      title: string;
      description?: string;
      position: number;
      columnId: string;
    }>;
  };
}

export const Column: React.FC<ColumnProps> = ({ column }) => {
  const { setNodeRef } = useDroppable({
    id: column.id,
  });

  const taskIds = column.tasks.map(task => task.id);

  return (
    <div className="kanban-column" ref={setNodeRef}>
      <div className="column-header">
        <h3 className="column-title">{column.title}</h3>
        <span className="task-count">{column.tasks.length}</span>
      </div>

      <SortableContext
        items={taskIds}
        strategy={verticalListSortingStrategy}
      >
        <div className="column-tasks">
          {column.tasks.map((task) => (
            <Task key={task.id} task={task} />
          ))}
        </div>
      </SortableContext>
    </div>
  );
};
```

## タスクコンポーネントの実装

ドラッグ可能なタスクコンポーネントを作成します：

```typescript
// src/components/Task.tsx
import React from 'react';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

interface TaskProps {
  task: {
    id: string;
    title: string;
    description?: string;
    position: number;
    columnId: string;
  };
  isDragging?: boolean;
}

export const Task: React.FC<TaskProps> = ({ task, isDragging = false }) => {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging: isSortableDragging,
  } = useSortable({ id: task.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isSortableDragging ? 0.5 : 1,
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      {...attributes}
      {...listeners}
      className={`task ${isDragging ? 'task-dragging' : ''}`}
    >
      <div className="task-header">
        <h4 className="task-title">{task.title}</h4>
      </div>
      {task.description && (
        <p className="task-description">{task.description}</p>
      )}
    </div>
  );
};
```

## CSSスタイリング

カンバンボードのスタイリングを実装します：

```css
/* src/styles/kanban.css */
.kanban-board {
  padding: 2rem;
  background: #f5f7fa;
  min-height: 100vh;
}

.kanban-title {
  font-size: 2rem;
  font-weight: bold;
  color: #2d3748;
  margin-bottom: 2rem;
  text-align: center;
}

.kanban-columns {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1.5rem;
  max-width: 1400px;
  margin: 0 auto;
}

.kanban-column {
  background: white;
  border-radius: 12px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  padding: 1.5rem;
  min-height: 500px;
}

.column-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 2px solid #e2e8f0;
}

.column-title {
  font-size: 1.25rem;
  font-weight: 600;
  color: #2d3748;
  margin: 0;
}

.task-count {
  background: #4299e1;
  color: white;
  padding: 0.25rem 0.75rem;
  border-radius: 20px;
  font-size: 0.875rem;
  font-weight: 500;
}

.column-tasks {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  min-height: 400px;
}

.task {
  background: white;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  padding: 1rem;
  cursor: grab;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.task:hover {
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  transform: translateY(-2px);
}

.task:active {
  cursor: grabbing;
}

.task-dragging {
  opacity: 0.5;
  transform: rotate(5deg);
}

.task-header {
  margin-bottom: 0.5rem;
}

.task-title {
  font-size: 1rem;
  font-weight: 600;
  color: #2d3748;
  margin: 0;
  line-height: 1.4;
}

.task-description {
  font-size: 0.875rem;
  color: #718096;
  margin: 0;
  line-height: 1.5;
}

.kanban-loading {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 200px;
  font-size: 1.125rem;
  color: #718096;
}

.kanban-error {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 200px;
  font-size: 1.125rem;
  color: #e53e3e;
}

/* レスポンシブ対応 */
@media (max-width: 768px) {
  .kanban-board {
    padding: 1rem;
  }

  .kanban-columns {
    grid-template-columns: 1fr;
    gap: 1rem;
  }

  .kanban-column {
    padding: 1rem;
  }

  .column-tasks {
    min-height: 300px;
  }
}

/* ドラッグ中の視覚的フィードバック */
.kanban-column.drag-over {
  background: #f0f9ff;
  border: 2px dashed #4299e1;
}

.task.drag-over {
  background: #f0f9ff;
  border-color: #4299e1;
}
```

## 初期データの設定

データベースに初期データを挿入する関数を作成します：

```typescript
// src/db/seed.ts
import { db } from './index'
import { boards, columns, tasks } from './schema'

export async function seedDatabase() {
  try {
    // ボードを作成
    const boardId = 'default-board'
    await db.insert(boards).values({
      id: boardId,
      title: 'My Kanban Board',
      createdAt: new Date(),
      updatedAt: new Date(),
    })

    // カラムを作成
    const todoColumn = {
      id: 'todo-column',
      boardId,
      title: 'To Do',
      position: 1,
      createdAt: new Date(),
    }

    const inProgressColumn = {
      id: 'in-progress-column',
      boardId,
      title: 'In Progress',
      position: 2,
      createdAt: new Date(),
    }

    const doneColumn = {
      id: 'done-column',
      boardId,
      title: 'Done',
      position: 3,
      createdAt: new Date(),
    }

    await db.insert(columns).values([todoColumn, inProgressColumn, doneColumn])

    // サンプルタスクを作成
    const sampleTasks = [
      {
        id: 'task-1',
        columnId: 'todo-column',
        title: 'プロジェクト計画を立てる',
        description: '要件定義とスケジュールの策定',
        position: 1,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 'task-2',
        columnId: 'todo-column',
        title: 'UIデザインを作成',
        description: 'ワイヤーフレームとモックアップの作成',
        position: 2,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 'task-3',
        columnId: 'in-progress-column',
        title: 'データベース設計',
        description: 'ER図とテーブル設計の実装',
        position: 1,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        id: 'task-4',
        columnId: 'done-column',
        title: '開発環境の構築',
        description: 'DockerとCI/CDパイプラインの設定',
        position: 1,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ]

    await db.insert(tasks).values(sampleTasks)

    console.log('Database seeded successfully!')
  } catch (error) {
    console.error('Failed to seed database:', error)
  }
}
```

## メインアプリケーションの統合

すべてのコンポーネントを統合したメインアプリケーションを作成します：

```typescript
// src/App.tsx
import React, { useEffect } from 'react';
import { KanbanBoard } from './components/KanbanBoard';
import { initializeDatabase, seedDatabase } from './db';
import './styles/kanban.css';

function App() {
  useEffect(() => {
    const setupDatabase = async () => {
      await initializeDatabase();
      await seedDatabase();
    };

    setupDatabase();
  }, []);

  return (
    <div className="App">
      <KanbanBoard />
    </div>
  );
}

export default App;
```

## パフォーマンス最適化

大量のタスクを扱う場合の最適化手法：

```typescript
// src/hooks/useOptimisticUpdate.ts
import { useState, useCallback } from 'react'

export const useOptimisticUpdate = () => {
  const [optimisticState, setOptimisticState] = useState<any>(null)

  const updateOptimistically = useCallback(
    async (updateFn: () => Promise<void>, optimisticUpdate: (prev: any) => any) => {
      // 楽観的更新
      setOptimisticState(optimisticUpdate)

      try {
        await updateFn()
      } catch (error) {
        // エラー時は元に戻す
        setOptimisticState(null)
        throw error
      }
    },
    [],
  )

  return { optimisticState, updateOptimistically }
}
```

## まとめ

ReactとDrizzleを使用したカンバンボードのドラッグアンドドロップ機能の実装方法を解説しました。主なポイントは以下の通りです：

- **型安全性**: TypeScriptとDrizzleの組み合わせで実行時エラーを削減
- **リアルタイム更新**: @dnd-kitによる滑らかなドラッグアンドドロップ体験
- **データベース同期**: 操作が自動的にSQLiteデータベースに反映
- **レスポンシブデザイン**: モバイルデバイスでも快適に操作可能
- **パフォーマンス**: 楽観的更新による高速なUI応答

この実装により、型安全で高性能なカンバンボードアプリケーションを構築できます。プロジェクトの要件に応じて、タスクの追加・編集機能やユーザー認証などを拡張してご活用ください。

## 次のステップ

- タスクの追加・編集・削除機能の実装
- ユーザー認証とマルチユーザー対応
- リアルタイム同期（WebSocket）
- タスクの期限設定と通知機能
- カンバンボードの共有機能
