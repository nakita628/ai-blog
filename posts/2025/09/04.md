---
date: 2025-09-04
title: React Three Fiber完全ガイド：3DグラフィックスをReactで簡単に実現する方法
description: React Three Fiber（R3F）を使った3Dグラフィックス開発の基本から応用まで解説。Three.jsの知識なしでも始められる、Reactコンポーネントベースの3D開発手法。
tags:
  - react
  - react-three-fiber
  - three-js
  - 3d-graphics
  - webgl
  - frontend
  - web-development
  - 3d-animation
prev:
  text: 'TanStack Router × Zod：型安全なルーティングとバリデーションの完全ガイド'
  link: '/posts/2025/09/03'
next:
  text: 'tRPC完全ガイド：型安全なAPI開発で開発効率を最大化する方法'
  link: '/posts/2025/09/06'
---

# React Three Fiber完全ガイド：3DグラフィックスをReactで簡単に実現する方法

[React Three Fiber（R3F）](https://r3f.docs.pmnd.rs/getting-started/introduction)は、Three.jsをReactで宣言的に扱えるようにするライブラリです。この記事では、3Dグラフィックスの知識がなくても始められる、R3Fの基本から応用までを実践的に解説します。

## React Three Fiberとは

### 概要

React Three Fiberは、Three.jsの機能をReactコンポーネントとして表現できるライブラリです。以下の特徴があります：

- **React宣言的**: JSXで3Dシーンを構築
- **パフォーマンス**: Reactのスケジューリング機能を活用
- **制限なし**: Three.jsの全機能を利用可能
- **型安全**: TypeScript完全対応
- **エコシステム**: 豊富なサードパーティライブラリ

### 従来のThree.js vs R3F

**従来のThree.js**

```javascript
// 命令的なアプローチ
const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
const renderer = new THREE.WebGLRenderer()
const geometry = new THREE.BoxGeometry()
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 })
const cube = new THREE.Mesh(geometry, material)
scene.add(cube)
renderer.render(scene, camera)
```

**React Three Fiber**

```tsx
// 宣言的なアプローチ
function Scene() {
  return (
    <Canvas>
      <ambientLight intensity={0.5} />
      <mesh>
        <boxGeometry args={[1, 1, 1]} />
        <meshStandardMaterial color="green" />
      </mesh>
      <PerspectiveCamera makeDefault position={[0, 0, 5]} />
    </Canvas>
  )
}
```

## 基本的なセットアップ

### 1. インストール

```bash
# 基本パッケージ
npm install three @types/three @react-three/fiber

# 追加のヘルパーライブラリ（推奨）
npm install @react-three/drei

# アニメーション用
npm install @react-spring/three

# 物理演算用
npm install @react-three/cannon
```

### 2. プロジェクト構造

```
src/
├── components/
│   ├── 3d/
│   │   ├── Scene.tsx
│   │   ├── Box.tsx
│   │   ├── Sphere.tsx
│   │   └── Lighting.tsx
│   └── ui/
│       ├── Controls.tsx
│       └── Stats.tsx
├── hooks/
│   ├── useAnimation.ts
│   └── usePhysics.ts
├── utils/
│   ├── math.ts
│   └── colors.ts
└── App.tsx
```

## 最初の3Dシーン

### 1. 基本的なCanvas

```tsx
// src/components/3d/Scene.tsx
import React from 'react'
import { Canvas } from '@react-three/fiber'
import { OrbitControls } from '@react-three/drei'

const Scene: React.FC = () => {
  return (
    <div style={{ width: '100vw', height: '100vh' }}>
      <Canvas camera={{ position: [0, 0, 5], fov: 75 }} style={{ background: '#1a1a1a' }}>
        {/* 光源 */}
        <ambientLight intensity={0.5} />
        <directionalLight position={[10, 10, 5]} intensity={1} />

        {/* 3Dオブジェクト */}
        <Box position={[-1.5, 0, 0]} />
        <Sphere position={[1.5, 0, 0]} />

        {/* カメラコントロール */}
        <OrbitControls enablePan={true} enableZoom={true} enableRotate={true} />
      </Canvas>
    </div>
  )
}

export default Scene
```

### 2. 基本的な3Dオブジェクト

```tsx
// src/components/3d/Box.tsx
import React, { useRef, useState } from 'react'
import { useFrame } from '@react-three/fiber'
import { Mesh } from 'three'

interface BoxProps {
  position: [number, number, number]
  color?: string
  size?: number
}

const Box: React.FC<BoxProps> = ({ position, color = '#ff6b6b', size = 1 }) => {
  const meshRef = useRef<Mesh>(null)
  const [hovered, setHover] = useState(false)
  const [clicked, setClicked] = useState(false)

  // アニメーション（毎フレーム実行）
  useFrame((state, delta) => {
    if (meshRef.current) {
      // 回転アニメーション
      meshRef.current.rotation.x += delta * 0.5
      meshRef.current.rotation.y += delta * 0.3

      // ホバー時の浮遊アニメーション
      if (hovered) {
        meshRef.current.position.y = position[1] + Math.sin(state.clock.elapsedTime * 3) * 0.1
      }
    }
  })

  return (
    <mesh
      ref={meshRef}
      position={position}
      scale={clicked ? 1.5 : 1}
      onClick={() => setClicked(!clicked)}
      onPointerOver={() => setHover(true)}
      onPointerOut={() => setHover(false)}
    >
      <boxGeometry args={[size, size, size]} />
      <meshStandardMaterial color={hovered ? '#ffa500' : color} roughness={0.3} metalness={0.1} />
    </mesh>
  )
}

export default Box
```

### 3. 球体オブジェクト

```tsx
// src/components/3d/Sphere.tsx
import React, { useRef } from 'react'
import { useFrame } from '@react-three/fiber'
import { Mesh } from 'three'

interface SphereProps {
  position: [number, number, number]
  color?: string
  radius?: number
}

const Sphere: React.FC<SphereProps> = ({ position, color = '#4ecdc4', radius = 0.5 }) => {
  const meshRef = useRef<Mesh>(null)

  useFrame((state, delta) => {
    if (meshRef.current) {
      // 球体の回転
      meshRef.current.rotation.x += delta * 0.2
      meshRef.current.rotation.z += delta * 0.1
    }
  })

  return (
    <mesh ref={meshRef} position={position}>
      <sphereGeometry args={[radius, 32, 32]} />
      <meshStandardMaterial
        color={color}
        roughness={0.2}
        metalness={0.8}
        transparent
        opacity={0.9}
      />
    </mesh>
  )
}

export default Sphere
```

## 高度な3Dシーン

### 1. 複雑なシーンの構築

```tsx
// src/components/3d/ComplexScene.tsx
import React, { Suspense } from 'react'
import { Canvas } from '@react-three/fiber'
import { OrbitControls, Environment, Stars, Text3D, Float } from '@react-three/drei'
import { Physics, RigidBody } from '@react-three/rapier'

const ComplexScene: React.FC = () => {
  return (
    <div style={{ width: '100vw', height: '100vh' }}>
      <Canvas camera={{ position: [0, 5, 10], fov: 60 }} shadows gl={{ antialias: true }}>
        {/* 環境設定 */}
        <Environment preset="sunset" />
        <Stars radius={100} depth={50} count={5000} factor={4} />

        {/* 物理演算 */}
        <Physics gravity={[0, -9.81, 0]}>
          {/* 地面 */}
          <RigidBody type="fixed">
            <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, -2, 0]} receiveShadow>
              <planeGeometry args={[20, 20]} />
              <meshStandardMaterial color="#303030" />
            </mesh>
          </RigidBody>

          {/* 浮遊するテキスト */}
          <Float speed={2} rotationIntensity={0.5} floatIntensity={0.5}>
            <Text3D
              font="/fonts/helvetiker_regular.typeface.json"
              size={1}
              height={0.2}
              curveSegments={12}
              position={[0, 3, 0]}
            >
              Hello R3F!
              <meshStandardMaterial color="#ff6b6b" />
            </Text3D>
          </Float>

          {/* 物理オブジェクト */}
          <FallingBoxes />
        </Physics>

        {/* 光源 */}
        <Lighting />

        {/* カメラコントロール */}
        <OrbitControls
          enablePan={true}
          enableZoom={true}
          enableRotate={true}
          maxPolarAngle={Math.PI / 2}
        />
      </Canvas>
    </div>
  )
}

// 落下する箱のコンポーネント
const FallingBoxes: React.FC = () => {
  const boxes = Array.from({ length: 10 }, (_, i) => ({
    id: i,
    position: [Math.random() * 10 - 5, 10 + i * 2, Math.random() * 10 - 5] as [
      number,
      number,
      number,
    ],
    color: `hsl(${Math.random() * 360}, 70%, 50%)`,
  }))

  return (
    <>
      {boxes.map((box) => (
        <RigidBody key={box.id} position={box.position}>
          <mesh castShadow>
            <boxGeometry args={[0.5, 0.5, 0.5]} />
            <meshStandardMaterial color={box.color} />
          </mesh>
        </RigidBody>
      ))}
    </>
  )
}

export default ComplexScene
```

### 2. 高度な光源設定

```tsx
// src/components/3d/Lighting.tsx
import React, { useRef } from 'react'
import { useFrame } from '@react-three/fiber'
import { PointLight, SpotLight } from 'three'

const Lighting: React.FC = () => {
  const pointLightRef = useRef<PointLight>(null)
  const spotLightRef = useRef<SpotLight>(null)

  useFrame((state) => {
    if (pointLightRef.current) {
      // 点光源の移動
      const time = state.clock.elapsedTime
      pointLightRef.current.position.x = Math.sin(time) * 5
      pointLightRef.current.position.z = Math.cos(time) * 5
    }

    if (spotLightRef.current) {
      // スポットライトの回転
      spotLightRef.current.angle = Math.sin(state.clock.elapsedTime * 0.5) * 0.3 + 0.5
    }
  })

  return (
    <>
      {/* 環境光 */}
      <ambientLight intensity={0.2} />

      {/* 点光源 */}
      <pointLight
        ref={pointLightRef}
        position={[5, 5, 5]}
        intensity={1}
        color="#ff6b6b"
        distance={10}
        decay={2}
      />

      {/* スポットライト */}
      <spotLight
        ref={spotLightRef}
        position={[0, 10, 0]}
        angle={0.5}
        penumbra={0.5}
        intensity={1}
        castShadow
        shadow-mapSize-width={2048}
        shadow-mapSize-height={2048}
      />

      {/* 方向光 */}
      <directionalLight
        position={[-5, 5, 5]}
        intensity={0.5}
        color="#4ecdc4"
        castShadow
        shadow-camera-far={50}
        shadow-camera-left={-10}
        shadow-camera-right={10}
        shadow-camera-top={10}
        shadow-camera-bottom={-10}
      />
    </>
  )
}

export default Lighting
```

## インタラクティブな3Dコンポーネント

### 1. ドラッグ可能なオブジェクト

```tsx
// src/components/3d/DraggableObject.tsx
import React, { useRef, useState } from 'react'
import { useFrame } from '@react-three/fiber'
import { useDrag } from '@use-gesture/react'
import { useSpring, animated } from '@react-spring/three'
import { Mesh } from 'three'

interface DraggableObjectProps {
  position: [number, number, number]
  geometry: 'box' | 'sphere' | 'cylinder'
  color: string
}

const DraggableObject: React.FC<DraggableObjectProps> = ({ position, geometry, color }) => {
  const meshRef = useRef<Mesh>(null)
  const [isDragging, setIsDragging] = useState(false)

  // スプリングアニメーション
  const [spring, api] = useSpring(() => ({
    scale: 1,
    rotation: [0, 0, 0],
    config: { mass: 1, tension: 400, friction: 40 },
  }))

  // ドラッグジェスチャー
  const bind = useDrag(
    ({ active, movement: [x, y], timeStamp, event }) => {
      event?.stopPropagation()

      if (active && meshRef.current) {
        setIsDragging(true)

        // マウス位置に基づいてオブジェクトを移動
        const newX = position[0] + x * 0.01
        const newY = position[1] - y * 0.01

        meshRef.current.position.set(newX, newY, position[2])

        // スケールと回転のアニメーション
        api.start({
          scale: 1.2,
          rotation: [y * 0.01, x * 0.01, 0],
        })
      } else {
        setIsDragging(false)
        api.start({
          scale: 1,
          rotation: [0, 0, 0],
        })
      }
    },
    { pointer: { touch: true } },
  )

  useFrame((state) => {
    if (meshRef.current && !isDragging) {
      // 通常時の浮遊アニメーション
      meshRef.current.position.y = position[1] + Math.sin(state.clock.elapsedTime * 2) * 0.1
    }
  })

  const renderGeometry = () => {
    switch (geometry) {
      case 'box':
        return <boxGeometry args={[1, 1, 1]} />
      case 'sphere':
        return <sphereGeometry args={[0.5, 32, 32]} />
      case 'cylinder':
        return <cylinderGeometry args={[0.5, 0.5, 1, 32]} />
      default:
        return <boxGeometry args={[1, 1, 1]} />
    }
  }

  return (
    <animated.mesh
      ref={meshRef}
      position={position}
      scale={spring.scale}
      rotation={spring.rotation}
      {...bind()}
      castShadow
    >
      {renderGeometry()}
      <meshStandardMaterial
        color={color}
        roughness={0.3}
        metalness={0.7}
        transparent
        opacity={isDragging ? 0.8 : 1}
      />
    </animated.mesh>
  )
}

export default DraggableObject
```

### 2. 3DテキストとUI

```tsx
// src/components/3d/Text3D.tsx
import React, { useRef } from 'react'
import { useFrame } from '@react-three/fiber'
import { Text3D, Float, Html } from '@react-three/drei'
import { Group } from 'three'

interface InteractiveTextProps {
  text: string
  position: [number, number, number]
  color?: string
  size?: number
}

const InteractiveText: React.FC<InteractiveTextProps> = ({
  text,
  position,
  color = '#ffffff',
  size = 1,
}) => {
  const groupRef = useRef<Group>(null)
  const [hovered, setHover] = useState(false)

  useFrame((state) => {
    if (groupRef.current) {
      // テキストの回転
      groupRef.current.rotation.y = Math.sin(state.clock.elapsedTime * 0.5) * 0.1
    }
  })

  return (
    <group ref={groupRef} position={position}>
      <Float speed={1} rotationIntensity={0.5} floatIntensity={0.5}>
        <Text3D
          font="/fonts/helvetiker_regular.typeface.json"
          size={size}
          height={0.2}
          curveSegments={12}
          onPointerOver={() => setHover(true)}
          onPointerOut={() => setHover(false)}
        >
          {text}
          <meshStandardMaterial
            color={hovered ? '#ff6b6b' : color}
            metalness={0.8}
            roughness={0.2}
          />
        </Text3D>
      </Float>

      {/* ホバー時のHTMLオーバーレイ */}
      {hovered && (
        <Html position={[0, 2, 0]} center>
          <div
            style={{
              background: 'rgba(0, 0, 0, 0.8)',
              color: 'white',
              padding: '8px 12px',
              borderRadius: '4px',
              fontSize: '14px',
              whiteSpace: 'nowrap',
            }}
          >
            {text} - クリックして詳細を見る
          </div>
        </Html>
      )}
    </group>
  )
}

export default InteractiveText
```

## パフォーマンス最適化

### 1. インスタンス化

```tsx
// src/components/3d/InstancedObjects.tsx
import React, { useRef } from 'react'
import { useFrame } from '@react-three/fiber'
import { InstancedMesh, Object3D } from 'three'

interface InstancedObjectsProps {
  count: number
  geometry: 'box' | 'sphere'
  color: string
}

const InstancedObjects: React.FC<InstancedObjectsProps> = ({ count, geometry, color }) => {
  const instancedMeshRef = useRef<InstancedMesh>(null)
  const tempObject = useRef(new Object3D())

  useFrame((state) => {
    if (instancedMeshRef.current) {
      const time = state.clock.elapsedTime

      for (let i = 0; i < count; i++) {
        const id = i

        // 各インスタンスの位置と回転を更新
        tempObject.current.position.set(
          Math.sin(time + i * 0.1) * 5,
          Math.cos(time + i * 0.1) * 2,
          Math.sin(time * 0.5 + i * 0.1) * 3,
        )

        tempObject.current.rotation.set(time + i * 0.1, time * 0.5 + i * 0.1, time * 0.3 + i * 0.1)

        tempObject.current.updateMatrix()
        instancedMeshRef.current.setMatrixAt(id, tempObject.current.matrix)
      }

      instancedMeshRef.current.instanceMatrix.needsUpdate = true
    }
  })

  const renderGeometry = () => {
    switch (geometry) {
      case 'box':
        return <instancedBufferGeometry args={[new THREE.BoxGeometry(0.5, 0.5, 0.5), count]} />
      case 'sphere':
        return <instancedBufferGeometry args={[new THREE.SphereGeometry(0.25, 16, 16), count]} />
      default:
        return <instancedBufferGeometry args={[new THREE.BoxGeometry(0.5, 0.5, 0.5), count]} />
    }
  }

  return (
    <instancedMesh ref={instancedMeshRef} args={[undefined, undefined, count]}>
      {renderGeometry()}
      <meshStandardMaterial color={color} />
    </instancedMesh>
  )
}

export default InstancedObjects
```

### 2. レベルオブディスタンス（LOD）

```tsx
// src/components/3d/LODObject.tsx
import React from 'react'
import { LOD } from '@react-three/drei'

interface LODObjectProps {
  position: [number, number, number]
  color: string
}

const LODObject: React.FC<LODObjectProps> = ({ position, color }) => {
  return (
    <LOD position={position}>
      {/* 高品質（近距離） */}
      <mesh>
        <sphereGeometry args={[1, 64, 64]} />
        <meshStandardMaterial color={color} wireframe />
      </mesh>

      {/* 中品質（中距離） */}
      <mesh>
        <sphereGeometry args={[1, 32, 32]} />
        <meshStandardMaterial color={color} />
      </mesh>

      {/* 低品質（遠距離） */}
      <mesh>
        <sphereGeometry args={[1, 16, 16]} />
        <meshStandardMaterial color={color} />
      </mesh>
    </LOD>
  )
}

export default LODObject
```

## 実用的なアプリケーション例

### 1. 3Dプロダクトビューアー

```tsx
// src/components/3d/ProductViewer.tsx
import React, { useState } from 'react'
import { Canvas } from '@react-three/fiber'
import { OrbitControls, Environment, useGLTF } from '@react-three/drei'

interface ProductViewerProps {
  modelPath: string
  backgroundColor?: string
}

const ProductViewer: React.FC<ProductViewerProps> = ({
  modelPath,
  backgroundColor = '#f0f0f0',
}) => {
  const [currentView, setCurrentView] = useState<'front' | 'side' | 'top'>('front')

  const views = {
    front: [0, 0, 5],
    side: [5, 0, 0],
    top: [0, 5, 0],
  }

  return (
    <div style={{ width: '100%', height: '500px' }}>
      <Canvas
        camera={{ position: views[currentView], fov: 50 }}
        style={{ background: backgroundColor }}
      >
        <Environment preset="studio" />

        {/* 3Dモデル */}
        <Model modelPath={modelPath} />

        {/* 光源 */}
        <ambientLight intensity={0.5} />
        <spotLight position={[10, 10, 10]} angle={0.15} penumbra={1} />

        {/* カメラコントロール */}
        <OrbitControls
          enablePan={false}
          enableZoom={true}
          enableRotate={true}
          maxPolarAngle={Math.PI}
          minPolarAngle={0}
        />
      </Canvas>

      {/* ビュー切り替えボタン */}
      <div
        style={{
          position: 'absolute',
          bottom: '20px',
          left: '50%',
          transform: 'translateX(-50%)',
          display: 'flex',
          gap: '10px',
        }}
      >
        {Object.keys(views).map((view) => (
          <button
            key={view}
            onClick={() => setCurrentView(view as keyof typeof views)}
            style={{
              padding: '8px 16px',
              background: currentView === view ? '#007bff' : '#6c757d',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            {view.charAt(0).toUpperCase() + view.slice(1)}
          </button>
        ))}
      </div>
    </div>
  )
}

// 3Dモデルコンポーネント
const Model: React.FC<{ modelPath: string }> = ({ modelPath }) => {
  const { scene } = useGLTF(modelPath)

  return <primitive object={scene} scale={[1, 1, 1]} />
}

export default ProductViewer
```

### 2. インタラクティブなダッシュボード

```tsx
// src/components/3d/Dashboard3D.tsx
import React, { useState } from 'react'
import { Canvas } from '@react-three/fiber'
import { OrbitControls, Text } from '@react-three/drei'

interface DataPoint {
  id: string
  value: number
  category: string
  position: [number, number, number]
}

interface Dashboard3DProps {
  data: DataPoint[]
}

const Dashboard3D: React.FC<Dashboard3DProps> = ({ data }) => {
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null)

  return (
    <div style={{ width: '100%', height: '600px' }}>
      <Canvas camera={{ position: [0, 10, 10], fov: 60 }}>
        <ambientLight intensity={0.4} />
        <directionalLight position={[10, 10, 5]} intensity={1} />

        {/* データポイント */}
        {data.map((point) => (
          <DataPoint3D
            key={point.id}
            data={point}
            isSelected={selectedCategory === point.category}
            onSelect={() => setSelectedCategory(point.category)}
          />
        ))}

        {/* 軸ラベル */}
        <Text position={[0, 0, -8]} fontSize={1} color="#666">
          X軸: カテゴリ
        </Text>
        <Text position={[-8, 0, 0]} fontSize={1} color="#666">
          Y軸: 値
        </Text>

        <OrbitControls enablePan={true} enableZoom={true} enableRotate={true} />
      </Canvas>

      {/* 凡例 */}
      <div
        style={{
          position: 'absolute',
          top: '20px',
          right: '20px',
          background: 'rgba(255, 255, 255, 0.9)',
          padding: '15px',
          borderRadius: '8px',
          boxShadow: '0 2px 10px rgba(0,0,0,0.1)',
        }}
      >
        <h3>カテゴリ</h3>
        {Array.from(new Set(data.map((d) => d.category))).map((category) => (
          <div key={category} style={{ marginBottom: '5px' }}>
            <span
              style={{
                display: 'inline-block',
                width: '12px',
                height: '12px',
                background: selectedCategory === category ? '#007bff' : '#ddd',
                borderRadius: '50%',
                marginRight: '8px',
              }}
            />
            {category}
          </div>
        ))}
      </div>
    </div>
  )
}

// データポイントの3D表現
const DataPoint3D: React.FC<{
  data: DataPoint
  isSelected: boolean
  onSelect: () => void
}> = ({ data, isSelected, onSelect }) => {
  const [hovered, setHover] = useState(false)

  return (
    <group position={data.position}>
      {/* データバー */}
      <mesh
        onClick={onSelect}
        onPointerOver={() => setHover(true)}
        onPointerOut={() => setHover(false)}
      >
        <cylinderGeometry args={[0.2, 0.2, data.value * 0.5, 8]} />
        <meshStandardMaterial
          color={isSelected ? '#007bff' : hovered ? '#ff6b6b' : '#4ecdc4'}
          transparent
          opacity={hovered ? 0.8 : 1}
        />
      </mesh>

      {/* ラベル */}
      <Text
        position={[0, data.value * 0.25 + 0.5, 0]}
        fontSize={0.3}
        color={isSelected ? '#007bff' : '#333'}
        anchorX="center"
        anchorY="middle"
      >
        {data.value}
      </Text>
    </group>
  )
}

export default Dashboard3D
```

## まとめ

React Three Fiberを使うことで、以下のような利点が得られます：

### 主な利点

1. **開発効率**: JSXによる宣言的な3Dシーン構築
2. **パフォーマンス**: Reactの最適化機能を活用
3. **型安全性**: TypeScript完全対応
4. **豊富なエコシステム**: 多数のサードパーティライブラリ
5. **学習コスト**: Three.jsの知識がなくても始められる

### 実践のポイント

- **段階的な学習**: 基本的なシーンから始めて、徐々に複雑化
- **パフォーマンス考慮**: インスタンス化、LOD、適切なジオメトリ使用
- **インタラクティブ性**: ユーザー入力と3Dオブジェクトの連携
- **レスポンシブ対応**: デバイスに応じた最適化

[React Three Fiber公式ドキュメント](https://r3f.docs.pmnd.rs/getting-started/introduction)では、さらに詳細な情報と実践的な例が提供されています。継続的に学習することで、より高度な3Dグラフィックスアプリケーションを構築できるでしょう。

3Dグラフィックスは一見複雑に見えますが、R3Fを使うことでReact開発者でも簡単に始められます。まずは基本的なシーンから始めて、徐々に機能を追加していくことをお勧めします。
