---
date: 2025-09-20
title: 論理削除とは？物理削除との違いと実装方法を初心者向けに解説
description: 論理削除の概念から実装方法まで、初心者にも分かりやすく解説。物理削除との違い、メリット・デメリット、実際のコード例を交えて詳しく説明する。
tags:
    - database
    - logical-delete
    - soft-delete
    - sql
    - data-management
    - best-practices
prev:
    text: "Node.js標準モジュール完全ガイド：ファイルシステムからHTTPサーバーまで"
    link: "/posts/2025/09/18"
next: false
---

# 論理削除とは？物理削除との違いと実装方法を初心者向けに解説

論理削除の概念から実装方法まで、初心者にも分かりやすく解説します。物理削除との違い、メリット・デメリット、実際のコード例を交えて詳しく説明します。

## 論理削除とは何か

論理削除（Logical Delete）とは、データベースからデータを**実際には削除せず**、削除されたことを示すフラグを付けることで、データを「見えない状態」にする手法です。

### 物理削除との違い

| 削除方法 | 説明 | データの状態 |
|---------|------|-------------|
| **物理削除** | データベースから完全にデータを削除 | データが存在しない |
| **論理削除** | 削除フラグを付けて非表示にする | データは残っているが非表示 |

## なぜ論理削除を使うのか

### 論理削除のメリット

- **データの復旧が可能**: 誤って削除しても簡単に復元できる
- **監査証跡の保持**: 誰がいつ削除したかの履歴が残る
- **関連データの整合性**: 他のテーブルとの関連が保たれる
- **法的要件への対応**: データ保持義務がある場合に有効

### 論理削除のデメリット

- **ストレージ容量の増加**: 削除されたデータも残り続ける
- **クエリの複雑化**: 削除フラグを考慮したクエリが必要
- **パフォーマンスの影響**: インデックスの効率が下がる可能性

## 基本的な実装方法

### データベーススキーマの設計

```sql
-- ユーザーテーブルの例
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL,  -- 論理削除用のカラム
    deleted_by INT NULL         -- 削除者ID（オプション）
);

-- インデックスの作成
CREATE INDEX idx_users_deleted_at ON users(deleted_at);
```

### 基本的なCRUD操作

```sql
-- データの挿入（通常通り）
INSERT INTO users (name, email) VALUES ('田中太郎', 'tanaka@example.com');

-- データの取得（削除されていないもののみ）
SELECT * FROM users WHERE deleted_at IS NULL;

-- 論理削除（削除フラグを設定）
UPDATE users 
SET deleted_at = CURRENT_TIMESTAMP, deleted_by = 1 
WHERE id = 1;

-- 論理削除されたデータの復元
UPDATE users 
SET deleted_at = NULL, deleted_by = NULL 
WHERE id = 1;

-- 物理削除（本当に削除したい場合）
DELETE FROM users WHERE id = 1;
```

## 実践的な実装例

### Node.js + Prismaでの実装

```typescript
// schema.prisma
model User {
  id        Int      @id @default(autoincrement())
  name      String
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime? // 論理削除用
  deletedBy Int?      // 削除者ID

  @@map("users")
}

// ユーザーサービスの実装
class UserService {
  // 論理削除されていないユーザーを取得
  async getActiveUsers() {
    return await prisma.user.findMany({
      where: {
        deletedAt: null
      }
    });
  }

  // 論理削除されたユーザーも含めて取得
  async getAllUsers() {
    return await prisma.user.findMany();
  }

  // 論理削除
  async softDeleteUser(id: number, deletedBy: number) {
    return await prisma.user.update({
      where: { id },
      data: {
        deletedAt: new Date(),
        deletedBy
      }
    });
  }

  // 論理削除の復元
  async restoreUser(id: number) {
    return await prisma.user.update({
      where: { id },
      data: {
        deletedAt: null,
        deletedBy: null
      }
    });
  }

  // 物理削除
  async hardDeleteUser(id: number) {
    return await prisma.user.delete({
      where: { id }
    });
  }
}
```

### TypeScript + TypeORMでの実装

```typescript
// エンティティの定義
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @Column({ unique: true })
  email: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @Column({ nullable: true })
  deletedAt: Date;

  @Column({ nullable: true })
  deletedBy: number;
}

// リポジトリの実装
import { Repository } from 'typeorm';

class UserRepository {
  constructor(private repository: Repository<User>) {}

  // アクティブなユーザーのみ取得
  async findActive(): Promise<User[]> {
    return await this.repository.find({
      where: { deletedAt: IsNull() }
    });
  }

  // 論理削除
  async softDelete(id: number, deletedBy: number): Promise<void> {
    await this.repository.update(id, {
      deletedAt: new Date(),
      deletedBy
    });
  }

  // 復元
  async restore(id: number): Promise<void> {
    await this.repository.update(id, {
      deletedAt: null,
      deletedBy: null
    });
  }
}
```

## 高度な実装パターン

### ミドルウェアを使った自動化

```typescript
// Prismaミドルウェアで自動的に論理削除を処理
prisma.$use(async (params, next) => {
  // 削除操作を論理削除に変換
  if (params.action === 'delete') {
    params.action = 'update';
    params.args['data'] = { 
      deletedAt: new Date(),
      deletedBy: getCurrentUserId() // 現在のユーザーIDを取得
    };
  }

  // 検索時に論理削除されたデータを除外
  if (params.action === 'findMany' || params.action === 'findFirst') {
    if (!params.args.where) {
      params.args.where = {};
    }
    if (!params.args.where.deletedAt) {
      params.args.where.deletedAt = null;
    }
  }

  return next(params);
});
```

### カスタムクエリビルダー

```typescript
// カスタムクエリビルダーの実装
class SoftDeleteQueryBuilder<T> {
  constructor(private queryBuilder: any) {}

  // 論理削除されていないもののみ
  active(): this {
    this.queryBuilder = this.queryBuilder.where('deletedAt IS NULL');
    return this;
  }

  // 論理削除されたもののみ
  deleted(): this {
    this.queryBuilder = this.queryBuilder.where('deletedAt IS NOT NULL');
    return this;
  }

  // すべて（削除済み含む）
  withDeleted(): this {
    return this;
  }

  // 論理削除
  softDelete(deletedBy?: number): Promise<void> {
    return this.queryBuilder.update({
      deletedAt: new Date(),
      deletedBy
    }).execute();
  }

  // 復元
  restore(): Promise<void> {
    return this.queryBuilder.update({
      deletedAt: null,
      deletedBy: null
    }).execute();
  }
}
```

## パフォーマンスの最適化

### インデックスの最適化

```sql
-- 複合インデックスの作成
CREATE INDEX idx_users_active ON users(deleted_at, created_at);
CREATE INDEX idx_users_email_active ON users(email, deleted_at);

-- 部分インデックス（PostgreSQL）
CREATE INDEX idx_users_active_partial ON users(created_at) 
WHERE deleted_at IS NULL;
```

### クエリの最適化

```sql
-- 効率的なクエリ例
-- 1. 論理削除されていないユーザーを取得
SELECT * FROM users 
WHERE deleted_at IS NULL 
ORDER BY created_at DESC 
LIMIT 10;

-- 2. 論理削除されたユーザーを取得
SELECT * FROM users 
WHERE deleted_at IS NOT NULL 
ORDER BY deleted_at DESC;

-- 3. 統計情報の取得
SELECT 
  COUNT(*) as total_users,
  COUNT(CASE WHEN deleted_at IS NULL THEN 1 END) as active_users,
  COUNT(CASE WHEN deleted_at IS NOT NULL THEN 1 END) as deleted_users
FROM users;
```

## 実際のプロジェクトでの運用

### バッチ処理での物理削除

```typescript
// 一定期間経過した論理削除データを物理削除
class DataCleanupService {
  async cleanupOldDeletedData() {
    const cutoffDate = new Date();
    cutoffDate.setMonth(cutoffDate.getMonth() - 6); // 6ヶ月前

    // 古い論理削除データを物理削除
    const result = await prisma.user.deleteMany({
      where: {
        deletedAt: {
          lt: cutoffDate
        }
      }
    });

    console.log(`${result.count}件のデータを物理削除しました`);
  }
}

// 定期的な実行（cron jobなど）
setInterval(async () => {
  const cleanup = new DataCleanupService();
  await cleanup.cleanupOldDeletedData();
}, 24 * 60 * 60 * 1000); // 24時間ごと
```

### 監査ログの実装

```typescript
// 削除操作のログ記録
class AuditService {
  async logDeletion(entityType: string, entityId: number, deletedBy: number) {
    await prisma.auditLog.create({
      data: {
        entityType,
        entityId,
        action: 'DELETE',
        performedBy: deletedBy,
        performedAt: new Date(),
        details: {
          type: 'logical_delete'
        }
      }
    });
  }

  async logRestoration(entityType: string, entityId: number, restoredBy: number) {
    await prisma.auditLog.create({
      data: {
        entityType,
        entityId,
        action: 'RESTORE',
        performedBy: restoredBy,
        performedAt: new Date(),
        details: {
          type: 'logical_restore'
        }
      }
    });
  }
}
```

## まとめ

論理削除は、データの安全性と復旧可能性を高める重要な手法です。主なポイントは以下の通りです：

- **データの保護**: 誤削除からの復旧が容易
- **監査証跡**: 削除履歴の保持
- **段階的な実装**: 既存システムへの段階的な導入が可能
- **パフォーマンス考慮**: 適切なインデックス設計が重要
- **運用の自動化**: バッチ処理での物理削除

論理削除を適切に実装することで、より安全で保守性の高いシステムを構築できます。

## 次のステップ

- データベース設計のベストプラクティス
- 監査ログシステムの構築
- データバックアップと復旧戦略
- パフォーマンス監視と最適化
- セキュリティとアクセス制御
