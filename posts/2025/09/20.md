---
date: 2025-09-20
title: 論理削除とは？物理削除との違いと実装方法を初心者向けに解説
description: 論理削除の概念から実装方法まで、初心者にも分かりやすく解説。物理削除との違い、メリット・デメリット、実際のコード例を交えて詳しく説明する。
tags:
  - database
  - logical-delete
  - soft-delete
  - sql
  - data-management
  - best-practices
prev:
  text: 'Node.js標準モジュール完全ガイド：ファイルシステムからHTTPサーバーまで'
  link: '/posts/2025/09/18'
next: false
---

# 論理削除とは？物理削除との違いと実装方法を初心者向けに解説

論理削除の概念から実装方法まで、初心者にも分かりやすく解説します。物理削除との違い、メリット・デメリット、実際のコード例を交えて詳しく説明します。

## 論理削除とは何か

論理削除（Logical Delete）とは、データベースからデータを**実際には削除せず**、削除されたことを示すフラグを付けることで、データを「見えない状態」にする手法です。

### 物理削除との違い

| 削除方法     | 説明                               | データの状態               |
| ------------ | ---------------------------------- | -------------------------- |
| **物理削除** | データベースから完全にデータを削除 | データが存在しない         |
| **論理削除** | 削除フラグを付けて非表示にする     | データは残っているが非表示 |

## なぜ論理削除を使うのか

### 論理削除のメリット

- **データの復旧が可能**: 誤って削除しても簡単に復元できる
- **監査証跡の保持**: 誰がいつ削除したかの履歴が残る
- **関連データの整合性**: 他のテーブルとの関連が保たれる
- **法的要件への対応**: データ保持義務がある場合に有効

### 論理削除のデメリット

- **ストレージ容量の増加**: 削除されたデータも残り続ける
- **クエリの複雑化**: 削除フラグを考慮したクエリが必要
- **パフォーマンスの影響**: インデックスの効率が下がる可能性

## 基本的な実装方法

### データベーススキーマの設計

```sql
-- ユーザーテーブルの例
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL,  -- 論理削除用のカラム
    deleted_by INT NULL         -- 削除者ID（オプション）
);

-- インデックスの作成
CREATE INDEX idx_users_deleted_at ON users(deleted_at);
```

### 基本的なCRUD操作

```sql
-- データの挿入（通常通り）
INSERT INTO users (name, email) VALUES ('田中太郎', 'tanaka@example.com');

-- データの取得（削除されていないもののみ）
SELECT * FROM users WHERE deleted_at IS NULL;

-- 論理削除（削除フラグを設定）
UPDATE users
SET deleted_at = CURRENT_TIMESTAMP, deleted_by = 1
WHERE id = 1;

-- 論理削除されたデータの復元
UPDATE users
SET deleted_at = NULL, deleted_by = NULL
WHERE id = 1;

-- 物理削除（本当に削除したい場合）
DELETE FROM users WHERE id = 1;
```

## 実践的な実装例

### Node.js + Prismaでの実装

```typescript
// schema.prisma
model User {
  id        Int      @id @default(autoincrement())
  name      String
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime? // 論理削除用
  deletedBy Int?      // 削除者ID

  @@map("users")
}

// ユーザーサービスの実装
class UserService {
  // 論理削除されていないユーザーを取得
  async getActiveUsers() {
    return await prisma.user.findMany({
      where: {
        deletedAt: null
      }
    });
  }

  // 論理削除されたユーザーも含めて取得
  async getAllUsers() {
    return await prisma.user.findMany();
  }

  // 論理削除
  async softDeleteUser(id: number, deletedBy: number) {
    return await prisma.user.update({
      where: { id },
      data: {
        deletedAt: new Date(),
        deletedBy
      }
    });
  }

  // 論理削除の復元
  async restoreUser(id: number) {
    return await prisma.user.update({
      where: { id },
      data: {
        deletedAt: null,
        deletedBy: null
      }
    });
  }

  // 物理削除
  async hardDeleteUser(id: number) {
    return await prisma.user.delete({
      where: { id }
    });
  }
}
```

### TypeScript + TypeORMでの実装

```typescript
// エンティティの定義
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm'

@Entity('users')
export class User {
  @PrimaryGeneratedColumn()
  id: number

  @Column()
  name: string

  @Column({ unique: true })
  email: string

  @CreateDateColumn()
  createdAt: Date

  @UpdateDateColumn()
  updatedAt: Date

  @Column({ nullable: true })
  deletedAt: Date

  @Column({ nullable: true })
  deletedBy: number
}

// リポジトリの実装
import { Repository } from 'typeorm'

class UserRepository {
  constructor(private repository: Repository<User>) {}

  // アクティブなユーザーのみ取得
  async findActive(): Promise<User[]> {
    return await this.repository.find({
      where: { deletedAt: IsNull() },
    })
  }

  // 論理削除
  async softDelete(id: number, deletedBy: number): Promise<void> {
    await this.repository.update(id, {
      deletedAt: new Date(),
      deletedBy,
    })
  }

  // 復元
  async restore(id: number): Promise<void> {
    await this.repository.update(id, {
      deletedAt: null,
      deletedBy: null,
    })
  }
}
```

## 高度な実装パターン

### ミドルウェアを使った自動化

```typescript
// Prismaミドルウェアで自動的に論理削除を処理
prisma.$use(async (params, next) => {
  // 削除操作を論理削除に変換
  if (params.action === 'delete') {
    params.action = 'update'
    params.args['data'] = {
      deletedAt: new Date(),
      deletedBy: getCurrentUserId(), // 現在のユーザーIDを取得
    }
  }

  // 検索時に論理削除されたデータを除外
  if (params.action === 'findMany' || params.action === 'findFirst') {
    if (!params.args.where) {
      params.args.where = {}
    }
    if (!params.args.where.deletedAt) {
      params.args.where.deletedAt = null
    }
  }

  return next(params)
})
```

### カスタムクエリビルダー

```typescript
// カスタムクエリビルダーの実装
class SoftDeleteQueryBuilder<T> {
  constructor(private queryBuilder: any) {}

  // 論理削除されていないもののみ
  active(): this {
    this.queryBuilder = this.queryBuilder.where('deletedAt IS NULL')
    return this
  }

  // 論理削除されたもののみ
  deleted(): this {
    this.queryBuilder = this.queryBuilder.where('deletedAt IS NOT NULL')
    return this
  }

  // すべて（削除済み含む）
  withDeleted(): this {
    return this
  }

  // 論理削除
  softDelete(deletedBy?: number): Promise<void> {
    return this.queryBuilder
      .update({
        deletedAt: new Date(),
        deletedBy,
      })
      .execute()
  }

  // 復元
  restore(): Promise<void> {
    return this.queryBuilder
      .update({
        deletedAt: null,
        deletedBy: null,
      })
      .execute()
  }
}
```

## パフォーマンスの最適化

### インデックスの最適化

```sql
-- 複合インデックスの作成
CREATE INDEX idx_users_active ON users(deleted_at, created_at);
CREATE INDEX idx_users_email_active ON users(email, deleted_at);

-- 部分インデックス（PostgreSQL）
CREATE INDEX idx_users_active_partial ON users(created_at)
WHERE deleted_at IS NULL;
```

### クエリの最適化

```sql
-- 効率的なクエリ例
-- 1. 論理削除されていないユーザーを取得
SELECT * FROM users
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 10;

-- 2. 論理削除されたユーザーを取得
SELECT * FROM users
WHERE deleted_at IS NOT NULL
ORDER BY deleted_at DESC;

-- 3. 統計情報の取得
SELECT
  COUNT(*) as total_users,
  COUNT(CASE WHEN deleted_at IS NULL THEN 1 END) as active_users,
  COUNT(CASE WHEN deleted_at IS NOT NULL THEN 1 END) as deleted_users
FROM users;
```

## 実際のプロジェクトでの運用

### バッチ処理での物理削除

```typescript
// 一定期間経過した論理削除データを物理削除
class DataCleanupService {
  async cleanupOldDeletedData() {
    const cutoffDate = new Date()
    cutoffDate.setMonth(cutoffDate.getMonth() - 6) // 6ヶ月前

    // 古い論理削除データを物理削除
    const result = await prisma.user.deleteMany({
      where: {
        deletedAt: {
          lt: cutoffDate,
        },
      },
    })

    console.log(`${result.count}件のデータを物理削除しました`)
  }
}

// 定期的な実行（cron jobなど）
setInterval(
  async () => {
    const cleanup = new DataCleanupService()
    await cleanup.cleanupOldDeletedData()
  },
  24 * 60 * 60 * 1000,
) // 24時間ごと
```

### 監査ログの実装

```typescript
// 削除操作のログ記録
class AuditService {
  async logDeletion(entityType: string, entityId: number, deletedBy: number) {
    await prisma.auditLog.create({
      data: {
        entityType,
        entityId,
        action: 'DELETE',
        performedBy: deletedBy,
        performedAt: new Date(),
        details: {
          type: 'logical_delete',
        },
      },
    })
  }

  async logRestoration(entityType: string, entityId: number, restoredBy: number) {
    await prisma.auditLog.create({
      data: {
        entityType,
        entityId,
        action: 'RESTORE',
        performedBy: restoredBy,
        performedAt: new Date(),
        details: {
          type: 'logical_restore',
        },
      },
    })
  }
}
```

## まとめ

論理削除は、データの安全性と復旧可能性を高める重要な手法です。主なポイントは以下の通りです：

- **データの保護**: 誤削除からの復旧が容易
- **監査証跡**: 削除履歴の保持
- **段階的な実装**: 既存システムへの段階的な導入が可能
- **パフォーマンス考慮**: 適切なインデックス設計が重要
- **運用の自動化**: バッチ処理での物理削除

論理削除を適切に実装することで、より安全で保守性の高いシステムを構築できます。

## 次のステップ

- データベース設計のベストプラクティス
- 監査ログシステムの構築
- データバックアップと復旧戦略
- パフォーマンス監視と最適化
- セキュリティとアクセス制御
