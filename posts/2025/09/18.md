---
date: 2025-09-18
title: Node.js標準モジュール完全ガイド：ファイルシステムからHTTPサーバーまで
description: Node.jsの標準モジュールを網羅的に解説。fs、http、path、crypto、streamなど主要モジュールの使い方と実践的なコード例を交えて詳しく説明する。
tags:
    - nodejs
    - standard-modules
    - filesystem
    - http
    - crypto
    - streams
    - backend
prev:
    text: "ReactとDrizzleでカンバンボードのドラッグアンドドロップを実装する"
    link: "/posts/2025/09/17"
next: false
---

# Node.js標準モジュール完全ガイド：ファイルシステムからHTTPサーバーまで

Node.jsの標準モジュールを網羅的に解説します。fs、http、path、crypto、streamなど主要モジュールの使い方と実践的なコード例を交えて詳しく説明します。

## なぜNode.js標準モジュールを学ぶのか

Node.jsの標準モジュールには以下のメリットがあります：

- **外部依存なし**: npmパッケージをインストールせずに使用可能
- **高性能**: ネイティブ実装で最適化されている
- **安定性**: Node.jsコアの一部として長期間サポートされる
- **軽量**: バンドルサイズを抑えられる
- **学習効果**: JavaScriptの非同期処理を深く理解できる

## ファイルシステム（fs）モジュール

ファイルの読み書き、ディレクトリ操作を行うモジュールです。

### 基本的なファイル操作

```javascript
import { readFile, writeFile, mkdir, readdir } from 'fs/promises';
import { existsSync } from 'fs';

// ファイルの読み込み
async function readConfig() {
  try {
    const data = await readFile('config.json', 'utf8');
    return JSON.parse(data);
  } catch (error) {
    console.error('設定ファイルの読み込みに失敗:', error.message);
    return null;
  }
}

// ファイルの書き込み
async function saveData(filename, data) {
  try {
    await writeFile(filename, JSON.stringify(data, null, 2));
    console.log(`${filename} に保存しました`);
  } catch (error) {
    console.error('ファイルの保存に失敗:', error.message);
  }
}

// ディレクトリの作成
async function createProjectStructure() {
  const dirs = ['src', 'public', 'tests'];
  
  for (const dir of dirs) {
    if (!existsSync(dir)) {
      await mkdir(dir, { recursive: true });
      console.log(`ディレクトリ ${dir} を作成しました`);
    }
  }
}
```

### ストリームを使った大容量ファイル処理

```javascript
import { createReadStream, createWriteStream } from 'fs';
import { pipeline } from 'stream/promises';

// 大容量ファイルのコピー
async function copyLargeFile(source, destination) {
  const readStream = createReadStream(source);
  const writeStream = createWriteStream(destination);
  
  try {
    await pipeline(readStream, writeStream);
    console.log('ファイルのコピーが完了しました');
  } catch (error) {
    console.error('コピー中にエラーが発生:', error.message);
  }
}

// ファイルの監視
import { watch } from 'fs';

function watchFile(filename) {
  const watcher = watch(filename, (eventType, filename) => {
    console.log(`ファイル ${filename} が ${eventType} されました`);
  });
  
  // 10秒後に監視を停止
  setTimeout(() => {
    watcher.close();
    console.log('ファイル監視を停止しました');
  }, 10000);
}
```

## HTTPモジュール

WebサーバーやHTTPクライアントを作成するモジュールです。

### 基本的なHTTPサーバー

```javascript
import { createServer } from 'http';
import { URL } from 'url';

const server = createServer((req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);
  const pathname = url.pathname;
  const method = req.method;
  
  // CORSヘッダーの設定
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  
  // ルーティング
  if (method === 'GET' && pathname === '/') {
    res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
    res.end('<h1>Node.js HTTPサーバー</h1><p>標準モジュールで構築されています</p>');
  } else if (method === 'GET' && pathname === '/api/status') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ 
      status: 'ok', 
      timestamp: new Date().toISOString(),
      uptime: process.uptime()
    }));
  } else if (method === 'POST' && pathname === '/api/echo') {
    let body = '';
    req.on('data', chunk => {
      body += chunk.toString();
    });
    
    req.on('end', () => {
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ 
        received: body,
        length: body.length 
      }));
    });
  } else {
    res.writeHead(404, { 'Content-Type': 'text/plain' });
    res.end('Not Found');
  }
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`サーバーがポート ${PORT} で起動しました`);
});
```

### HTTPクライアント

```javascript
import { request } from 'http';
import { get } from 'https';

// HTTPリクエストの送信
function makeRequest(url, options = {}) {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url);
    const isHttps = urlObj.protocol === 'https:';
    const httpModule = isHttps ? require('https') : require('http');
    
    const reqOptions = {
      hostname: urlObj.hostname,
      port: urlObj.port || (isHttps ? 443 : 80),
      path: urlObj.pathname + urlObj.search,
      method: options.method || 'GET',
      headers: options.headers || {}
    };
    
    const req = httpModule.request(reqOptions, (res) => {
      let data = '';
      
      res.on('data', (chunk) => {
        data += chunk;
      });
      
      res.on('end', () => {
        resolve({
          statusCode: res.statusCode,
          headers: res.headers,
          data: data
        });
      });
    });
    
    req.on('error', (error) => {
      reject(error);
    });
    
    if (options.body) {
      req.write(options.body);
    }
    
    req.end();
  });
}

// 使用例
async function fetchData() {
  try {
    const response = await makeRequest('https://api.github.com/users/octocat');
    console.log('ステータス:', response.statusCode);
    console.log('データ:', JSON.parse(response.data));
  } catch (error) {
    console.error('リクエストエラー:', error.message);
  }
}
```

## パス操作（path）モジュール

ファイルパスの操作を安全に行うモジュールです。

```javascript
import { join, resolve, dirname, basename, extname, parse } from 'path';
import { fileURLToPath } from 'url';

// 現在のファイルのディレクトリを取得
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// パスの結合
const configPath = join(__dirname, 'config', 'app.json');
console.log('設定ファイルパス:', configPath);

// 絶対パスの解決
const absolutePath = resolve('./src/components/Button.jsx');
console.log('絶対パス:', absolutePath);

// パスの解析
const filePath = '/home/user/projects/app/src/components/Button.jsx';
const pathInfo = parse(filePath);

console.log('ディレクトリ:', pathInfo.dir);
console.log('ファイル名:', pathInfo.name);
console.log('拡張子:', pathInfo.ext);
console.log('ベース名:', basename(filePath));
console.log('拡張子のみ:', extname(filePath));

// クロスプラットフォーム対応のパス操作
function createAssetPath(assetName) {
  return join('assets', 'images', assetName);
}

// Windows、macOS、Linuxで正しく動作
console.log(createAssetPath('logo.png')); // assets/images/logo.png
```

## 暗号化（crypto）モジュール

ハッシュ化、暗号化、デジタル署名などの機能を提供します。

```javascript
import { createHash, createHmac, randomBytes, createCipher, createDecipher } from 'crypto';

// ハッシュ化
function hashPassword(password, salt = '') {
  const hash = createHash('sha256');
  hash.update(password + salt);
  return hash.digest('hex');
}

// HMAC（メッセージ認証コード）
function createSignature(data, secret) {
  const hmac = createHmac('sha256', secret);
  hmac.update(data);
  return hmac.digest('hex');
}

// ランダムな文字列の生成
function generateToken(length = 32) {
  return randomBytes(length).toString('hex');
}

// パスワードの検証
function verifyPassword(password, hashedPassword, salt = '') {
  return hashPassword(password, salt) === hashedPassword;
}

// 使用例
const password = 'mySecretPassword';
const salt = generateToken(16);
const hashed = hashPassword(password, salt);

console.log('元のパスワード:', password);
console.log('ソルト:', salt);
console.log('ハッシュ:', hashed);
console.log('検証結果:', verifyPassword(password, hashed, salt));
```

## ストリーム（stream）モジュール

大量のデータを効率的に処理するためのモジュールです。

```javascript
import { Readable, Writable, Transform, pipeline } from 'stream';
import { promisify } from 'util';

const pipelineAsync = promisify(pipeline);

// カスタムReadableストリーム
class NumberGenerator extends Readable {
  constructor(max) {
    super({ objectMode: true });
    this.max = max;
    this.current = 0;
  }
  
  _read() {
    if (this.current >= this.max) {
      this.push(null); // ストリーム終了
      return;
    }
    
    this.push({ number: this.current++, timestamp: new Date() });
  }
}

// カスタムTransformストリーム
class NumberMultiplier extends Transform {
  constructor(factor) {
    super({ objectMode: true });
    this.factor = factor;
  }
  
  _transform(chunk, encoding, callback) {
    const result = {
      ...chunk,
      multiplied: chunk.number * this.factor
    };
    callback(null, result);
  }
}

// カスタムWritableストリーム
class DataLogger extends Writable {
  constructor() {
    super({ objectMode: true });
  }
  
  _write(chunk, encoding, callback) {
    console.log('処理されたデータ:', chunk);
    callback();
  }
}

// ストリームの組み合わせ
async function processNumbers() {
  const generator = new NumberGenerator(10);
  const multiplier = new NumberMultiplier(2);
  const logger = new DataLogger();
  
  try {
    await pipelineAsync(generator, multiplier, logger);
    console.log('ストリーム処理が完了しました');
  } catch (error) {
    console.error('ストリーム処理エラー:', error.message);
  }
}
```

## プロセス管理（process）モジュール

Node.jsプロセスの情報取得や制御を行います。

```javascript
import process from 'process';

// 環境変数の取得
console.log('Node.jsバージョン:', process.version);
console.log('プラットフォーム:', process.platform);
console.log('アーキテクチャ:', process.arch);
console.log('メモリ使用量:', process.memoryUsage());

// 環境変数の設定と取得
process.env.NODE_ENV = 'production';
console.log('環境:', process.env.NODE_ENV);

// シグナルハンドリング
process.on('SIGINT', () => {
  console.log('\nアプリケーションを終了しています...');
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('終了シグナルを受信しました');
  process.exit(0);
});

// 未処理の例外のキャッチ
process.on('uncaughtException', (error) => {
  console.error('未処理の例外:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('未処理のPromise拒否:', reason);
  process.exit(1);
});

// プロセスの終了
function gracefulShutdown() {
  console.log('グレースフルシャットダウンを開始...');
  
  // クリーンアップ処理
  setTimeout(() => {
    console.log('クリーンアップ完了');
    process.exit(0);
  }, 1000);
}
```

## イベント（events）モジュール

イベント駆動プログラミングのためのモジュールです。

```javascript
import { EventEmitter } from 'events';

// カスタムイベントエミッター
class UserManager extends EventEmitter {
  constructor() {
    super();
    this.users = new Map();
  }
  
  addUser(user) {
    this.users.set(user.id, user);
    this.emit('userAdded', user);
  }
  
  removeUser(userId) {
    const user = this.users.get(userId);
    if (user) {
      this.users.delete(userId);
      this.emit('userRemoved', user);
    }
  }
  
  getUser(userId) {
    return this.users.get(userId);
  }
}

// 使用例
const userManager = new UserManager();

// イベントリスナーの登録
userManager.on('userAdded', (user) => {
  console.log(`ユーザーが追加されました: ${user.name}`);
});

userManager.on('userRemoved', (user) => {
  console.log(`ユーザーが削除されました: ${user.name}`);
});

// 一度だけ実行されるリスナー
userManager.once('userAdded', (user) => {
  console.log('最初のユーザーが追加されました！');
});

// ユーザーの操作
userManager.addUser({ id: 1, name: 'Alice' });
userManager.addUser({ id: 2, name: 'Bob' });
userManager.removeUser(1);
```

## まとめ

Node.jsの標準モジュールは、外部ライブラリに依存せずに強力な機能を提供します。主なポイントは以下の通りです：

- **fs**: ファイルシステム操作の基本
- **http/https**: Webサーバーとクライアントの構築
- **path**: クロスプラットフォーム対応のパス操作
- **crypto**: セキュリティ関連の機能
- **stream**: 大量データの効率的な処理
- **process**: プロセス管理と環境情報
- **events**: イベント駆動プログラミング

これらのモジュールを組み合わせることで、外部依存を最小限に抑えた高性能なNode.jsアプリケーションを構築できます。

## 次のステップ

- 非同期処理のパターン（Promise、async/await）の深掘り
- カスタムモジュールの作成とパッケージ化
- パフォーマンス最適化のテクニック
- エラーハンドリングのベストプラクティス
- テストの書き方とデバッグ手法
