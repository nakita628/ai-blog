---
date: 2025-09-18
title: Node.js標準モジュール完全ガイド：ファイルシステムからHTTPサーバーまで
description: Node.jsの標準モジュールを網羅的に解説。fs、http、path、crypto、streamなど主要モジュールの使い方と実践的なコード例を交えて詳しく説明する。
tags:
  - nodejs
  - standard-modules
  - filesystem
  - http
  - crypto
  - streams
  - backend
prev:
  text: 'ReactとDrizzleでカンバンボードのドラッグアンドドロップを実装する'
  link: '/posts/2025/09/17'
next: false
---

# Node.js標準モジュール完全ガイド：ファイルシステムからHTTPサーバーまで

Node.jsの標準モジュールを網羅的に解説します。fs、http、path、crypto、streamなど主要モジュールの使い方と実践的なコード例を交えて詳しく説明します。

## なぜNode.js標準モジュールを学ぶのか

Node.jsの標準モジュールには以下のメリットがあります：

- **外部依存なし**: npmパッケージをインストールせずに使用可能
- **高性能**: ネイティブ実装で最適化されている
- **安定性**: Node.jsコアの一部として長期間サポートされる
- **軽量**: バンドルサイズを抑えられる
- **学習効果**: JavaScriptの非同期処理を深く理解できる

## ファイルシステム（fs）モジュール

ファイルの読み書き、ディレクトリ操作を行うモジュールです。

### 基本的なファイル操作

```javascript
import { readFile, writeFile, mkdir, readdir } from 'fs/promises'
import { existsSync } from 'fs'

// ファイルの読み込み
async function readConfig() {
  try {
    const data = await readFile('config.json', 'utf8')
    return JSON.parse(data)
  } catch (error) {
    console.error('設定ファイルの読み込みに失敗:', error.message)
    return null
  }
}

// ファイルの書き込み
async function saveData(filename, data) {
  try {
    await writeFile(filename, JSON.stringify(data, null, 2))
    console.log(`${filename} に保存しました`)
  } catch (error) {
    console.error('ファイルの保存に失敗:', error.message)
  }
}

// ディレクトリの作成
async function createProjectStructure() {
  const dirs = ['src', 'public', 'tests']

  for (const dir of dirs) {
    if (!existsSync(dir)) {
      await mkdir(dir, { recursive: true })
      console.log(`ディレクトリ ${dir} を作成しました`)
    }
  }
}
```

### ストリームを使った大容量ファイル処理

```javascript
import { createReadStream, createWriteStream } from 'fs'
import { pipeline } from 'stream/promises'

// 大容量ファイルのコピー
async function copyLargeFile(source, destination) {
  const readStream = createReadStream(source)
  const writeStream = createWriteStream(destination)

  try {
    await pipeline(readStream, writeStream)
    console.log('ファイルのコピーが完了しました')
  } catch (error) {
    console.error('コピー中にエラーが発生:', error.message)
  }
}

// ファイルの監視
import { watch } from 'fs'

function watchFile(filename) {
  const watcher = watch(filename, (eventType, filename) => {
    console.log(`ファイル ${filename} が ${eventType} されました`)
  })

  // 10秒後に監視を停止
  setTimeout(() => {
    watcher.close()
    console.log('ファイル監視を停止しました')
  }, 10000)
}
```

## HTTPモジュール

WebサーバーやHTTPクライアントを作成するモジュールです。

### 基本的なHTTPサーバー

```javascript
import { createServer } from 'http'
import { URL } from 'url'

const server = createServer((req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`)
  const pathname = url.pathname
  const method = req.method

  // CORSヘッダーの設定
  res.setHeader('Access-Control-Allow-Origin', '*')
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE')
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type')

  // ルーティング
  if (method === 'GET' && pathname === '/') {
    res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' })
    res.end('<h1>Node.js HTTPサーバー</h1><p>標準モジュールで構築されています</p>')
  } else if (method === 'GET' && pathname === '/api/status') {
    res.writeHead(200, { 'Content-Type': 'application/json' })
    res.end(
      JSON.stringify({
        status: 'ok',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
      }),
    )
  } else if (method === 'POST' && pathname === '/api/echo') {
    let body = ''
    req.on('data', (chunk) => {
      body += chunk.toString()
    })

    req.on('end', () => {
      res.writeHead(200, { 'Content-Type': 'application/json' })
      res.end(
        JSON.stringify({
          received: body,
          length: body.length,
        }),
      )
    })
  } else {
    res.writeHead(404, { 'Content-Type': 'text/plain' })
    res.end('Not Found')
  }
})

const PORT = process.env.PORT || 3000
server.listen(PORT, () => {
  console.log(`サーバーがポート ${PORT} で起動しました`)
})
```

### HTTPクライアント

```javascript
import { request } from 'http'
import { get } from 'https'

// HTTPリクエストの送信
function makeRequest(url, options = {}) {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url)
    const isHttps = urlObj.protocol === 'https:'
    const httpModule = isHttps ? require('https') : require('http')

    const reqOptions = {
      hostname: urlObj.hostname,
      port: urlObj.port || (isHttps ? 443 : 80),
      path: urlObj.pathname + urlObj.search,
      method: options.method || 'GET',
      headers: options.headers || {},
    }

    const req = httpModule.request(reqOptions, (res) => {
      let data = ''

      res.on('data', (chunk) => {
        data += chunk
      })

      res.on('end', () => {
        resolve({
          statusCode: res.statusCode,
          headers: res.headers,
          data: data,
        })
      })
    })

    req.on('error', (error) => {
      reject(error)
    })

    if (options.body) {
      req.write(options.body)
    }

    req.end()
  })
}

// 使用例
async function fetchData() {
  try {
    const response = await makeRequest('https://api.github.com/users/octocat')
    console.log('ステータス:', response.statusCode)
    console.log('データ:', JSON.parse(response.data))
  } catch (error) {
    console.error('リクエストエラー:', error.message)
  }
}
```

## パス操作（path）モジュール

ファイルパスの操作を安全に行うモジュールです。

```javascript
import { join, resolve, dirname, basename, extname, parse } from 'path'
import { fileURLToPath } from 'url'

// 現在のファイルのディレクトリを取得
const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

// パスの結合
const configPath = join(__dirname, 'config', 'app.json')
console.log('設定ファイルパス:', configPath)

// 絶対パスの解決
const absolutePath = resolve('./src/components/Button.jsx')
console.log('絶対パス:', absolutePath)

// パスの解析
const filePath = '/home/user/projects/app/src/components/Button.jsx'
const pathInfo = parse(filePath)

console.log('ディレクトリ:', pathInfo.dir)
console.log('ファイル名:', pathInfo.name)
console.log('拡張子:', pathInfo.ext)
console.log('ベース名:', basename(filePath))
console.log('拡張子のみ:', extname(filePath))

// クロスプラットフォーム対応のパス操作
function createAssetPath(assetName) {
  return join('assets', 'images', assetName)
}

// Windows、macOS、Linuxで正しく動作
console.log(createAssetPath('logo.png')) // assets/images/logo.png
```

## 暗号化（crypto）モジュール

ハッシュ化、暗号化、デジタル署名などの機能を提供します。

```javascript
import { createHash, createHmac, randomBytes, createCipher, createDecipher } from 'crypto'

// ハッシュ化
function hashPassword(password, salt = '') {
  const hash = createHash('sha256')
  hash.update(password + salt)
  return hash.digest('hex')
}

// HMAC（メッセージ認証コード）
function createSignature(data, secret) {
  const hmac = createHmac('sha256', secret)
  hmac.update(data)
  return hmac.digest('hex')
}

// ランダムな文字列の生成
function generateToken(length = 32) {
  return randomBytes(length).toString('hex')
}

// パスワードの検証
function verifyPassword(password, hashedPassword, salt = '') {
  return hashPassword(password, salt) === hashedPassword
}

// 使用例
const password = 'mySecretPassword'
const salt = generateToken(16)
const hashed = hashPassword(password, salt)

console.log('元のパスワード:', password)
console.log('ソルト:', salt)
console.log('ハッシュ:', hashed)
console.log('検証結果:', verifyPassword(password, hashed, salt))
```

## ストリーム（stream）モジュール

大量のデータを効率的に処理するためのモジュールです。

```javascript
import { Readable, Writable, Transform, pipeline } from 'stream'
import { promisify } from 'util'

const pipelineAsync = promisify(pipeline)

// カスタムReadableストリーム
class NumberGenerator extends Readable {
  constructor(max) {
    super({ objectMode: true })
    this.max = max
    this.current = 0
  }

  _read() {
    if (this.current >= this.max) {
      this.push(null) // ストリーム終了
      return
    }

    this.push({ number: this.current++, timestamp: new Date() })
  }
}

// カスタムTransformストリーム
class NumberMultiplier extends Transform {
  constructor(factor) {
    super({ objectMode: true })
    this.factor = factor
  }

  _transform(chunk, encoding, callback) {
    const result = {
      ...chunk,
      multiplied: chunk.number * this.factor,
    }
    callback(null, result)
  }
}

// カスタムWritableストリーム
class DataLogger extends Writable {
  constructor() {
    super({ objectMode: true })
  }

  _write(chunk, encoding, callback) {
    console.log('処理されたデータ:', chunk)
    callback()
  }
}

// ストリームの組み合わせ
async function processNumbers() {
  const generator = new NumberGenerator(10)
  const multiplier = new NumberMultiplier(2)
  const logger = new DataLogger()

  try {
    await pipelineAsync(generator, multiplier, logger)
    console.log('ストリーム処理が完了しました')
  } catch (error) {
    console.error('ストリーム処理エラー:', error.message)
  }
}
```

## プロセス管理（process）モジュール

Node.jsプロセスの情報取得や制御を行います。

```javascript
import process from 'process'

// 環境変数の取得
console.log('Node.jsバージョン:', process.version)
console.log('プラットフォーム:', process.platform)
console.log('アーキテクチャ:', process.arch)
console.log('メモリ使用量:', process.memoryUsage())

// 環境変数の設定と取得
process.env.NODE_ENV = 'production'
console.log('環境:', process.env.NODE_ENV)

// シグナルハンドリング
process.on('SIGINT', () => {
  console.log('\nアプリケーションを終了しています...')
  process.exit(0)
})

process.on('SIGTERM', () => {
  console.log('終了シグナルを受信しました')
  process.exit(0)
})

// 未処理の例外のキャッチ
process.on('uncaughtException', (error) => {
  console.error('未処理の例外:', error)
  process.exit(1)
})

process.on('unhandledRejection', (reason, promise) => {
  console.error('未処理のPromise拒否:', reason)
  process.exit(1)
})

// プロセスの終了
function gracefulShutdown() {
  console.log('グレースフルシャットダウンを開始...')

  // クリーンアップ処理
  setTimeout(() => {
    console.log('クリーンアップ完了')
    process.exit(0)
  }, 1000)
}
```

## イベント（events）モジュール

イベント駆動プログラミングのためのモジュールです。

```javascript
import { EventEmitter } from 'events'

// カスタムイベントエミッター
class UserManager extends EventEmitter {
  constructor() {
    super()
    this.users = new Map()
  }

  addUser(user) {
    this.users.set(user.id, user)
    this.emit('userAdded', user)
  }

  removeUser(userId) {
    const user = this.users.get(userId)
    if (user) {
      this.users.delete(userId)
      this.emit('userRemoved', user)
    }
  }

  getUser(userId) {
    return this.users.get(userId)
  }
}

// 使用例
const userManager = new UserManager()

// イベントリスナーの登録
userManager.on('userAdded', (user) => {
  console.log(`ユーザーが追加されました: ${user.name}`)
})

userManager.on('userRemoved', (user) => {
  console.log(`ユーザーが削除されました: ${user.name}`)
})

// 一度だけ実行されるリスナー
userManager.once('userAdded', (user) => {
  console.log('最初のユーザーが追加されました！')
})

// ユーザーの操作
userManager.addUser({ id: 1, name: 'Alice' })
userManager.addUser({ id: 2, name: 'Bob' })
userManager.removeUser(1)
```

## まとめ

Node.jsの標準モジュールは、外部ライブラリに依存せずに強力な機能を提供します。主なポイントは以下の通りです：

- **fs**: ファイルシステム操作の基本
- **http/https**: Webサーバーとクライアントの構築
- **path**: クロスプラットフォーム対応のパス操作
- **crypto**: セキュリティ関連の機能
- **stream**: 大量データの効率的な処理
- **process**: プロセス管理と環境情報
- **events**: イベント駆動プログラミング

これらのモジュールを組み合わせることで、外部依存を最小限に抑えた高性能なNode.jsアプリケーションを構築できます。

## 次のステップ

- 非同期処理のパターン（Promise、async/await）の深掘り
- カスタムモジュールの作成とパッケージ化
- パフォーマンス最適化のテクニック
- エラーハンドリングのベストプラクティス
- テストの書き方とデバッグ手法
