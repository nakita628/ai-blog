---
date: 2025-09-23
title: Pydantic完全ガイド：Pythonのデータ検証ライブラリを初心者向けに解説
description: Pydanticの基本から実践的な使い方まで、初心者向けに分かりやすく解説。データ検証、型変換、エラーハンドリングなど、実際のコード例を交えて詳しく説明する。
tags:
    - pydantic
    - python
    - data-validation
    - type-hints
    - fastapi
    - data-modeling
prev:
    text: "Python入門完全ガイド：初心者でも分かるプログラミング言語の基本"
    link: "/posts/2025/09/22"
next: false
---

# Pydantic完全ガイド：Pythonのデータ検証ライブラリを初心者向けに解説

[Pydantic](https://docs.pydantic.dev/latest/)は、Pythonで最も広く使用されているデータ検証ライブラリです。型ヒントを活用してデータの検証とシリアライゼーションを行う強力なツールで、FastAPIやDjango Ninjaなど多くの人気ライブラリで使用されています。

## Pydanticとは何か

Pydanticは、Pythonの型ヒントを活用してデータの検証と変換を行うライブラリです。以下の特徴があります：

- **型ヒントベース**: Pythonの型アノテーションを使用してスキーマを定義
- **高速**: Rustで書かれたコアエンジンにより高速な検証
- **自動変換**: 適切な型への自動変換（例：文字列"123" → 整数123）
- **詳細なエラー**: 検証失敗時の詳細なエラーメッセージ
- **JSON Schema対応**: 自動的にJSON Schemaを生成
- **IDE対応**: 型チェッカーやIDEとの完璧な統合

## インストール

```bash
pip install pydantic
```

## 基本的な使い方

### シンプルなモデルの作成

```python
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int
    email: str

# データの検証と作成
user_data = {
    "name": "田中太郎",
    "age": 25,
    "email": "tanaka@example.com"
}

user = User(**user_data)
print(user.name)  # 田中太郎
print(user.age)   # 25
print(user.email) # tanaka@example.com
```

### 型の自動変換

```python
from pydantic import BaseModel
from datetime import datetime

class User(BaseModel):
    name: str
    age: int
    email: str
    created_at: datetime

# 文字列の数値を自動的に整数に変換
# 文字列の日時を自動的にdatetimeオブジェクトに変換
user_data = {
    "name": "佐藤花子",
    "age": "30",  # 文字列だが自動的に整数に変換される
    "email": "sato@example.com",
    "created_at": "2023-01-01 12:00:00"  # 文字列だが自動的にdatetimeに変換される
}

user = User(**user_data)
print(type(user.age))        # <class 'int'>
print(type(user.created_at)) # <class 'datetime.datetime'>
```

### デフォルト値の設定

```python
from pydantic import BaseModel
from typing import Optional

class User(BaseModel):
    name: str
    age: int = 20  # デフォルト値
    email: Optional[str] = None  # オプショナルフィールド
    is_active: bool = True  # デフォルト値

# 最小限のデータでユーザーを作成
user = User(name="鈴木一郎")
print(user.age)      # 20 (デフォルト値)
print(user.email)    # None
print(user.is_active) # True
```

## 高度な型とバリデーション

### 制約付きの型

```python
from pydantic import BaseModel, Field, EmailStr
from typing import List, Optional
from datetime import datetime

class User(BaseModel):
    name: str = Field(..., min_length=1, max_length=50)  # 必須、1-50文字
    age: int = Field(..., ge=0, le=120)  # 必須、0-120の範囲
    email: EmailStr  # メールアドレス形式の検証
    tags: List[str] = Field(default_factory=list)  # 文字列のリスト
    created_at: datetime = Field(default_factory=datetime.now)

# 有効なデータ
user_data = {
    "name": "田中太郎",
    "age": 25,
    "email": "tanaka@example.com",
    "tags": ["python", "developer"]
}

user = User(**user_data)
print(user.model_dump())
```

### カスタムバリデーター

```python
from pydantic import BaseModel, field_validator
from typing import List

class Product(BaseModel):
    name: str
    price: float
    category: str
    tags: List[str]

    @field_validator('price')
    @classmethod
    def validate_price(cls, v):
        if v <= 0:
            raise ValueError('価格は0より大きい必要があります')
        return v

    @field_validator('category')
    @classmethod
    def validate_category(cls, v):
        allowed_categories = ['electronics', 'clothing', 'books', 'food']
        if v.lower() not in allowed_categories:
            raise ValueError(f'カテゴリは {allowed_categories} のいずれかである必要があります')
        return v.lower()

    @field_validator('tags')
    @classmethod
    def validate_tags(cls, v):
        if len(v) > 5:
            raise ValueError('タグは5個以下である必要があります')
        return [tag.lower() for tag in v]

# 使用例
try:
    product = Product(
        name="スマートフォン",
        price=50000,
        category="electronics",
        tags=["mobile", "tech", "smartphone"]
    )
    print("商品が正常に作成されました:", product.name)
except ValueError as e:
    print(f"エラー: {e}")
```

## エラーハンドリング

### 検証エラーの処理

```python
from pydantic import BaseModel, ValidationError, Field

class User(BaseModel):
    name: str = Field(..., min_length=1)
    age: int = Field(..., ge=0, le=120)
    email: str = Field(..., regex=r'^[^@]+@[^@]+\.[^@]+$')

# 無効なデータでの検証エラー
invalid_data = {
    "name": "",  # 空文字（min_length違反）
    "age": 150,  # 範囲外（le=120違反）
    "email": "invalid-email"  # メール形式違反
}

try:
    user = User(**invalid_data)
except ValidationError as e:
    print("検証エラーが発生しました:")
    for error in e.errors():
        print(f"- {error['loc']}: {error['msg']}")
        print(f"  入力値: {error['input']}")
```

### エラーの詳細情報

```python
from pydantic import BaseModel, ValidationError, Field
from typing import List

class User(BaseModel):
    name: str = Field(..., min_length=2, max_length=20)
    age: int = Field(..., ge=18, le=65)
    hobbies: List[str] = Field(..., min_length=1, max_length=3)

def validate_user_data(data: dict):
    try:
        user = User(**data)
        return {"success": True, "user": user}
    except ValidationError as e:
        errors = []
        for error in e.errors():
            field = " -> ".join(str(loc) for loc in error['loc'])
            errors.append({
                "field": field,
                "message": error['msg'],
                "input": error['input'],
                "type": error['type']
            })
        return {"success": False, "errors": errors}

# テストデータ
test_data = {
    "name": "A",  # 短すぎる
    "age": 16,    # 18未満
    "hobbies": []  # 空のリスト
}

result = validate_user_data(test_data)
if not result["success"]:
    print("検証エラー:")
    for error in result["errors"]:
        print(f"フィールド: {error['field']}")
        print(f"メッセージ: {error['message']}")
        print(f"入力値: {error['input']}")
        print(f"エラータイプ: {error['type']}")
        print("---")
```

## 実践的な使用例

### APIリクエスト/レスポンスモデル

```python
from pydantic import BaseModel, Field, EmailStr
from typing import List, Optional
from datetime import datetime
from enum import Enum

class UserRole(str, Enum):
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"

class UserCreate(BaseModel):
    """ユーザー作成用のリクエストモデル"""
    name: str = Field(..., min_length=1, max_length=50)
    email: EmailStr
    age: int = Field(..., ge=18, le=120)
    role: UserRole = UserRole.USER

class UserUpdate(BaseModel):
    """ユーザー更新用のリクエストモデル"""
    name: Optional[str] = Field(None, min_length=1, max_length=50)
    age: Optional[int] = Field(None, ge=18, le=120)
    role: Optional[UserRole] = None

class UserResponse(BaseModel):
    """ユーザー情報のレスポンスモデル"""
    id: int
    name: str
    email: str
    age: int
    role: UserRole
    created_at: datetime
    is_active: bool = True

    class Config:
        from_attributes = True  # ORMオブジェクトからの変換を許可

# 使用例
def create_user(user_data: dict) -> UserResponse:
    # リクエストデータの検証
    user_create = UserCreate(**user_data)
    
    # データベースに保存（シミュレーション）
    user_id = 1
    created_at = datetime.now()
    
    # レスポンスモデルで返す
    return UserResponse(
        id=user_id,
        name=user_create.name,
        email=user_create.email,
        age=user_create.age,
        role=user_create.role,
        created_at=created_at
    )

# テスト
user_data = {
    "name": "田中太郎",
    "email": "tanaka@example.com",
    "age": 25,
    "role": "user"
}

user_response = create_user(user_data)
print(user_response.model_dump())
```

### 設定管理

```python
from pydantic import BaseModel, Field
from typing import List, Optional
import os

class DatabaseConfig(BaseModel):
    host: str = Field(default="localhost")
    port: int = Field(default=5432, ge=1, le=65535)
    username: str
    password: str
    database: str

class RedisConfig(BaseModel):
    host: str = Field(default="localhost")
    port: int = Field(default=6379, ge=1, le=65535)
    password: Optional[str] = None
    db: int = Field(default=0, ge=0, le=15)

class AppConfig(BaseModel):
    app_name: str = Field(default="MyApp")
    debug: bool = Field(default=False)
    secret_key: str
    allowed_hosts: List[str] = Field(default_factory=lambda: ["localhost"])
    database: DatabaseConfig
    redis: RedisConfig

    @classmethod
    def from_env(cls):
        """環境変数から設定を読み込み"""
        return cls(
            app_name=os.getenv("APP_NAME", "MyApp"),
            debug=os.getenv("DEBUG", "false").lower() == "true",
            secret_key=os.getenv("SECRET_KEY", "your-secret-key"),
            allowed_hosts=os.getenv("ALLOWED_HOSTS", "localhost").split(","),
            database=DatabaseConfig(
                host=os.getenv("DB_HOST", "localhost"),
                port=int(os.getenv("DB_PORT", "5432")),
                username=os.getenv("DB_USERNAME", "postgres"),
                password=os.getenv("DB_PASSWORD", "password"),
                database=os.getenv("DB_NAME", "myapp")
            ),
            redis=RedisConfig(
                host=os.getenv("REDIS_HOST", "localhost"),
                port=int(os.getenv("REDIS_PORT", "6379")),
                password=os.getenv("REDIS_PASSWORD"),
                db=int(os.getenv("REDIS_DB", "0"))
            )
        )

# 設定の使用
config = AppConfig.from_env()
print(f"アプリ名: {config.app_name}")
print(f"データベース: {config.database.host}:{config.database.port}")
print(f"Redis: {config.redis.host}:{config.redis.port}")
```

### データ変換とシリアライゼーション

```python
from pydantic import BaseModel, Field, computed_field
from typing import List, Dict, Any
from datetime import datetime, date
import json

class Product(BaseModel):
    name: str
    price: float
    category: str
    tags: List[str] = Field(default_factory=list)
    created_at: datetime = Field(default_factory=datetime.now)

    @computed_field
    @property
    def price_with_tax(self) -> float:
        """税込み価格を計算"""
        return self.price * 1.1

    @computed_field
    @property
    def display_name(self) -> str:
        """表示用の名前"""
        return f"{self.name} ({self.category})"

    def to_dict(self) -> Dict[str, Any]:
        """辞書に変換"""
        return self.model_dump()

    def to_json(self) -> str:
        """JSON文字列に変換"""
        return self.model_dump_json()

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Product':
        """辞書から作成"""
        return cls(**data)

    @classmethod
    def from_json(cls, json_str: str) -> 'Product':
        """JSON文字列から作成"""
        return cls.model_validate_json(json_str)

# 使用例
product_data = {
    "name": "スマートフォン",
    "price": 50000,
    "category": "electronics",
    "tags": ["mobile", "tech"]
}

# オブジェクトの作成
product = Product(**product_data)

# 計算フィールドの使用
print(f"税込み価格: {product.price_with_tax}")
print(f"表示名: {product.display_name}")

# シリアライゼーション
product_dict = product.to_dict()
product_json = product.to_json()

print("辞書形式:")
print(json.dumps(product_dict, indent=2, ensure_ascii=False))

print("\nJSON形式:")
print(product_json)

# デシリアライゼーション
product_from_dict = Product.from_dict(product_dict)
product_from_json = Product.from_json(product_json)

print(f"\n復元された商品: {product_from_dict.name}")
```

## FastAPIとの統合

### FastAPIでのPydantic使用例

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field, EmailStr
from typing import List, Optional
from datetime import datetime

app = FastAPI()

class UserCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=50)
    email: EmailStr
    age: int = Field(..., ge=18, le=120)

class UserResponse(BaseModel):
    id: int
    name: str
    email: str
    age: int
    created_at: datetime

# メモリ内のユーザーストレージ（実際のアプリではデータベースを使用）
users = []
next_id = 1

@app.post("/users/", response_model=UserResponse)
async def create_user(user: UserCreate):
    """ユーザーを作成"""
    global next_id
    
    # メールアドレスの重複チェック
    for existing_user in users:
        if existing_user["email"] == user.email:
            raise HTTPException(status_code=400, detail="Email already registered")
    
    # ユーザーの作成
    new_user = {
        "id": next_id,
        "name": user.name,
        "email": user.email,
        "age": user.age,
        "created_at": datetime.now()
    }
    
    users.append(new_user)
    next_id += 1
    
    return UserResponse(**new_user)

@app.get("/users/", response_model=List[UserResponse])
async def get_users():
    """ユーザー一覧を取得"""
    return [UserResponse(**user) for user in users]

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    """特定のユーザーを取得"""
    for user in users:
        if user["id"] == user_id:
            return UserResponse(**user)
    
    raise HTTPException(status_code=404, detail="User not found")

# アプリケーションの実行
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

## まとめ

Pydanticは、Pythonでデータ検証とシリアライゼーションを行うための強力なライブラリです。主なポイントは以下の通りです：

- **型ヒントベース**: Pythonの型アノテーションを活用した直感的なスキーマ定義
- **自動変換**: 適切な型への自動変換により、柔軟なデータ処理が可能
- **詳細なエラー**: 検証失敗時の詳細なエラーメッセージでデバッグが容易
- **高速**: Rustで書かれたコアエンジンによる高速な検証
- **豊富な機能**: カスタムバリデーター、計算フィールド、設定管理など
- **エコシステム**: FastAPI、Django Ninjaなど多くのライブラリで使用

Pydanticを使用することで、型安全で保守性の高いPythonアプリケーションを構築できます。

## 次のステップ

- FastAPIでのAPI開発
- データベースORMとの統合
- カスタムバリデーターの高度な使い方
- JSON Schemaの活用
- パフォーマンス最適化のテクニック
