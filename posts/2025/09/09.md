---
date: 2025-09-09
title: TypeScriptと数学で作るゲームアルゴリズム：初心者向け実践ガイド
description: TypeScriptと数学を組み合わせてゲームアルゴリズムを実装する方法を解説。物理演算、パスファインディング、AI、パーティクルシステムなど、実際のゲーム開発で使われるアルゴリズムを数学的アプローチで詳しく説明します。
tags:
  - typescript
  - game-development
  - algorithms
  - mathematics
  - physics
  - pathfinding
  - ai
  - particle-systems
  - game-programming
prev:
  text: 'Google Cloud Storage 完全ガイド：初心者向け使い方と本番運用の注意点'
  link: '/posts/2025/09/08'
next:
  text: 'Cloud Run に GitHub Actions で Next.js をデプロイする完全ガイド'
  link: '/posts/2025/09/10'
---

# TypeScriptと数学で作るゲームアルゴリズム：初心者向け実践ガイド

ゲーム開発において、数学とアルゴリズムは密接に関わっています。この記事では、TypeScriptを使って実際のゲームで使用されるアルゴリズムを数学的アプローチで実装する方法を詳しく解説します。

## ゲームアルゴリズムの基礎

### 座標系とベクトル

ゲーム開発では、2D/3D空間での位置や方向を扱うためにベクトルが重要です。

```typescript
// 2Dベクトルクラス
class Vector2 {
  constructor(
    public x: number,
    public y: number,
  ) {}

  // ベクトルの加算
  add(other: Vector2): Vector2 {
    return new Vector2(this.x + other.x, this.y + other.y)
  }

  // ベクトルの減算
  subtract(other: Vector2): Vector2 {
    return new Vector2(this.x - other.x, this.y - other.y)
  }

  // スカラー倍
  multiply(scalar: number): Vector2 {
    return new Vector2(this.x * scalar, this.y * scalar)
  }

  // ベクトルの長さ（ノルム）
  magnitude(): number {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  }

  // 正規化（単位ベクトル）
  normalize(): Vector2 {
    const mag = this.magnitude()
    if (mag === 0) return new Vector2(0, 0)
    return new Vector2(this.x / mag, this.y / mag)
  }

  // 内積
  dot(other: Vector2): number {
    return this.x * other.x + this.y * other.y
  }

  // 距離計算
  distance(other: Vector2): number {
    return this.subtract(other).magnitude()
  }
}

// 使用例
const playerPos = new Vector2(100, 200)
const enemyPos = new Vector2(150, 250)
const distance = playerPos.distance(enemyPos)
console.log(`距離: ${distance}`) // 約70.71
```

### 三角関数の活用

ゲームでは回転や円運動に三角関数が頻繁に使用されます。

```typescript
// 角度から方向ベクトルを取得
function angleToVector(angleInDegrees: number): Vector2 {
  const radians = (angleInDegrees * Math.PI) / 180
  return new Vector2(Math.cos(radians), Math.sin(radians))
}

// 方向ベクトルから角度を取得
function vectorToAngle(vector: Vector2): number {
  return Math.atan2(vector.y, vector.x) * (180 / Math.PI)
}

// 円運動の実装
class CircularMotion {
  constructor(
    private center: Vector2,
    private radius: number,
    private speed: number,
  ) {}

  getPosition(time: number): Vector2 {
    const angle = time * this.speed
    const offset = angleToVector(angle).multiply(this.radius)
    return this.center.add(offset)
  }
}

// 使用例
const circularMotion = new CircularMotion(
  new Vector2(400, 300), // 中心
  100, // 半径
  0.02, // 速度
)

// アニメーションループで使用
let time = 0
function animate() {
  const position = circularMotion.getPosition(time)
  // オブジェクトを position に描画
  time += 0.016 // 60FPS想定
  requestAnimationFrame(animate)
}
```

## 物理演算アルゴリズム

### 重力と運動

```typescript
// 物理オブジェクトクラス
class PhysicsObject {
  constructor(
    public position: Vector2,
    public velocity: Vector2 = new Vector2(0, 0),
    public mass: number = 1,
    public restitution: number = 0.8, // 反発係数
  ) {}

  // 重力の適用
  applyGravity(gravity: Vector2, deltaTime: number): void {
    this.velocity = this.velocity.add(gravity.multiply(deltaTime))
  }

  // 位置の更新
  update(deltaTime: number): void {
    this.position = this.position.add(this.velocity.multiply(deltaTime))
  }

  // 力の適用
  applyForce(force: Vector2, deltaTime: number): void {
    const acceleration = force.multiply(1 / this.mass)
    this.velocity = this.velocity.add(acceleration.multiply(deltaTime))
  }
}

// 物理シミュレーション
class PhysicsSimulation {
  private objects: PhysicsObject[] = []
  private gravity = new Vector2(0, 9.8)

  addObject(obj: PhysicsObject): void {
    this.objects.push(obj)
  }

  update(deltaTime: number): void {
    for (const obj of this.objects) {
      obj.applyGravity(this.gravity, deltaTime)
      obj.update(deltaTime)

      // 地面との衝突判定
      if (obj.position.y > 400) {
        // 地面の高さ
        obj.position.y = 400
        obj.velocity.y *= -obj.restitution
      }
    }
  }
}
```

### 衝突判定

```typescript
// 円形の衝突判定
class Circle {
  constructor(
    public center: Vector2,
    public radius: number,
  ) {}

  // 円と円の衝突判定
  intersects(other: Circle): boolean {
    const distance = this.center.distance(other.center)
    return distance < this.radius + other.radius
  }

  // 円と点の衝突判定
  containsPoint(point: Vector2): boolean {
    return this.center.distance(point) <= this.radius
  }
}

// 矩形の衝突判定
class Rectangle {
  constructor(
    public x: number,
    public y: number,
    public width: number,
    public height: number,
  ) {}

  // 矩形と矩形の衝突判定（AABB）
  intersects(other: Rectangle): boolean {
    return (
      this.x < other.x + other.width &&
      this.x + this.width > other.x &&
      this.y < other.y + other.height &&
      this.y + this.height > other.y
    )
  }

  // 矩形と点の衝突判定
  containsPoint(point: Vector2): boolean {
    return (
      point.x >= this.x &&
      point.x <= this.x + this.width &&
      point.y >= this.y &&
      point.y <= this.y + this.height
    )
  }
}
```

## パスファインディングアルゴリズム

### A\*アルゴリズム

```typescript
// グリッドノード
class GridNode {
  constructor(
    public x: number,
    public y: number,
    public walkable: boolean = true,
    public gCost: number = 0, // スタートからのコスト
    public hCost: number = 0, // ゴールまでの推定コスト
    public parent: GridNode | null = null,
  ) {}

  get fCost(): number {
    return this.gCost + this.hCost
  }
}

// A*パスファインディング
class AStarPathfinding {
  private grid: GridNode[][]
  private width: number
  private height: number

  constructor(width: number, height: number) {
    this.width = width
    this.height = height
    this.grid = []

    // グリッドの初期化
    for (let x = 0; x < width; x++) {
      this.grid[x] = []
      for (let y = 0; y < height; y++) {
        this.grid[x][y] = new GridNode(x, y)
      }
    }
  }

  // 障害物の設定
  setObstacle(x: number, y: number): void {
    if (this.isValidPosition(x, y)) {
      this.grid[x][y].walkable = false
    }
  }

  // 位置の有効性チェック
  private isValidPosition(x: number, y: number): boolean {
    return x >= 0 && x < this.width && y >= 0 && y < this.height
  }

  // ヒューリスティック関数（マンハッタン距離）
  private heuristic(nodeA: GridNode, nodeB: GridNode): number {
    return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y)
  }

  // 隣接ノードの取得
  private getNeighbors(node: GridNode): GridNode[] {
    const neighbors: GridNode[] = []
    const directions = [
      [-1, -1],
      [-1, 0],
      [-1, 1],
      [0, -1],
      [0, 1],
      [1, -1],
      [1, 0],
      [1, 1],
    ]

    for (const [dx, dy] of directions) {
      const x = node.x + dx
      const y = node.y + dy

      if (this.isValidPosition(x, y) && this.grid[x][y].walkable) {
        neighbors.push(this.grid[x][y])
      }
    }

    return neighbors
  }

  // A*アルゴリズムの実装
  findPath(startX: number, startY: number, endX: number, endY: number): Vector2[] {
    const start = this.grid[startX][startY]
    const end = this.grid[endX][endY]

    const openSet: GridNode[] = [start]
    const closedSet: Set<GridNode> = new Set()

    while (openSet.length > 0) {
      // fCostが最小のノードを選択
      let currentNode = openSet[0]
      for (let i = 1; i < openSet.length; i++) {
        if (
          openSet[i].fCost < currentNode.fCost ||
          (openSet[i].fCost === currentNode.fCost && openSet[i].hCost < currentNode.hCost)
        ) {
          currentNode = openSet[i]
        }
      }

      openSet.splice(openSet.indexOf(currentNode), 1)
      closedSet.add(currentNode)

      // ゴールに到達
      if (currentNode === end) {
        return this.retracePath(start, end)
      }

      // 隣接ノードの処理
      for (const neighbor of this.getNeighbors(currentNode)) {
        if (closedSet.has(neighbor)) continue

        const newGCost = currentNode.gCost + this.heuristic(currentNode, neighbor)

        if (newGCost < neighbor.gCost || !openSet.includes(neighbor)) {
          neighbor.gCost = newGCost
          neighbor.hCost = this.heuristic(neighbor, end)
          neighbor.parent = currentNode

          if (!openSet.includes(neighbor)) {
            openSet.push(neighbor)
          }
        }
      }
    }

    return [] // パスが見つからない
  }

  // パスの再構築
  private retracePath(start: GridNode, end: GridNode): Vector2[] {
    const path: Vector2[] = []
    let currentNode = end

    while (currentNode !== start) {
      path.push(new Vector2(currentNode.x, currentNode.y))
      currentNode = currentNode.parent!
    }

    return path.reverse()
  }
}

// 使用例
const pathfinding = new AStarPathfinding(20, 20)
pathfinding.setObstacle(5, 5)
pathfinding.setObstacle(5, 6)
pathfinding.setObstacle(5, 7)

const path = pathfinding.findPath(0, 0, 19, 19)
console.log('見つかったパス:', path)
```

## AIアルゴリズム

### ステートマシン

```typescript
// ステートの基底クラス
abstract class State {
  abstract enter(entity: GameEntity): void
  abstract update(entity: GameEntity, deltaTime: number): void
  abstract exit(entity: GameEntity): void
}

// ゲームエンティティ
class GameEntity {
  public position: Vector2
  public velocity: Vector2
  public currentState: State
  public target: Vector2 | null = null

  constructor(x: number, y: number) {
    this.position = new Vector2(x, y)
    this.velocity = new Vector2(0, 0)
    this.currentState = new IdleState()
  }

  changeState(newState: State): void {
    this.currentState.exit(this)
    this.currentState = newState
    this.currentState.enter(this)
  }

  update(deltaTime: number): void {
    this.currentState.update(this, deltaTime)
  }
}

// アイドル状態
class IdleState extends State {
  enter(entity: GameEntity): void {
    console.log('アイドル状態に入りました')
  }

  update(entity: GameEntity, deltaTime: number): void {
    // プレイヤーが近づいたら追跡状態に移行
    const playerDistance = entity.position.distance(new Vector2(400, 300))
    if (playerDistance < 100) {
      entity.changeState(new ChaseState())
    }
  }

  exit(entity: GameEntity): void {
    console.log('アイドル状態を終了しました')
  }
}

// 追跡状態
class ChaseState extends State {
  enter(entity: GameEntity): void {
    console.log('追跡状態に入りました')
    entity.target = new Vector2(400, 300) // プレイヤーの位置
  }

  update(entity: GameEntity, deltaTime: number): void {
    if (entity.target) {
      const direction = entity.target.subtract(entity.position).normalize()
      entity.velocity = direction.multiply(50) // 移動速度
      entity.position = entity.position.add(entity.velocity.multiply(deltaTime))

      // プレイヤーから離れたらアイドル状態に戻る
      const distance = entity.position.distance(entity.target)
      if (distance > 150) {
        entity.changeState(new IdleState())
      }
    }
  }

  exit(entity: GameEntity): void {
    console.log('追跡状態を終了しました')
    entity.target = null
  }
}
```

### フロッキング（群れ行動）

```typescript
// フロッキングエージェント
class FlockingAgent {
  constructor(
    public position: Vector2,
    public velocity: Vector2 = new Vector2(0, 0),
    public maxSpeed: number = 50,
    public maxForce: number = 2,
  ) {}

  // 分離（他のエージェントから離れる）
  separate(agents: FlockingAgent[]): Vector2 {
    const desiredSeparation = 25
    const steer = new Vector2(0, 0)
    let count = 0

    for (const agent of agents) {
      const distance = this.position.distance(agent.position)
      if (distance > 0 && distance < desiredSeparation) {
        const diff = this.position.subtract(agent.position)
        diff.normalize()
        diff.multiply(1 / distance) // 距離に反比例
        steer.add(diff)
        count++
      }
    }

    if (count > 0) {
      steer.multiply(1 / count)
      steer.normalize()
      steer.multiply(this.maxSpeed)
      steer.subtract(this.velocity)
      steer.multiply(Math.min(steer.magnitude(), this.maxForce))
    }

    return steer
  }

  // 整列（他のエージェントと同じ方向に移動）
  align(agents: FlockingAgent[]): Vector2 {
    const neighborDist = 50
    const sum = new Vector2(0, 0)
    let count = 0

    for (const agent of agents) {
      const distance = this.position.distance(agent.position)
      if (distance > 0 && distance < neighborDist) {
        sum.add(agent.velocity)
        count++
      }
    }

    if (count > 0) {
      sum.multiply(1 / count)
      sum.normalize()
      sum.multiply(this.maxSpeed)
      const steer = sum.subtract(this.velocity)
      steer.multiply(Math.min(steer.magnitude(), this.maxForce))
      return steer
    }

    return new Vector2(0, 0)
  }

  // 結合（他のエージェントの中心に向かう）
  cohesion(agents: FlockingAgent[]): Vector2 {
    const neighborDist = 50
    const sum = new Vector2(0, 0)
    let count = 0

    for (const agent of agents) {
      const distance = this.position.distance(agent.position)
      if (distance > 0 && distance < neighborDist) {
        sum.add(agent.position)
        count++
      }
    }

    if (count > 0) {
      sum.multiply(1 / count)
      return this.seek(sum)
    }

    return new Vector2(0, 0)
  }

  // 特定の位置に向かう
  seek(target: Vector2): Vector2 {
    const desired = target.subtract(this.position)
    desired.normalize()
    desired.multiply(this.maxSpeed)

    const steer = desired.subtract(this.velocity)
    steer.multiply(Math.min(steer.magnitude(), this.maxForce))
    return steer
  }

  // フロッキングの更新
  flock(agents: FlockingAgent[]): void {
    const sep = this.separate(agents).multiply(1.5)
    const ali = this.align(agents).multiply(1.0)
    const coh = this.cohesion(agents).multiply(1.0)

    this.velocity.add(sep)
    this.velocity.add(ali)
    this.velocity.add(coh)

    // 速度制限
    if (this.velocity.magnitude() > this.maxSpeed) {
      this.velocity.normalize().multiply(this.maxSpeed)
    }

    this.position.add(this.velocity)
  }
}
```

## パーティクルシステム

```typescript
// パーティクル
class Particle {
  constructor(
    public position: Vector2,
    public velocity: Vector2,
    public life: number,
    public maxLife: number,
    public size: number,
    public color: string,
  ) {}

  update(deltaTime: number): boolean {
    this.position.add(this.velocity.multiply(deltaTime))
    this.life -= deltaTime

    // 重力の適用
    this.velocity.y += 9.8 * deltaTime

    return this.life > 0
  }

  getAlpha(): number {
    return this.life / this.maxLife
  }
}

// パーティクルシステム
class ParticleSystem {
  private particles: Particle[] = []
  private gravity = new Vector2(0, 9.8)

  // パーティクルの生成
  emit(position: Vector2, count: number = 10): void {
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count
      const speed = 50 + Math.random() * 100
      const velocity = new Vector2(
        Math.cos(angle) * speed,
        Math.sin(angle) * speed - 50, // 上向きの初期速度
      )

      const particle = new Particle(
        position,
        velocity,
        2.0, // 寿命
        2.0,
        2 + Math.random() * 4, // サイズ
        `hsl(${Math.random() * 60 + 15}, 100%, 50%)`, // オレンジ系の色
      )

      this.particles.push(particle)
    }
  }

  // システムの更新
  update(deltaTime: number): void {
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const particle = this.particles[i]
      if (!particle.update(deltaTime)) {
        this.particles.splice(i, 1)
      }
    }
  }

  // パーティクルの描画（Canvas用）
  render(ctx: CanvasRenderingContext2D): void {
    for (const particle of this.particles) {
      ctx.save()
      ctx.globalAlpha = particle.getAlpha()
      ctx.fillStyle = particle.color
      ctx.beginPath()
      ctx.arc(particle.position.x, particle.position.y, particle.size, 0, Math.PI * 2)
      ctx.fill()
      ctx.restore()
    }
  }
}
```

## ノイズ生成アルゴリズム

### パーリンノイズ

```typescript
// 簡易版パーリンノイズ
class PerlinNoise {
  private permutation: number[] = []

  constructor(seed: number = 0) {
    this.generatePermutation(seed)
  }

  private generatePermutation(seed: number): void {
    const p: number[] = []
    for (let i = 0; i < 256; i++) {
      p[i] = i
    }

    // シードに基づいてシャッフル
    let rng = seed
    for (let i = 255; i > 0; i--) {
      rng = (rng * 9301 + 49297) % 233280
      const j = Math.floor((rng / 233280) * (i + 1))
      ;[p[i], p[j]] = [p[j], p[i]]
    }

    // 配列を2倍にして繰り返し
    this.permutation = [...p, ...p]
  }

  private fade(t: number): number {
    return t * t * t * (t * (t * 6 - 15) + 10)
  }

  private lerp(t: number, a: number, b: number): number {
    return a + t * (b - a)
  }

  private grad(hash: number, x: number, y: number): number {
    const h = hash & 3
    const u = h < 2 ? x : y
    const v = h < 2 ? y : x
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)
  }

  noise(x: number, y: number): number {
    const X = Math.floor(x) & 255
    const Y = Math.floor(y) & 255

    x -= Math.floor(x)
    y -= Math.floor(y)

    const u = this.fade(x)
    const v = this.fade(y)

    const A = this.permutation[X] + Y
    const AA = this.permutation[A]
    const AB = this.permutation[A + 1]
    const B = this.permutation[X + 1] + Y
    const BA = this.permutation[B]
    const BB = this.permutation[B + 1]

    return this.lerp(
      v,
      this.lerp(
        u,
        this.grad(this.permutation[AA], x, y),
        this.grad(this.permutation[BA], x - 1, y),
      ),
      this.lerp(
        u,
        this.grad(this.permutation[AB], x, y - 1),
        this.grad(this.permutation[BB], x - 1, y - 1),
      ),
    )
  }
}

// 使用例：地形生成
class TerrainGenerator {
  private noise: PerlinNoise

  constructor(seed: number = 0) {
    this.noise = new PerlinNoise(seed)
  }

  generateHeight(x: number, y: number): number {
    let height = 0
    let amplitude = 1
    let frequency = 0.01
    let maxValue = 0

    // オクターブを重ね合わせる
    for (let i = 0; i < 4; i++) {
      height += this.noise.noise(x * frequency, y * frequency) * amplitude
      maxValue += amplitude
      amplitude *= 0.5
      frequency *= 2
    }

    return height / maxValue
  }
}
```

## まとめ

TypeScriptと数学を組み合わせることで、以下のようなゲームアルゴリズムを実装できます：

### 実装したアルゴリズム

1. **ベクトル演算**: 位置、速度、方向の計算
2. **物理演算**: 重力、衝突、運動のシミュレーション
3. **パスファインディング**: A\*アルゴリズムによる最適経路探索
4. **AI**: ステートマシンとフロッキングによる知的行動
5. **パーティクルシステム**: 視覚効果の生成
6. **ノイズ生成**: パーリンノイズによる自然な地形生成

### 数学の重要性

- **線形代数**: ベクトル演算、座標変換
- **三角関数**: 回転、円運動、角度計算
- **確率・統計**: ランダム生成、ノイズ
- **最適化理論**: パスファインディング、AI

### 実践のポイント

- **パフォーマンス**: 計算量を考慮した効率的な実装
- **可読性**: 数学的概念を分かりやすいコードで表現
- **拡張性**: モジュール化による再利用可能な設計
- **デバッグ**: 視覚化による動作確認

これらのアルゴリズムを組み合わせることで、複雑で魅力的なゲーム体験を創造できます。まずは基本的なベクトル演算から始めて、徐々に高度なアルゴリズムに挑戦してみてください。
