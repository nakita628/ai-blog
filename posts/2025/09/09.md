---
date: 2025-09-09
title: TypeScriptと数学で作るゲームアルゴリズム：初心者向け実践ガイド
description: TypeScriptと数学を組み合わせてゲームアルゴリズムを実装する方法を解説。物理演算、パスファインディング、AI、パーティクルシステムなど、実際のゲーム開発で使われるアルゴリズムを数学的アプローチで詳しく説明します。
tags:
    - typescript
    - game-development
    - algorithms
    - mathematics
    - physics
    - pathfinding
    - ai
    - particle-systems
    - game-programming
prev:
    text: "Google Cloud Storage 完全ガイド：初心者向け使い方と本番運用の注意点"
    link: "/posts/2025/09/08"
next:
    text: "Cloud Run に GitHub Actions で Next.js をデプロイする完全ガイド"
    link: "/posts/2025/09/10"
---

# TypeScriptと数学で作るゲームアルゴリズム：初心者向け実践ガイド

ゲーム開発において、数学とアルゴリズムは密接に関わっています。この記事では、TypeScriptを使って実際のゲームで使用されるアルゴリズムを数学的アプローチで実装する方法を詳しく解説します。

## ゲームアルゴリズムの基礎

### 座標系とベクトル

ゲーム開発では、2D/3D空間での位置や方向を扱うためにベクトルが重要です。

```typescript
// 2Dベクトルクラス
class Vector2 {
  constructor(
    public x: number,
    public y: number
  ) {}

  // ベクトルの加算
  add(other: Vector2): Vector2 {
    return new Vector2(this.x + other.x, this.y + other.y);
  }

  // ベクトルの減算
  subtract(other: Vector2): Vector2 {
    return new Vector2(this.x - other.x, this.y - other.y);
  }

  // スカラー倍
  multiply(scalar: number): Vector2 {
    return new Vector2(this.x * scalar, this.y * scalar);
  }

  // ベクトルの長さ（ノルム）
  magnitude(): number {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }

  // 正規化（単位ベクトル）
  normalize(): Vector2 {
    const mag = this.magnitude();
    if (mag === 0) return new Vector2(0, 0);
    return new Vector2(this.x / mag, this.y / mag);
  }

  // 内積
  dot(other: Vector2): number {
    return this.x * other.x + this.y * other.y;
  }

  // 距離計算
  distance(other: Vector2): number {
    return this.subtract(other).magnitude();
  }
}

// 使用例
const playerPos = new Vector2(100, 200);
const enemyPos = new Vector2(150, 250);
const distance = playerPos.distance(enemyPos);
console.log(`距離: ${distance}`); // 約70.71
```

### 三角関数の活用

ゲームでは回転や円運動に三角関数が頻繁に使用されます。

```typescript
// 角度から方向ベクトルを取得
function angleToVector(angleInDegrees: number): Vector2 {
  const radians = (angleInDegrees * Math.PI) / 180;
  return new Vector2(
    Math.cos(radians),
    Math.sin(radians)
  );
}

// 方向ベクトルから角度を取得
function vectorToAngle(vector: Vector2): number {
  return Math.atan2(vector.y, vector.x) * (180 / Math.PI);
}

// 円運動の実装
class CircularMotion {
  constructor(
    private center: Vector2,
    private radius: number,
    private speed: number
  ) {}

  getPosition(time: number): Vector2 {
    const angle = time * this.speed;
    const offset = angleToVector(angle).multiply(this.radius);
    return this.center.add(offset);
  }
}

// 使用例
const circularMotion = new CircularMotion(
  new Vector2(400, 300), // 中心
  100, // 半径
  0.02 // 速度
);

// アニメーションループで使用
let time = 0;
function animate() {
  const position = circularMotion.getPosition(time);
  // オブジェクトを position に描画
  time += 0.016; // 60FPS想定
  requestAnimationFrame(animate);
}
```

## 物理演算アルゴリズム

### 重力と運動

```typescript
// 物理オブジェクトクラス
class PhysicsObject {
  constructor(
    public position: Vector2,
    public velocity: Vector2 = new Vector2(0, 0),
    public mass: number = 1,
    public restitution: number = 0.8 // 反発係数
  ) {}

  // 重力の適用
  applyGravity(gravity: Vector2, deltaTime: number): void {
    this.velocity = this.velocity.add(gravity.multiply(deltaTime));
  }

  // 位置の更新
  update(deltaTime: number): void {
    this.position = this.position.add(this.velocity.multiply(deltaTime));
  }

  // 力の適用
  applyForce(force: Vector2, deltaTime: number): void {
    const acceleration = force.multiply(1 / this.mass);
    this.velocity = this.velocity.add(acceleration.multiply(deltaTime));
  }
}

// 物理シミュレーション
class PhysicsSimulation {
  private objects: PhysicsObject[] = [];
  private gravity = new Vector2(0, 9.8);

  addObject(obj: PhysicsObject): void {
    this.objects.push(obj);
  }

  update(deltaTime: number): void {
    for (const obj of this.objects) {
      obj.applyGravity(this.gravity, deltaTime);
      obj.update(deltaTime);
      
      // 地面との衝突判定
      if (obj.position.y > 400) { // 地面の高さ
        obj.position.y = 400;
        obj.velocity.y *= -obj.restitution;
      }
    }
  }
}
```

### 衝突判定

```typescript
// 円形の衝突判定
class Circle {
  constructor(
    public center: Vector2,
    public radius: number
  ) {}

  // 円と円の衝突判定
  intersects(other: Circle): boolean {
    const distance = this.center.distance(other.center);
    return distance < (this.radius + other.radius);
  }

  // 円と点の衝突判定
  containsPoint(point: Vector2): boolean {
    return this.center.distance(point) <= this.radius;
  }
}

// 矩形の衝突判定
class Rectangle {
  constructor(
    public x: number,
    public y: number,
    public width: number,
    public height: number
  ) {}

  // 矩形と矩形の衝突判定（AABB）
  intersects(other: Rectangle): boolean {
    return (
      this.x < other.x + other.width &&
      this.x + this.width > other.x &&
      this.y < other.y + other.height &&
      this.y + this.height > other.y
    );
  }

  // 矩形と点の衝突判定
  containsPoint(point: Vector2): boolean {
    return (
      point.x >= this.x &&
      point.x <= this.x + this.width &&
      point.y >= this.y &&
      point.y <= this.y + this.height
    );
  }
}
```

## パスファインディングアルゴリズム

### A*アルゴリズム

```typescript
// グリッドノード
class GridNode {
  constructor(
    public x: number,
    public y: number,
    public walkable: boolean = true,
    public gCost: number = 0, // スタートからのコスト
    public hCost: number = 0, // ゴールまでの推定コスト
    public parent: GridNode | null = null
  ) {}

  get fCost(): number {
    return this.gCost + this.hCost;
  }
}

// A*パスファインディング
class AStarPathfinding {
  private grid: GridNode[][];
  private width: number;
  private height: number;

  constructor(width: number, height: number) {
    this.width = width;
    this.height = height;
    this.grid = [];
    
    // グリッドの初期化
    for (let x = 0; x < width; x++) {
      this.grid[x] = [];
      for (let y = 0; y < height; y++) {
        this.grid[x][y] = new GridNode(x, y);
      }
    }
  }

  // 障害物の設定
  setObstacle(x: number, y: number): void {
    if (this.isValidPosition(x, y)) {
      this.grid[x][y].walkable = false;
    }
  }

  // 位置の有効性チェック
  private isValidPosition(x: number, y: number): boolean {
    return x >= 0 && x < this.width && y >= 0 && y < this.height;
  }

  // ヒューリスティック関数（マンハッタン距離）
  private heuristic(nodeA: GridNode, nodeB: GridNode): number {
    return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y);
  }

  // 隣接ノードの取得
  private getNeighbors(node: GridNode): GridNode[] {
    const neighbors: GridNode[] = [];
    const directions = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],           [0, 1],
      [1, -1],  [1, 0],  [1, 1]
    ];

    for (const [dx, dy] of directions) {
      const x = node.x + dx;
      const y = node.y + dy;
      
      if (this.isValidPosition(x, y) && this.grid[x][y].walkable) {
        neighbors.push(this.grid[x][y]);
      }
    }

    return neighbors;
  }

  // A*アルゴリズムの実装
  findPath(startX: number, startY: number, endX: number, endY: number): Vector2[] {
    const start = this.grid[startX][startY];
    const end = this.grid[endX][endY];

    const openSet: GridNode[] = [start];
    const closedSet: Set<GridNode> = new Set();

    while (openSet.length > 0) {
      // fCostが最小のノードを選択
      let currentNode = openSet[0];
      for (let i = 1; i < openSet.length; i++) {
        if (openSet[i].fCost < currentNode.fCost || 
            (openSet[i].fCost === currentNode.fCost && openSet[i].hCost < currentNode.hCost)) {
          currentNode = openSet[i];
        }
      }

      openSet.splice(openSet.indexOf(currentNode), 1);
      closedSet.add(currentNode);

      // ゴールに到達
      if (currentNode === end) {
        return this.retracePath(start, end);
      }

      // 隣接ノードの処理
      for (const neighbor of this.getNeighbors(currentNode)) {
        if (closedSet.has(neighbor)) continue;

        const newGCost = currentNode.gCost + this.heuristic(currentNode, neighbor);
        
        if (newGCost < neighbor.gCost || !openSet.includes(neighbor)) {
          neighbor.gCost = newGCost;
          neighbor.hCost = this.heuristic(neighbor, end);
          neighbor.parent = currentNode;

          if (!openSet.includes(neighbor)) {
            openSet.push(neighbor);
          }
        }
      }
    }

    return []; // パスが見つからない
  }

  // パスの再構築
  private retracePath(start: GridNode, end: GridNode): Vector2[] {
    const path: Vector2[] = [];
    let currentNode = end;

    while (currentNode !== start) {
      path.push(new Vector2(currentNode.x, currentNode.y));
      currentNode = currentNode.parent!;
    }

    return path.reverse();
  }
}

// 使用例
const pathfinding = new AStarPathfinding(20, 20);
pathfinding.setObstacle(5, 5);
pathfinding.setObstacle(5, 6);
pathfinding.setObstacle(5, 7);

const path = pathfinding.findPath(0, 0, 19, 19);
console.log('見つかったパス:', path);
```

## AIアルゴリズム

### ステートマシン

```typescript
// ステートの基底クラス
abstract class State {
  abstract enter(entity: GameEntity): void;
  abstract update(entity: GameEntity, deltaTime: number): void;
  abstract exit(entity: GameEntity): void;
}

// ゲームエンティティ
class GameEntity {
  public position: Vector2;
  public velocity: Vector2;
  public currentState: State;
  public target: Vector2 | null = null;

  constructor(x: number, y: number) {
    this.position = new Vector2(x, y);
    this.velocity = new Vector2(0, 0);
    this.currentState = new IdleState();
  }

  changeState(newState: State): void {
    this.currentState.exit(this);
    this.currentState = newState;
    this.currentState.enter(this);
  }

  update(deltaTime: number): void {
    this.currentState.update(this, deltaTime);
  }
}

// アイドル状態
class IdleState extends State {
  enter(entity: GameEntity): void {
    console.log('アイドル状態に入りました');
  }

  update(entity: GameEntity, deltaTime: number): void {
    // プレイヤーが近づいたら追跡状態に移行
    const playerDistance = entity.position.distance(new Vector2(400, 300));
    if (playerDistance < 100) {
      entity.changeState(new ChaseState());
    }
  }

  exit(entity: GameEntity): void {
    console.log('アイドル状態を終了しました');
  }
}

// 追跡状態
class ChaseState extends State {
  enter(entity: GameEntity): void {
    console.log('追跡状態に入りました');
    entity.target = new Vector2(400, 300); // プレイヤーの位置
  }

  update(entity: GameEntity, deltaTime: number): void {
    if (entity.target) {
      const direction = entity.target.subtract(entity.position).normalize();
      entity.velocity = direction.multiply(50); // 移動速度
      entity.position = entity.position.add(entity.velocity.multiply(deltaTime));

      // プレイヤーから離れたらアイドル状態に戻る
      const distance = entity.position.distance(entity.target);
      if (distance > 150) {
        entity.changeState(new IdleState());
      }
    }
  }

  exit(entity: GameEntity): void {
    console.log('追跡状態を終了しました');
    entity.target = null;
  }
}
```

### フロッキング（群れ行動）

```typescript
// フロッキングエージェント
class FlockingAgent {
  constructor(
    public position: Vector2,
    public velocity: Vector2 = new Vector2(0, 0),
    public maxSpeed: number = 50,
    public maxForce: number = 2
  ) {}

  // 分離（他のエージェントから離れる）
  separate(agents: FlockingAgent[]): Vector2 {
    const desiredSeparation = 25;
    const steer = new Vector2(0, 0);
    let count = 0;

    for (const agent of agents) {
      const distance = this.position.distance(agent.position);
      if (distance > 0 && distance < desiredSeparation) {
        const diff = this.position.subtract(agent.position);
        diff.normalize();
        diff.multiply(1 / distance); // 距離に反比例
        steer.add(diff);
        count++;
      }
    }

    if (count > 0) {
      steer.multiply(1 / count);
      steer.normalize();
      steer.multiply(this.maxSpeed);
      steer.subtract(this.velocity);
      steer.multiply(Math.min(steer.magnitude(), this.maxForce));
    }

    return steer;
  }

  // 整列（他のエージェントと同じ方向に移動）
  align(agents: FlockingAgent[]): Vector2 {
    const neighborDist = 50;
    const sum = new Vector2(0, 0);
    let count = 0;

    for (const agent of agents) {
      const distance = this.position.distance(agent.position);
      if (distance > 0 && distance < neighborDist) {
        sum.add(agent.velocity);
        count++;
      }
    }

    if (count > 0) {
      sum.multiply(1 / count);
      sum.normalize();
      sum.multiply(this.maxSpeed);
      const steer = sum.subtract(this.velocity);
      steer.multiply(Math.min(steer.magnitude(), this.maxForce));
      return steer;
    }

    return new Vector2(0, 0);
  }

  // 結合（他のエージェントの中心に向かう）
  cohesion(agents: FlockingAgent[]): Vector2 {
    const neighborDist = 50;
    const sum = new Vector2(0, 0);
    let count = 0;

    for (const agent of agents) {
      const distance = this.position.distance(agent.position);
      if (distance > 0 && distance < neighborDist) {
        sum.add(agent.position);
        count++;
      }
    }

    if (count > 0) {
      sum.multiply(1 / count);
      return this.seek(sum);
    }

    return new Vector2(0, 0);
  }

  // 特定の位置に向かう
  seek(target: Vector2): Vector2 {
    const desired = target.subtract(this.position);
    desired.normalize();
    desired.multiply(this.maxSpeed);

    const steer = desired.subtract(this.velocity);
    steer.multiply(Math.min(steer.magnitude(), this.maxForce));
    return steer;
  }

  // フロッキングの更新
  flock(agents: FlockingAgent[]): void {
    const sep = this.separate(agents).multiply(1.5);
    const ali = this.align(agents).multiply(1.0);
    const coh = this.cohesion(agents).multiply(1.0);

    this.velocity.add(sep);
    this.velocity.add(ali);
    this.velocity.add(coh);

    // 速度制限
    if (this.velocity.magnitude() > this.maxSpeed) {
      this.velocity.normalize().multiply(this.maxSpeed);
    }

    this.position.add(this.velocity);
  }
}
```

## パーティクルシステム

```typescript
// パーティクル
class Particle {
  constructor(
    public position: Vector2,
    public velocity: Vector2,
    public life: number,
    public maxLife: number,
    public size: number,
    public color: string
  ) {}

  update(deltaTime: number): boolean {
    this.position.add(this.velocity.multiply(deltaTime));
    this.life -= deltaTime;
    
    // 重力の適用
    this.velocity.y += 9.8 * deltaTime;
    
    return this.life > 0;
  }

  getAlpha(): number {
    return this.life / this.maxLife;
  }
}

// パーティクルシステム
class ParticleSystem {
  private particles: Particle[] = [];
  private gravity = new Vector2(0, 9.8);

  // パーティクルの生成
  emit(position: Vector2, count: number = 10): void {
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      const speed = 50 + Math.random() * 100;
      const velocity = new Vector2(
        Math.cos(angle) * speed,
        Math.sin(angle) * speed - 50 // 上向きの初期速度
      );

      const particle = new Particle(
        position,
        velocity,
        2.0, // 寿命
        2.0,
        2 + Math.random() * 4, // サイズ
        `hsl(${Math.random() * 60 + 15}, 100%, 50%)` // オレンジ系の色
      );

      this.particles.push(particle);
    }
  }

  // システムの更新
  update(deltaTime: number): void {
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const particle = this.particles[i];
      if (!particle.update(deltaTime)) {
        this.particles.splice(i, 1);
      }
    }
  }

  // パーティクルの描画（Canvas用）
  render(ctx: CanvasRenderingContext2D): void {
    for (const particle of this.particles) {
      ctx.save();
      ctx.globalAlpha = particle.getAlpha();
      ctx.fillStyle = particle.color;
      ctx.beginPath();
      ctx.arc(particle.position.x, particle.position.y, particle.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }
}
```

## ノイズ生成アルゴリズム

### パーリンノイズ

```typescript
// 簡易版パーリンノイズ
class PerlinNoise {
  private permutation: number[] = [];

  constructor(seed: number = 0) {
    this.generatePermutation(seed);
  }

  private generatePermutation(seed: number): void {
    const p: number[] = [];
    for (let i = 0; i < 256; i++) {
      p[i] = i;
    }

    // シードに基づいてシャッフル
    let rng = seed;
    for (let i = 255; i > 0; i--) {
      rng = (rng * 9301 + 49297) % 233280;
      const j = Math.floor((rng / 233280) * (i + 1));
      [p[i], p[j]] = [p[j], p[i]];
    }

    // 配列を2倍にして繰り返し
    this.permutation = [...p, ...p];
  }

  private fade(t: number): number {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }

  private lerp(t: number, a: number, b: number): number {
    return a + t * (b - a);
  }

  private grad(hash: number, x: number, y: number): number {
    const h = hash & 3;
    const u = h < 2 ? x : y;
    const v = h < 2 ? y : x;
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
  }

  noise(x: number, y: number): number {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;

    x -= Math.floor(x);
    y -= Math.floor(y);

    const u = this.fade(x);
    const v = this.fade(y);

    const A = this.permutation[X] + Y;
    const AA = this.permutation[A];
    const AB = this.permutation[A + 1];
    const B = this.permutation[X + 1] + Y;
    const BA = this.permutation[B];
    const BB = this.permutation[B + 1];

    return this.lerp(
      v,
      this.lerp(
        u,
        this.grad(this.permutation[AA], x, y),
        this.grad(this.permutation[BA], x - 1, y)
      ),
      this.lerp(
        u,
        this.grad(this.permutation[AB], x, y - 1),
        this.grad(this.permutation[BB], x - 1, y - 1)
      )
    );
  }
}

// 使用例：地形生成
class TerrainGenerator {
  private noise: PerlinNoise;

  constructor(seed: number = 0) {
    this.noise = new PerlinNoise(seed);
  }

  generateHeight(x: number, y: number): number {
    let height = 0;
    let amplitude = 1;
    let frequency = 0.01;
    let maxValue = 0;

    // オクターブを重ね合わせる
    for (let i = 0; i < 4; i++) {
      height += this.noise.noise(x * frequency, y * frequency) * amplitude;
      maxValue += amplitude;
      amplitude *= 0.5;
      frequency *= 2;
    }

    return height / maxValue;
  }
}
```

## まとめ

TypeScriptと数学を組み合わせることで、以下のようなゲームアルゴリズムを実装できます：

### 実装したアルゴリズム

1. **ベクトル演算**: 位置、速度、方向の計算
2. **物理演算**: 重力、衝突、運動のシミュレーション
3. **パスファインディング**: A*アルゴリズムによる最適経路探索
4. **AI**: ステートマシンとフロッキングによる知的行動
5. **パーティクルシステム**: 視覚効果の生成
6. **ノイズ生成**: パーリンノイズによる自然な地形生成

### 数学の重要性

- **線形代数**: ベクトル演算、座標変換
- **三角関数**: 回転、円運動、角度計算
- **確率・統計**: ランダム生成、ノイズ
- **最適化理論**: パスファインディング、AI

### 実践のポイント

- **パフォーマンス**: 計算量を考慮した効率的な実装
- **可読性**: 数学的概念を分かりやすいコードで表現
- **拡張性**: モジュール化による再利用可能な設計
- **デバッグ**: 視覚化による動作確認

これらのアルゴリズムを組み合わせることで、複雑で魅力的なゲーム体験を創造できます。まずは基本的なベクトル演算から始めて、徐々に高度なアルゴリズムに挑戦してみてください。
