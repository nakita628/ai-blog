---
date: 2025-09-24
title: SWRとHono RPCで作る型安全なフルスタックアプリ：React + TypeScript完全ガイド
description: SWRとHonoのRPC機能を組み合わせて、型安全なフルスタックアプリケーションを構築する方法を初心者向けに解説。サーバーとクライアント間の型共有から実践的な実装まで詳しく説明する。
tags:
  - swr
  - hono
  - rpc
  - react
  - typescript
  - fullstack
  - data-fetching
prev:
  text: 'Pydantic完全ガイド：Pythonのデータ検証ライブラリを初心者向けに解説'
  link: '/posts/2025/09/23'
next:
  text: 'Laravel入門完全ガイド：PHPフレームワークの王者を初心者向けに解説'
  link: '/posts/2025/09/25'
---

# SWRとHono RPCで作る型安全なフルスタックアプリ：React + TypeScript完全ガイド

[SWR](https://swr.vercel.app/ja)と[Hono RPC](https://hono.dev/docs/guides/rpc)を組み合わせることで、型安全で高性能なフルスタックアプリケーションを構築できます。サーバーとクライアント間でAPI仕様を共有し、リアルタイムなデータ取得を実現する方法を詳しく解説します。

## なぜSWRとHono RPCを組み合わせるのか

### SWRの特徴

- **stale-while-revalidate戦略**: キャッシュから即座にデータを返し、バックグラウンドで最新データを取得
- **自動再検証**: フォーカス時やネットワーク復旧時に自動的にデータを更新
- **リアルタイム体験**: ユーザーは常に最新のデータを見ることができる

### Hono RPCの特徴

- **型安全**: サーバーとクライアント間でAPI仕様を共有
- **自動推論**: TypeScriptの型推論により、コンパイル時にエラーを検出
- **開発効率**: API仕様の変更が自動的にクライアントに反映

## プロジェクトのセットアップ

### 必要なパッケージのインストール

```bash
# サーバー側
npm install hono @hono/zod-validator zod

# クライアント側
npm install swr hono/client
```

### プロジェクト構成

```
my-app/
├── server/
│   ├── index.ts
│   ├── routes/
│   │   ├── users.ts
│   │   └── posts.ts
│   └── types.ts
├── client/
│   ├── src/
│   │   ├── components/
│   │   ├── hooks/
│   │   └── lib/
│   └── package.json
└── shared/
    └── types.ts
```

## サーバー側の実装

### 基本的なHonoアプリケーション

```typescript
// server/index.ts
import { Hono } from 'hono'
import { zValidator } from '@hono/zod-validator'
import { z } from 'zod'
import { cors } from 'hono/cors'

const app = new Hono()

// CORS設定
app.use(
  '*',
  cors({
    origin: 'http://localhost:3000',
    credentials: true,
  }),
)

// ユーザー関連のルート
app.get('/users', async (c) => {
  // 実際のアプリではデータベースから取得
  const users = [
    { id: 1, name: '田中太郎', email: 'tanaka@example.com' },
    { id: 2, name: '佐藤花子', email: 'sato@example.com' },
    { id: 3, name: '鈴木一郎', email: 'suzuki@example.com' },
  ]

  return c.json({ users })
})

// ユーザー作成のバリデーションスキーマ
const createUserSchema = z.object({
  name: z.string().min(1, '名前は必須です'),
  email: z.string().email('有効なメールアドレスを入力してください'),
})

app.post('/users', zValidator('json', createUserSchema), async (c) => {
  const { name, email } = c.req.valid('json')

  // 実際のアプリではデータベースに保存
  const newUser = {
    id: Date.now(), // 簡易的なID生成
    name,
    email,
    createdAt: new Date().toISOString(),
  }

  return c.json({ user: newUser }, 201)
})

// 特定のユーザー取得
app.get('/users/:id', async (c) => {
  const id = parseInt(c.req.param('id'))

  // 実際のアプリではデータベースから取得
  const user = {
    id,
    name: '田中太郎',
    email: 'tanaka@example.com',
    createdAt: '2023-01-01T00:00:00Z',
  }

  if (!user) {
    return c.json({ error: 'ユーザーが見つかりません' }, 404)
  }

  return c.json({ user })
})

// 投稿関連のルート
app.get('/posts', async (c) => {
  const posts = [
    {
      id: 1,
      title: 'SWRとHono RPCの組み合わせ',
      content: '型安全なフルスタックアプリの構築方法',
      authorId: 1,
      createdAt: '2023-01-01T00:00:00Z',
    },
    {
      id: 2,
      title: 'React Hooksの活用',
      content: 'カスタムフックの作成とベストプラクティス',
      authorId: 2,
      createdAt: '2023-01-02T00:00:00Z',
    },
  ]

  return c.json({ posts })
})

// 投稿作成のバリデーションスキーマ
const createPostSchema = z.object({
  title: z.string().min(1, 'タイトルは必須です'),
  content: z.string().min(1, '内容は必須です'),
  authorId: z.number().int().positive('有効な作者IDを入力してください'),
})

app.post('/posts', zValidator('json', createPostSchema), async (c) => {
  const { title, content, authorId } = c.req.valid('json')

  const newPost = {
    id: Date.now(),
    title,
    content,
    authorId,
    createdAt: new Date().toISOString(),
  }

  return c.json({ post: newPost }, 201)
})

// アプリケーションの型をエクスポート
export type AppType = typeof app

export default app
```

### 型定義の共有

```typescript
// shared/types.ts
export interface User {
  id: number
  name: string
  email: string
  createdAt: string
}

export interface Post {
  id: number
  title: string
  content: string
  authorId: number
  createdAt: string
}

export interface CreateUserRequest {
  name: string
  email: string
}

export interface CreatePostRequest {
  title: string
  content: string
  authorId: number
}
```

## クライアント側の実装

### Honoクライアントの設定

```typescript
// client/src/lib/api.ts
import { hc } from 'hono/client'
import type { AppType } from '../../server/index'

// Honoクライアントの作成
export const client = hc<AppType>('http://localhost:8787', {
  init: {
    credentials: 'include',
  },
})

// 型安全なAPI呼び出しのヘルパー関数
export const api = {
  // ユーザー関連
  getUsers: () => client.users.$get(),
  getUser: (id: number) => client.users[':id'].$get({ param: { id: id.toString() } }),
  createUser: (data: { name: string; email: string }) => client.users.$post({ json: data }),

  // 投稿関連
  getPosts: () => client.posts.$get(),
  createPost: (data: { title: string; content: string; authorId: number }) =>
    client.posts.$post({ json: data }),
}
```

### SWRフックの作成

```typescript
// client/src/hooks/useUsers.ts
import useSWR from 'swr'
import { api } from '../lib/api'

// ユーザー一覧を取得するフック
export function useUsers() {
  const { data, error, isLoading, mutate } = useSWR('users', async () => {
    const response = await api.getUsers()
    if (!response.ok) {
      throw new Error('ユーザーの取得に失敗しました')
    }
    return response.json()
  })

  return {
    users: data?.users || [],
    error,
    isLoading,
    mutate,
  }
}

// 特定のユーザーを取得するフック
export function useUser(id: number) {
  const { data, error, isLoading, mutate } = useSWR(id ? `user-${id}` : null, async () => {
    const response = await api.getUser(id)
    if (!response.ok) {
      throw new Error('ユーザーの取得に失敗しました')
    }
    return response.json()
  })

  return {
    user: data?.user,
    error,
    isLoading,
    mutate,
  }
}
```

```typescript
// client/src/hooks/usePosts.ts
import useSWR from 'swr'
import { api } from '../lib/api'

// 投稿一覧を取得するフック
export function usePosts() {
  const { data, error, isLoading, mutate } = useSWR('posts', async () => {
    const response = await api.getPosts()
    if (!response.ok) {
      throw new Error('投稿の取得に失敗しました')
    }
    return response.json()
  })

  return {
    posts: data?.posts || [],
    error,
    isLoading,
    mutate,
  }
}

// 投稿作成のフック
export function useCreatePost() {
  const { mutate } = usePosts()

  const createPost = async (postData: { title: string; content: string; authorId: number }) => {
    try {
      const response = await api.createPost(postData)
      if (!response.ok) {
        throw new Error('投稿の作成に失敗しました')
      }

      // 投稿一覧を再取得
      mutate()

      return response.json()
    } catch (error) {
      console.error('投稿作成エラー:', error)
      throw error
    }
  }

  return { createPost }
}
```

### Reactコンポーネントの実装

```typescript
// client/src/components/UserList.tsx
import React from 'react'
import { useUsers } from '../hooks/useUsers'

export function UserList() {
  const { users, error, isLoading } = useUsers()

  if (isLoading) {
    return <div className="loading">ユーザーを読み込み中...</div>
  }

  if (error) {
    return <div className="error">エラー: {error.message}</div>
  }

  return (
    <div className="user-list">
      <h2>ユーザー一覧</h2>
      <ul>
        {users.map((user) => (
          <li key={user.id} className="user-item">
            <div className="user-info">
              <h3>{user.name}</h3>
              <p>{user.email}</p>
              <small>作成日: {new Date(user.createdAt).toLocaleDateString()}</small>
            </div>
          </li>
        ))}
      </ul>
    </div>
  )
}
```

```typescript
// client/src/components/PostList.tsx
import React, { useState } from 'react'
import { usePosts, useCreatePost } from '../hooks/usePosts'

export function PostList() {
  const { posts, error, isLoading } = usePosts()
  const { createPost } = useCreatePost()
  const [isCreating, setIsCreating] = useState(false)

  const handleCreatePost = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    setIsCreating(true)

    const formData = new FormData(e.currentTarget)
    const postData = {
      title: formData.get('title') as string,
      content: formData.get('content') as string,
      authorId: 1 // 実際のアプリでは認証されたユーザーのIDを使用
    }

    try {
      await createPost(postData)
      e.currentTarget.reset()
    } catch (error) {
      console.error('投稿作成エラー:', error)
    } finally {
      setIsCreating(false)
    }
  }

  if (isLoading) {
    return <div className="loading">投稿を読み込み中...</div>
  }

  if (error) {
    return <div className="error">エラー: {error.message}</div>
  }

  return (
    <div className="post-list">
      <h2>投稿一覧</h2>

      {/* 投稿作成フォーム */}
      <form onSubmit={handleCreatePost} className="create-post-form">
        <h3>新しい投稿を作成</h3>
        <div>
          <label htmlFor="title">タイトル:</label>
          <input
            type="text"
            id="title"
            name="title"
            required
            disabled={isCreating}
          />
        </div>
        <div>
          <label htmlFor="content">内容:</label>
          <textarea
            id="content"
            name="content"
            required
            disabled={isCreating}
          />
        </div>
        <button type="submit" disabled={isCreating}>
          {isCreating ? '作成中...' : '投稿を作成'}
        </button>
      </form>

      {/* 投稿一覧 */}
      <div className="posts">
        {posts.map((post) => (
          <article key={post.id} className="post-item">
            <h3>{post.title}</h3>
            <p>{post.content}</p>
            <small>
              作成日: {new Date(post.createdAt).toLocaleDateString()}
            </small>
          </article>
        ))}
      </div>
    </div>
  )
}
```

### メインアプリケーションコンポーネント

```typescript
// client/src/App.tsx
import React from 'react'
import { UserList } from './components/UserList'
import { PostList } from './components/PostList'
import './App.css'

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <h1>SWR + Hono RPC デモ</h1>
        <p>型安全なフルスタックアプリケーション</p>
      </header>

      <main className="App-main">
        <section className="users-section">
          <UserList />
        </section>

        <section className="posts-section">
          <PostList />
        </section>
      </main>
    </div>
  )
}

export default App
```

## 高度な機能の実装

### 楽観的UI更新

```typescript
// client/src/hooks/useOptimisticPosts.ts
import useSWR, { mutate } from 'swr'
import { api } from '../lib/api'

export function useOptimisticPosts() {
  const { posts, error, isLoading } = usePosts()

  const createPostOptimistic = async (postData: {
    title: string
    content: string
    authorId: number
  }) => {
    // 楽観的更新: 即座にUIに反映
    const optimisticPost = {
      id: Date.now(), // 一時的なID
      ...postData,
      createdAt: new Date().toISOString(),
    }

    // キャッシュを楽観的に更新
    mutate('posts', { posts: [...posts, optimisticPost] }, false)

    try {
      // 実際のAPI呼び出し
      const response = await api.createPost(postData)
      if (!response.ok) {
        throw new Error('投稿の作成に失敗しました')
      }

      // 成功時は実際のデータで更新
      mutate('posts')
    } catch (error) {
      // 失敗時は元の状態に戻す
      mutate('posts')
      throw error
    }
  }

  return {
    posts,
    error,
    isLoading,
    createPostOptimistic,
  }
}
```

### エラーハンドリングとリトライ

```typescript
// client/src/hooks/useSWRWithRetry.ts
import useSWR from 'swr'

export function useSWRWithRetry<T>(
  key: string,
  fetcher: () => Promise<T>,
  options?: {
    retryCount?: number
    retryDelay?: number
  },
) {
  const { retryCount = 3, retryDelay = 1000 } = options || {}

  const fetcherWithRetry = async (): Promise<T> => {
    let lastError: Error

    for (let i = 0; i <= retryCount; i++) {
      try {
        return await fetcher()
      } catch (error) {
        lastError = error as Error

        if (i < retryCount) {
          // リトライ前に待機
          await new Promise((resolve) => setTimeout(resolve, retryDelay * (i + 1)))
        }
      }
    }

    throw lastError!
  }

  return useSWR(key, fetcherWithRetry, {
    errorRetryCount: 0, // SWRの自動リトライを無効化
    onError: (error) => {
      console.error(`API呼び出し失敗 (${key}):`, error)
    },
  })
}
```

### リアルタイム更新の実装

```typescript
// client/src/hooks/useRealtimePosts.ts
import { useEffect } from 'react'
import { usePosts } from './usePosts'

export function useRealtimePosts() {
  const { posts, mutate } = usePosts()

  useEffect(() => {
    // WebSocket接続（実際の実装では適切なWebSocketライブラリを使用）
    const ws = new WebSocket('ws://localhost:8787/ws/posts')

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data)

      if (data.type === 'post_created') {
        // 新しい投稿が作成された場合、データを再取得
        mutate()
      } else if (data.type === 'post_updated') {
        // 投稿が更新された場合、データを再取得
        mutate()
      }
    }

    ws.onerror = (error) => {
      console.error('WebSocketエラー:', error)
    }

    return () => {
      ws.close()
    }
  }, [mutate])

  return { posts }
}
```

## パフォーマンス最適化

### SWRの設定最適化

```typescript
// client/src/lib/swrConfig.ts
import { SWRConfiguration } from 'swr'

export const swrConfig: SWRConfiguration = {
  // フォーカス時の再検証を有効化
  revalidateOnFocus: true,

  // ネットワーク復旧時の再検証を有効化
  revalidateOnReconnect: true,

  // ポーリング間隔（30秒）
  refreshInterval: 30000,

  // エラー時のリトライ設定
  errorRetryCount: 3,
  errorRetryInterval: 5000,

  // キャッシュの有効期限（5分）
  dedupingInterval: 300000,

  // グローバルエラーハンドラー
  onError: (error, key) => {
    console.error(`SWRエラー (${key}):`, error)

    // エラー通知の実装
    if (error.message.includes('401')) {
      // 認証エラーの場合、ログインページにリダイレクト
      window.location.href = '/login'
    }
  },
}
```

### メインアプリケーションでのSWR設定

```typescript
// client/src/main.tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import { SWRConfig } from 'swr'
import App from './App'
import { swrConfig } from './lib/swrConfig'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <SWRConfig value={swrConfig}>
      <App />
    </SWRConfig>
  </React.StrictMode>
)
```

## まとめ

SWRとHono RPCを組み合わせることで、以下の利点を得ることができます：

- **型安全性**: サーバーとクライアント間でAPI仕様を共有し、コンパイル時にエラーを検出
- **リアルタイム体験**: SWRの自動再検証により、常に最新のデータを表示
- **開発効率**: API仕様の変更が自動的にクライアントに反映
- **パフォーマンス**: キャッシュと楽観的更新により、高速なユーザー体験を提供
- **保守性**: 型安全なコードにより、バグの発生を抑制

この組み合わせにより、モダンで保守性の高いフルスタックアプリケーションを構築できます。

## 次のステップ

- 認証と認可の実装
- リアルタイム通信（WebSocket）の追加
- データベース統合（Prisma、Drizzle等）
- テストの実装（Jest、Vitest等）
- デプロイメント（Vercel、Cloudflare Workers等）
