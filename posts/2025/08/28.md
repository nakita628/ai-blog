---
date: 2025-08-28
title: TypeScript + Hono で作る軽量認証システム：JWT とセッション管理の実装ガイド
description: Honoフレームワークを使ってAuth.jsに依存しない独自の認証システムを構築する方法を解説。JWT認証、パスワードハッシュ化、ミドルウェア、セキュリティベストプラクティスまで網羅した実践ガイド。
tags:
    - typescript
    - hono
    - jwt
    - authentication
    - security
    - web-api
    - middleware
prev:
    text: "Auth.js (NextAuth v5) 完全ガイド：Prisma連携とJWTセッション両方の実装パターン"
    link: "/posts/2025/08/27"
next: false
---

# TypeScript + Hono で作る軽量認証システム：JWT とセッション管理の実装ガイド

[Hono](https://hono.dev/) は、Web標準に基づいた高速で軽量なWebアプリケーションフレームワークだ。Cloudflare Workers、Deno、Bun、Node.jsなど複数のランタイムで動作し、優れた開発体験を提供する。本記事では、Auth.jsなどの外部ライブラリに依存せず、Honoを使って独自の認証システムを構築する方法を詳しく解説する。

## なぜ独自認証システムを構築するのか

### 独自認証システムのメリット

#### 1. **完全な制御**
- 認証フローを細かくカスタマイズ可能
- ビジネス要件に合わせた柔軟な実装
- 外部依存を最小限に抑制

#### 2. **軽量性**
- 必要な機能のみを実装
- バンドルサイズの最適化
- パフォーマンスの向上

#### 3. **学習効果**
- 認証の仕組みを深く理解
- セキュリティに対する意識向上
- デバッグとメンテナンスの容易性

### 考慮すべきデメリット

#### 1. **セキュリティリスク**
- 実装ミスによる脆弱性
- セキュリティ更新の責任
- 専門知識の必要性

#### 2. **開発コスト**
- 初期実装時間の増加
- テストの複雑化
- 継続的なメンテナンス

## プロジェクトセットアップ

### 必要なパッケージのインストール

まず、プロジェクトの初期化と必要なパッケージをインストールする：

```bash
# プロジェクト初期化
mkdir hono-auth-system
cd hono-auth-system
npm init -y

# 必要なパッケージをインストール
npm install hono @hono/node-server
npm install -D typescript @types/node tsx nodemon

# 認証関連のパッケージ
npm install jsonwebtoken bcryptjs
npm install -D @types/jsonwebtoken @types/bcryptjs

# バリデーション用
npm install zod
```

### TypeScript設定

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "types": ["node"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### package.json スクリプト設定

```json
{
  "scripts": {
    "dev": "nodemon --exec tsx src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js"
  }
}
```

## 基本的なHonoアプリケーション構造

### プロジェクト構造

```
src/
├── index.ts              # エントリーポイント
├── auth/
│   ├── jwt.ts            # JWT関連ユーティリティ
│   ├── password.ts       # パスワードハッシュ化
│   └── middleware.ts     # 認証ミドルウェア
├── routes/
│   ├── auth.ts           # 認証関連ルート
│   └── protected.ts      # 保護されたルート
├── types/
│   └── auth.ts           # 型定義
└── utils/
    └── validation.ts     # バリデーション
```

### メインアプリケーション

```typescript
// src/index.ts
import { Hono } from 'hono'
import { serve } from '@hono/node-server'
import { cors } from 'hono/cors'
import { logger } from 'hono/logger'
import { prettyJSON } from 'hono/pretty-json'

import authRoutes from './routes/auth'
import protectedRoutes from './routes/protected'

const app = new Hono()

// ミドルウェア設定
app.use('*', logger())
app.use('*', prettyJSON())
app.use('*', cors({
  origin: ['http://localhost:3000', 'http://localhost:5173'],
  allowHeaders: ['Content-Type', 'Authorization'],
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE'],
  credentials: true,
}))

// ルート設定
app.route('/api/auth', authRoutes)
app.route('/api', protectedRoutes)

// ヘルスチェック
app.get('/health', (c) => {
  return c.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  })
})

// 404ハンドラー
app.notFound((c) => {
  return c.json({ error: 'Not Found' }, 404)
})

// エラーハンドラー
app.onError((err, c) => {
  console.error('Application error:', err)
  return c.json({ 
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined
  }, 500)
})

const port = Number(process.env.PORT) || 3001

console.log(`🚀 Server running on http://localhost:${port}`)
serve({
  fetch: app.fetch,
  port
})
```

## JWT認証の実装

### JWT ユーティリティ

```typescript
// src/auth/jwt.ts
import jwt from 'jsonwebtoken'
import type { User } from '../types/auth'

const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-key'
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d'
const REFRESH_TOKEN_EXPIRES_IN = process.env.REFRESH_TOKEN_EXPIRES_IN || '30d'

export interface JWTPayload {
  userId: string
  email: string
  role?: string
  iat?: number
  exp?: number
}

export class JWTService {
  /**
   * アクセストークンを生成
   */
  static generateAccessToken(user: User): string {
    const payload: JWTPayload = {
      userId: user.id,
      email: user.email,
      role: user.role,
    }

    return jwt.sign(payload, JWT_SECRET, {
      expiresIn: JWT_EXPIRES_IN,
      issuer: 'hono-auth-system',
      audience: 'hono-auth-client',
    })
  }

  /**
   * リフレッシュトークンを生成
   */
  static generateRefreshToken(user: User): string {
    const payload: JWTPayload = {
      userId: user.id,
      email: user.email,
    }

    return jwt.sign(payload, JWT_SECRET, {
      expiresIn: REFRESH_TOKEN_EXPIRES_IN,
      issuer: 'hono-auth-system',
      audience: 'hono-auth-refresh',
    })
  }

  /**
   * トークンを検証
   */
  static verifyToken(token: string): JWTPayload | null {
    try {
      const decoded = jwt.verify(token, JWT_SECRET) as JWTPayload
      return decoded
    } catch (error) {
      console.error('JWT verification failed:', error)
      return null
    }
  }

  /**
   * トークンをデコード（検証なし）
   */
  static decodeToken(token: string): JWTPayload | null {
    try {
      return jwt.decode(token) as JWTPayload
    } catch (error) {
      console.error('JWT decode failed:', error)
      return null
    }
  }

  /**
   * トークンの有効期限をチェック
   */
  static isTokenExpired(token: string): boolean {
    const decoded = this.decodeToken(token)
    if (!decoded || !decoded.exp) return true
    
    const currentTime = Math.floor(Date.now() / 1000)
    return decoded.exp < currentTime
  }

  /**
   * トークンペアを生成
   */
  static generateTokenPair(user: User) {
    return {
      accessToken: this.generateAccessToken(user),
      refreshToken: this.generateRefreshToken(user),
      expiresIn: JWT_EXPIRES_IN,
      tokenType: 'Bearer',
    }
  }
}
```

### パスワードハッシュ化

```typescript
// src/auth/password.ts
import bcrypt from 'bcryptjs'

export class PasswordService {
  private static readonly SALT_ROUNDS = 12

  /**
   * パスワードをハッシュ化
   */
  static async hashPassword(password: string): Promise<string> {
    try {
      const salt = await bcrypt.genSalt(this.SALT_ROUNDS)
      return await bcrypt.hash(password, salt)
    } catch (error) {
      console.error('Password hashing failed:', error)
      throw new Error('パスワードのハッシュ化に失敗しました')
    }
  }

  /**
   * パスワードを検証
   */
  static async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {
    try {
      return await bcrypt.compare(password, hashedPassword)
    } catch (error) {
      console.error('Password verification failed:', error)
      return false
    }
  }

  /**
   * パスワード強度をチェック
   */
  static validatePasswordStrength(password: string): {
    isValid: boolean
    errors: string[]
  } {
    const errors: string[] = []

    if (password.length < 8) {
      errors.push('パスワードは8文字以上である必要があります')
    }

    if (password.length > 128) {
      errors.push('パスワードは128文字以下である必要があります')
    }

    if (!/[a-z]/.test(password)) {
      errors.push('小文字を含む必要があります')
    }

    if (!/[A-Z]/.test(password)) {
      errors.push('大文字を含む必要があります')
    }

    if (!/\d/.test(password)) {
      errors.push('数字を含む必要があります')
    }

    if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
      errors.push('特殊文字を含む必要があります')
    }

    // よくあるパスワードパターンをチェック
    const commonPatterns = [
      /^(.)\1+$/, // 同じ文字の繰り返し
      /^(012|123|234|345|456|567|678|789|890)+/, // 連続する数字
      /^(abc|bcd|cde|def|efg|fgh|ghi|hij|ijk|jkl|klm|lmn|mno|nop|opq|pqr|qrs|rst|stu|tuv|uvw|vwx|wxy|xyz)+/i, // 連続するアルファベット
    ]

    for (const pattern of commonPatterns) {
      if (pattern.test(password)) {
        errors.push('より複雑なパスワードを使用してください')
        break
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
    }
  }
}
```

### 型定義

```typescript
// src/types/auth.ts
export interface User {
  id: string
  email: string
  name: string
  role: 'user' | 'admin'
  createdAt: Date
  updatedAt: Date
}

export interface UserWithPassword extends User {
  password: string
}

export interface LoginRequest {
  email: string
  password: string
}

export interface RegisterRequest {
  email: string
  password: string
  name: string
}

export interface AuthResponse {
  user: Omit<User, 'password'>
  accessToken: string
  refreshToken: string
  expiresIn: string
  tokenType: string
}

export interface RefreshTokenRequest {
  refreshToken: string
}

// Context拡張用の型
export interface AuthContext {
  user: User
}
```

### バリデーション

```typescript
// src/utils/validation.ts
import { z } from 'zod'

export const loginSchema = z.object({
  email: z
    .string()
    .email('有効なメールアドレスを入力してください')
    .min(1, 'メールアドレスは必須です'),
  password: z
    .string()
    .min(1, 'パスワードは必須です'),
})

export const registerSchema = z.object({
  email: z
    .string()
    .email('有効なメールアドレスを入力してください')
    .min(1, 'メールアドレスは必須です'),
  password: z
    .string()
    .min(8, 'パスワードは8文字以上である必要があります')
    .max(128, 'パスワードは128文字以下である必要があります'),
  name: z
    .string()
    .min(1, '名前は必須です')
    .max(100, '名前は100文字以下である必要があります'),
})

export const refreshTokenSchema = z.object({
  refreshToken: z
    .string()
    .min(1, 'リフレッシュトークンは必須です'),
})

export type LoginInput = z.infer<typeof loginSchema>
export type RegisterInput = z.infer<typeof registerSchema>
export type RefreshTokenInput = z.infer<typeof refreshTokenSchema>
```

## 認証ミドルウェアの実装

### 認証ミドルウェア

```typescript
// src/auth/middleware.ts
import type { Context, Next } from 'hono'
import { HTTPException } from 'hono/http-exception'
import { JWTService } from './jwt'
import type { User, AuthContext } from '../types/auth'

// 簡易的なユーザーストア（実際の実装ではデータベースを使用）
const users: Map<string, User> = new Map()

// デモ用ユーザーを追加
users.set('user1', {
  id: 'user1',
  email: 'user@example.com',
  name: 'Test User',
  role: 'user',
  createdAt: new Date(),
  updatedAt: new Date(),
})

users.set('admin1', {
  id: 'admin1',
  email: 'admin@example.com',
  name: 'Admin User',
  role: 'admin',
  createdAt: new Date(),
  updatedAt: new Date(),
})

/**
 * 認証が必要なルートを保護するミドルウェア
 */
export const authMiddleware = async (c: Context, next: Next) => {
  const authHeader = c.req.header('Authorization')
  
  if (!authHeader) {
    throw new HTTPException(401, {
      message: 'Authorization header is required'
    })
  }

  const token = authHeader.replace('Bearer ', '')
  
  if (!token) {
    throw new HTTPException(401, {
      message: 'Token is required'
    })
  }

  const payload = JWTService.verifyToken(token)
  
  if (!payload) {
    throw new HTTPException(401, {
      message: 'Invalid or expired token'
    })
  }

  // ユーザー情報を取得（実際の実装ではデータベースから取得）
  const user = users.get(payload.userId)
  
  if (!user) {
    throw new HTTPException(401, {
      message: 'User not found'
    })
  }

  // コンテキストにユーザー情報を追加
  c.set('user', user)
  
  await next()
}

/**
 * 管理者権限が必要なルートを保護するミドルウェア
 */
export const adminMiddleware = async (c: Context, next: Next) => {
  const user = c.get('user') as User
  
  if (!user || user.role !== 'admin') {
    throw new HTTPException(403, {
      message: 'Admin access required'
    })
  }
  
  await next()
}

/**
 * オプショナル認証ミドルウェア（ログイン状態を確認するが必須ではない）
 */
export const optionalAuthMiddleware = async (c: Context, next: Next) => {
  const authHeader = c.req.header('Authorization')
  
  if (authHeader) {
    const token = authHeader.replace('Bearer ', '')
    const payload = JWTService.verifyToken(token)
    
    if (payload) {
      const user = users.get(payload.userId)
      if (user) {
        c.set('user', user)
      }
    }
  }
  
  await next()
}

/**
 * レート制限ミドルウェア（簡易実装）
 */
const rateLimitStore = new Map<string, { count: number; resetTime: number }>()

export const rateLimitMiddleware = (maxRequests: number = 5, windowMs: number = 15 * 60 * 1000) => {
  return async (c: Context, next: Next) => {
    const clientIP = c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown'
    const now = Date.now()
    const windowStart = now - windowMs
    
    const clientData = rateLimitStore.get(clientIP)
    
    if (!clientData || clientData.resetTime < windowStart) {
      // 新しいウィンドウまたは期限切れ
      rateLimitStore.set(clientIP, { count: 1, resetTime: now + windowMs })
    } else if (clientData.count >= maxRequests) {
      // レート制限に引っかかった
      throw new HTTPException(429, {
        message: 'Too many requests. Please try again later.'
      })
    } else {
      // カウントを増やす
      clientData.count++
    }
    
    await next()
  }
}

// ユーザーストアのヘルパー関数（実際の実装ではデータベースサービスクラスを作成）
export const userStore = {
  findByEmail: (email: string): User | undefined => {
    for (const user of users.values()) {
      if (user.email === email) {
        return user
      }
    }
    return undefined
  },
  
  findById: (id: string): User | undefined => {
    return users.get(id)
  },
  
  create: (userData: Omit<User, 'id' | 'createdAt' | 'updatedAt'>): User => {
    const user: User = {
      ...userData,
      id: `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date(),
      updatedAt: new Date(),
    }
    users.set(user.id, user)
    return user
  },
  
  // パスワード付きユーザー用の簡易ストア
  userPasswords: new Map<string, string>(),
}
```

## 認証ルートの実装

### 認証関連ルート

```typescript
// src/routes/auth.ts
import { Hono } from 'hono'
import { HTTPException } from 'hono/http-exception'
import { JWTService } from '../auth/jwt'
import { PasswordService } from '../auth/password'
import { rateLimitMiddleware, userStore } from '../auth/middleware'
import { 
  loginSchema, 
  registerSchema, 
  refreshTokenSchema,
  type LoginInput,
  type RegisterInput,
  type RefreshTokenInput 
} from '../utils/validation'
import type { AuthResponse } from '../types/auth'

const auth = new Hono()

/**
 * ユーザー登録
 */
auth.post('/register', rateLimitMiddleware(3, 15 * 60 * 1000), async (c) => {
  try {
    const body = await c.req.json()
    const validatedData = registerSchema.parse(body) as RegisterInput

    // メールアドレスの重複チェック
    const existingUser = userStore.findByEmail(validatedData.email)
    if (existingUser) {
      throw new HTTPException(409, {
        message: 'このメールアドレスは既に使用されています'
      })
    }

    // パスワード強度チェック
    const passwordValidation = PasswordService.validatePasswordStrength(validatedData.password)
    if (!passwordValidation.isValid) {
      throw new HTTPException(400, {
        message: 'パスワードが要件を満たしていません',
        errors: passwordValidation.errors
      })
    }

    // パスワードをハッシュ化
    const hashedPassword = await PasswordService.hashPassword(validatedData.password)

    // ユーザーを作成
    const user = userStore.create({
      email: validatedData.email,
      name: validatedData.name,
      role: 'user',
    })

    // パスワードを保存（実際の実装ではデータベースに保存）
    userStore.userPasswords.set(user.id, hashedPassword)

    // JWTトークンを生成
    const tokenPair = JWTService.generateTokenPair(user)

    const response: AuthResponse = {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
      },
      ...tokenPair,
    }

    return c.json(response, 201)
  } catch (error) {
    if (error instanceof HTTPException) {
      throw error
    }

    if (error instanceof Error && error.name === 'ZodError') {
      throw new HTTPException(400, {
        message: 'バリデーションエラー',
        errors: error.message
      })
    }

    console.error('Registration error:', error)
    throw new HTTPException(500, {
      message: '登録処理中にエラーが発生しました'
    })
  }
})

/**
 * ログイン
 */
auth.post('/login', rateLimitMiddleware(5, 15 * 60 * 1000), async (c) => {
  try {
    const body = await c.req.json()
    const validatedData = loginSchema.parse(body) as LoginInput

    // ユーザーを検索
    const user = userStore.findByEmail(validatedData.email)
    if (!user) {
      // セキュリティのため、ユーザーが存在しない場合も同じエラーメッセージ
      throw new HTTPException(401, {
        message: 'メールアドレスまたはパスワードが正しくありません'
      })
    }

    // パスワードを検証
    const hashedPassword = userStore.userPasswords.get(user.id)
    if (!hashedPassword) {
      throw new HTTPException(401, {
        message: 'メールアドレスまたはパスワードが正しくありません'
      })
    }

    const isPasswordValid = await PasswordService.verifyPassword(
      validatedData.password,
      hashedPassword
    )

    if (!isPasswordValid) {
      throw new HTTPException(401, {
        message: 'メールアドレスまたはパスワードが正しくありません'
      })
    }

    // JWTトークンを生成
    const tokenPair = JWTService.generateTokenPair(user)

    const response: AuthResponse = {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
      },
      ...tokenPair,
    }

    return c.json(response)
  } catch (error) {
    if (error instanceof HTTPException) {
      throw error
    }

    if (error instanceof Error && error.name === 'ZodError') {
      throw new HTTPException(400, {
        message: 'バリデーションエラー',
        errors: error.message
      })
    }

    console.error('Login error:', error)
    throw new HTTPException(500, {
      message: 'ログイン処理中にエラーが発生しました'
    })
  }
})

/**
 * トークンリフレッシュ
 */
auth.post('/refresh', rateLimitMiddleware(10, 15 * 60 * 1000), async (c) => {
  try {
    const body = await c.req.json()
    const validatedData = refreshTokenSchema.parse(body) as RefreshTokenInput

    // リフレッシュトークンを検証
    const payload = JWTService.verifyToken(validatedData.refreshToken)
    if (!payload) {
      throw new HTTPException(401, {
        message: 'Invalid refresh token'
      })
    }

    // ユーザーを取得
    const user = userStore.findById(payload.userId)
    if (!user) {
      throw new HTTPException(401, {
        message: 'User not found'
      })
    }

    // 新しいトークンペアを生成
    const tokenPair = JWTService.generateTokenPair(user)

    return c.json(tokenPair)
  } catch (error) {
    if (error instanceof HTTPException) {
      throw error
    }

    if (error instanceof Error && error.name === 'ZodError') {
      throw new HTTPException(400, {
        message: 'バリデーションエラー',
        errors: error.message
      })
    }

    console.error('Token refresh error:', error)
    throw new HTTPException(500, {
      message: 'トークン更新処理中にエラーが発生しました'
    })
  }
})

/**
 * ログアウト（オプション：トークンブラックリスト実装時）
 */
auth.post('/logout', async (c) => {
  // 実際の実装では、トークンをブラックリストに追加
  // またはリフレッシュトークンを無効化
  return c.json({ message: 'ログアウトしました' })
})

/**
 * 現在のユーザー情報を取得
 */
import { authMiddleware } from '../auth/middleware'

auth.get('/me', authMiddleware, async (c) => {
  const user = c.get('user')
  return c.json({
    user: {
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    }
  })
})

export default auth
```

### 保護されたルート

```typescript
// src/routes/protected.ts
import { Hono } from 'hono'
import { authMiddleware, adminMiddleware } from '../auth/middleware'
import type { User } from '../types/auth'

const protected = new Hono()

/**
 * 認証が必要な一般ユーザー向けルート
 */
protected.get('/profile', authMiddleware, async (c) => {
  const user = c.get('user') as User
  
  return c.json({
    message: 'プロフィール情報',
    user: {
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role,
    }
  })
})

/**
 * 認証が必要なダッシュボード
 */
protected.get('/dashboard', authMiddleware, async (c) => {
  const user = c.get('user') as User
  
  return c.json({
    message: `こんにちは、${user.name}さん`,
    dashboardData: {
      lastLogin: new Date().toISOString(),
      notifications: [],
      stats: {
        totalPosts: 0,
        totalViews: 0,
      }
    }
  })
})

/**
 * 管理者専用ルート
 */
protected.get('/admin/users', authMiddleware, adminMiddleware, async (c) => {
  // 実際の実装では、データベースからユーザー一覧を取得
  return c.json({
    message: '管理者用ユーザー一覧',
    users: [
      { id: 'user1', email: 'user@example.com', name: 'Test User', role: 'user' },
      { id: 'admin1', email: 'admin@example.com', name: 'Admin User', role: 'admin' },
    ]
  })
})

/**
 * 管理者専用システム情報
 */
protected.get('/admin/system', authMiddleware, adminMiddleware, async (c) => {
  return c.json({
    message: 'システム情報',
    system: {
      version: '1.0.0',
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      environment: process.env.NODE_ENV || 'development',
    }
  })
})

export default protected
```

## 環境変数とセキュリティ設定

### 環境変数設定

```bash
# .env
NODE_ENV=development
PORT=3001

# JWT設定
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_EXPIRES_IN=1h
REFRESH_TOKEN_EXPIRES_IN=7d

# CORS設定
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:5173

# レート制限設定
RATE_LIMIT_MAX_REQUESTS=100
RATE_LIMIT_WINDOW_MS=900000
```

### セキュリティベストプラクティス

#### 1. **環境変数の管理**

```typescript
// src/config/env.ts
import { z } from 'zod'

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  PORT: z.string().transform(Number).default(3001),
  JWT_SECRET: z.string().min(32, 'JWT_SECRET must be at least 32 characters'),
  JWT_EXPIRES_IN: z.string().default('1h'),
  REFRESH_TOKEN_EXPIRES_IN: z.string().default('7d'),
  ALLOWED_ORIGINS: z.string().default('http://localhost:3000'),
})

export const env = envSchema.parse(process.env)
```

#### 2. **セキュリティヘッダー**

```typescript
// src/middleware/security.ts
import type { Context, Next } from 'hono'

export const securityHeaders = async (c: Context, next: Next) => {
  await next()
  
  // セキュリティヘッダーを設定
  c.header('X-Content-Type-Options', 'nosniff')
  c.header('X-Frame-Options', 'DENY')
  c.header('X-XSS-Protection', '1; mode=block')
  c.header('Referrer-Policy', 'strict-origin-when-cross-origin')
  c.header('Permissions-Policy', 'camera=(), microphone=(), geolocation=()')
  
  // HSTS（HTTPSの場合のみ）
  if (c.req.header('x-forwarded-proto') === 'https') {
    c.header('Strict-Transport-Security', 'max-age=31536000; includeSubDomains')
  }
}
```

## テストの実装

### テスト環境のセットアップ

```bash
npm install -D vitest @vitest/ui supertest @types/supertest
```

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
  },
})
```

### 認証機能のテスト

```typescript
// src/__tests__/auth.test.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { Hono } from 'hono'
import request from 'supertest'
import authRoutes from '../routes/auth'

const app = new Hono()
app.route('/api/auth', authRoutes)

describe('Authentication', () => {
  beforeEach(() => {
    // テスト前にユーザーストアをクリア
    // 実際の実装では、テスト用データベースを使用
  })

  describe('POST /api/auth/register', () => {
    it('should register a new user successfully', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'TestPassword123!',
        name: 'Test User'
      }

      const response = await request(app.fetch)
        .post('/api/auth/register')
        .send(userData)
        .expect(201)

      expect(response.body).toHaveProperty('user')
      expect(response.body).toHaveProperty('accessToken')
      expect(response.body).toHaveProperty('refreshToken')
      expect(response.body.user.email).toBe(userData.email)
      expect(response.body.user.name).toBe(userData.name)
    })

    it('should reject weak passwords', async () => {
      const userData = {
        email: 'test@example.com',
        password: '123',
        name: 'Test User'
      }

      const response = await request(app.fetch)
        .post('/api/auth/register')
        .send(userData)
        .expect(400)

      expect(response.body.message).toContain('パスワードが要件を満たしていません')
    })

    it('should reject duplicate email addresses', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'TestPassword123!',
        name: 'Test User'
      }

      // 最初の登録
      await request(app.fetch)
        .post('/api/auth/register')
        .send(userData)
        .expect(201)

      // 重複する登録
      const response = await request(app.fetch)
        .post('/api/auth/register')
        .send(userData)
        .expect(409)

      expect(response.body.message).toContain('既に使用されています')
    })
  })

  describe('POST /api/auth/login', () => {
    it('should login with valid credentials', async () => {
      // まずユーザーを登録
      const userData = {
        email: 'test@example.com',
        password: 'TestPassword123!',
        name: 'Test User'
      }

      await request(app.fetch)
        .post('/api/auth/register')
        .send(userData)
        .expect(201)

      // ログインを試行
      const loginData = {
        email: userData.email,
        password: userData.password
      }

      const response = await request(app.fetch)
        .post('/api/auth/login')
        .send(loginData)
        .expect(200)

      expect(response.body).toHaveProperty('user')
      expect(response.body).toHaveProperty('accessToken')
      expect(response.body).toHaveProperty('refreshToken')
    })

    it('should reject invalid credentials', async () => {
      const loginData = {
        email: 'nonexistent@example.com',
        password: 'wrongpassword'
      }

      const response = await request(app.fetch)
        .post('/api/auth/login')
        .send(loginData)
        .expect(401)

      expect(response.body.message).toContain('正しくありません')
    })
  })

  describe('GET /api/auth/me', () => {
    it('should return user info with valid token', async () => {
      // ユーザー登録とログイン
      const userData = {
        email: 'test@example.com',
        password: 'TestPassword123!',
        name: 'Test User'
      }

      await request(app.fetch)
        .post('/api/auth/register')
        .send(userData)

      const loginResponse = await request(app.fetch)
        .post('/api/auth/login')
        .send({ email: userData.email, password: userData.password })

      const token = loginResponse.body.accessToken

      // /me エンドポイントをテスト
      const response = await request(app.fetch)
        .get('/api/auth/me')
        .set('Authorization', `Bearer ${token}`)
        .expect(200)

      expect(response.body.user.email).toBe(userData.email)
      expect(response.body.user.name).toBe(userData.name)
    })

    it('should reject requests without token', async () => {
      const response = await request(app.fetch)
        .get('/api/auth/me')
        .expect(401)

      expect(response.body.message).toContain('Authorization header is required')
    })
  })
})
```

## フロントエンド連携例

### React での使用例

```typescript
// frontend/src/hooks/useAuth.ts
import { useState, useEffect } from 'react'

interface User {
  id: string
  email: string
  name: string
  role: string
}

interface AuthState {
  user: User | null
  accessToken: string | null
  isLoading: boolean
  isAuthenticated: boolean
}

export const useAuth = () => {
  const [authState, setAuthState] = useState<AuthState>({
    user: null,
    accessToken: null,
    isLoading: true,
    isAuthenticated: false,
  })

  useEffect(() => {
    // ローカルストレージからトークンを取得
    const token = localStorage.getItem('accessToken')
    if (token) {
      // ユーザー情報を取得
      fetchUserInfo(token)
    } else {
      setAuthState(prev => ({ ...prev, isLoading: false }))
    }
  }, [])

  const fetchUserInfo = async (token: string) => {
    try {
      const response = await fetch('http://localhost:3001/api/auth/me', {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      })

      if (response.ok) {
        const data = await response.json()
        setAuthState({
          user: data.user,
          accessToken: token,
          isLoading: false,
          isAuthenticated: true,
        })
      } else {
        // トークンが無効な場合
        localStorage.removeItem('accessToken')
        localStorage.removeItem('refreshToken')
        setAuthState({
          user: null,
          accessToken: null,
          isLoading: false,
          isAuthenticated: false,
        })
      }
    } catch (error) {
      console.error('Failed to fetch user info:', error)
      setAuthState(prev => ({ ...prev, isLoading: false }))
    }
  }

  const login = async (email: string, password: string) => {
    try {
      const response = await fetch('http://localhost:3001/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ email, password }),
      })

      if (response.ok) {
        const data = await response.json()
        
        // トークンを保存
        localStorage.setItem('accessToken', data.accessToken)
        localStorage.setItem('refreshToken', data.refreshToken)
        
        setAuthState({
          user: data.user,
          accessToken: data.accessToken,
          isLoading: false,
          isAuthenticated: true,
        })
        
        return { success: true }
      } else {
        const errorData = await response.json()
        return { success: false, error: errorData.message }
      }
    } catch (error) {
      console.error('Login failed:', error)
      return { success: false, error: 'ログインに失敗しました' }
    }
  }

  const logout = () => {
    localStorage.removeItem('accessToken')
    localStorage.removeItem('refreshToken')
    setAuthState({
      user: null,
      accessToken: null,
      isLoading: false,
      isAuthenticated: false,
    })
  }

  return {
    ...authState,
    login,
    logout,
  }
}
```

## 本番環境での考慮事項

### デプロイメントチェックリスト

#### セキュリティ設定
- [ ] 強力なJWT_SECRETを設定
- [ ] HTTPS の強制
- [ ] セキュリティヘッダーの設定
- [ ] CORS の適切な設定
- [ ] レート制限の実装

#### パフォーマンス
- [ ] データベース接続プールの設定
- [ ] キャッシュ戦略の実装
- [ ] ログ出力の最適化
- [ ] モニタリングの設定

#### 運用
- [ ] ヘルスチェックエンドポイント
- [ ] ログ監視
- [ ] エラー追跡
- [ ] バックアップ戦略

## まとめ

### 実装した機能

本記事では、Honoを使用して以下の認証機能を実装した：

#### 1. **基本認証機能**
- ユーザー登録・ログイン
- JWT トークン生成・検証
- パスワードハッシュ化
- トークンリフレッシュ

#### 2. **セキュリティ機能**
- パスワード強度チェック
- レート制限
- 認証ミドルウェア
- 管理者権限チェック

#### 3. **開発支援機能**
- TypeScript 型安全性
- バリデーション
- エラーハンドリング
- テスト実装

### 次のステップ

#### 1. **データベース統合**
- Prisma や Drizzle ORM の導入
- ユーザー情報の永続化
- セッション管理の改善

#### 2. **高度な機能**
- 二要素認証（2FA）
- OAuth プロバイダ連携
- パスワードリセット機能
- アカウント確認メール

#### 3. **運用改善**
- ログ監視システム
- パフォーマンス監視
- 自動テストの拡充
- CI/CD パイプライン

### 推奨事項

Honoを使った認証システムは、軽量で高性能なAPIを構築するのに適している。ただし、本番環境では以下の点に注意が必要：

1. **セキュリティの継続的な更新**
2. **適切なデータベース設計**
3. **監視とログ管理**
4. **定期的なセキュリティ監査**

独自認証システムの構築は学習効果が高く、要件に合わせた柔軟な実装が可能だが、セキュリティリスクも伴う。本記事の実装を参考に、プロジェクトの要件に応じてカスタマイズしていただきたい。
