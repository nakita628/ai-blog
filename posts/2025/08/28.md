---
date: 2025-08-28
title: TypeScript + Hono ã§ä½œã‚‹è»½é‡èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ï¼šJWT ã¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã®å®Ÿè£…ã‚¬ã‚¤ãƒ‰
description: Honoãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ã£ã¦Auth.jsã«ä¾å­˜ã—ãªã„ç‹¬è‡ªã®èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹æ–¹æ³•ã‚’è§£èª¬ã€‚JWTèªè¨¼ã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–ã€ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã¾ã§ç¶²ç¾…ã—ãŸå®Ÿè·µã‚¬ã‚¤ãƒ‰ã€‚
tags:
  - typescript
  - hono
  - jwt
  - authentication
  - security
  - web-api
  - middleware
prev:
  text: 'Auth.js (NextAuth v5) å®Œå…¨ã‚¬ã‚¤ãƒ‰ï¼šPrismaé€£æºã¨JWTã‚»ãƒƒã‚·ãƒ§ãƒ³ä¸¡æ–¹ã®å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³'
  link: '/posts/2025/08/27'
next:
  text: 'Rediså®Œå…¨ã‚¬ã‚¤ãƒ‰ï¼šé«˜é€Ÿãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ä½¿ã„æ–¹ã¨å®Ÿç”¨äº‹ä¾‹'
  link: '/posts/2025/08/29'
---

# TypeScript + Hono ã§ä½œã‚‹è»½é‡èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ï¼šJWT ã¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã®å®Ÿè£…ã‚¬ã‚¤ãƒ‰

[Hono](https://hono.dev/) ã¯ã€Webæ¨™æº–ã«åŸºã¥ã„ãŸé«˜é€Ÿã§è»½é‡ãªWebã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã ã€‚Cloudflare Workersã€Denoã€Bunã€Node.jsãªã©è¤‡æ•°ã®ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§å‹•ä½œã—ã€å„ªã‚ŒãŸé–‹ç™ºä½“é¨“ã‚’æä¾›ã™ã‚‹ã€‚æœ¬è¨˜äº‹ã§ã¯ã€Auth.jsãªã©ã®å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ä¾å­˜ã›ãšã€Honoã‚’ä½¿ã£ã¦ç‹¬è‡ªã®èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹æ–¹æ³•ã‚’è©³ã—ãè§£èª¬ã™ã‚‹ã€‚

## ãªãœç‹¬è‡ªèªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ã®ã‹

### ç‹¬è‡ªèªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ¡ãƒªãƒƒãƒˆ

#### 1. **å®Œå…¨ãªåˆ¶å¾¡**

- èªè¨¼ãƒ•ãƒ­ãƒ¼ã‚’ç´°ã‹ãã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½
- ãƒ“ã‚¸ãƒã‚¹è¦ä»¶ã«åˆã‚ã›ãŸæŸ”è»Ÿãªå®Ÿè£…
- å¤–éƒ¨ä¾å­˜ã‚’æœ€å°é™ã«æŠ‘åˆ¶

#### 2. **è»½é‡æ€§**

- å¿…è¦ãªæ©Ÿèƒ½ã®ã¿ã‚’å®Ÿè£…
- ãƒãƒ³ãƒ‰ãƒ«ã‚µã‚¤ã‚ºã®æœ€é©åŒ–
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®å‘ä¸Š

#### 3. **å­¦ç¿’åŠ¹æœ**

- èªè¨¼ã®ä»•çµ„ã¿ã‚’æ·±ãç†è§£
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã«å¯¾ã™ã‚‹æ„è­˜å‘ä¸Š
- ãƒ‡ãƒãƒƒã‚°ã¨ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ã®å®¹æ˜“æ€§

### è€ƒæ…®ã™ã¹ããƒ‡ãƒ¡ãƒªãƒƒãƒˆ

#### 1. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯**

- å®Ÿè£…ãƒŸã‚¹ã«ã‚ˆã‚‹è„†å¼±æ€§
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ›´æ–°ã®è²¬ä»»
- å°‚é–€çŸ¥è­˜ã®å¿…è¦æ€§

#### 2. **é–‹ç™ºã‚³ã‚¹ãƒˆ**

- åˆæœŸå®Ÿè£…æ™‚é–“ã®å¢—åŠ 
- ãƒ†ã‚¹ãƒˆã®è¤‡é›‘åŒ–
- ç¶™ç¶šçš„ãªãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹

## ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

### å¿…è¦ãªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

ã¾ãšã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®åˆæœŸåŒ–ã¨å¿…è¦ãªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ï¼š

```bash
# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆæœŸåŒ–
mkdir hono-auth-system
cd hono-auth-system
npm init -y

# å¿…è¦ãªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
npm install hono @hono/node-server
npm install -D typescript @types/node tsx nodemon

# èªè¨¼é–¢é€£ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸
npm install jsonwebtoken bcryptjs
npm install -D @types/jsonwebtoken @types/bcryptjs

# ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
npm install zod
```

### TypeScriptè¨­å®š

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "types": ["node"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### package.json ã‚¹ã‚¯ãƒªãƒ—ãƒˆè¨­å®š

```json
{
  "scripts": {
    "dev": "nodemon --exec tsx src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js"
  }
}
```

## åŸºæœ¬çš„ãªHonoã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³æ§‹é€ 

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ 

```
src/
â”œâ”€â”€ index.ts              # ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ jwt.ts            # JWTé–¢é€£ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”‚   â”œâ”€â”€ password.ts       # ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–
â”‚   â””â”€â”€ middleware.ts     # èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ auth.ts           # èªè¨¼é–¢é€£ãƒ«ãƒ¼ãƒˆ
â”‚   â””â”€â”€ protected.ts      # ä¿è­·ã•ã‚ŒãŸãƒ«ãƒ¼ãƒˆ
â”œâ”€â”€ types/
â”‚   â””â”€â”€ auth.ts           # å‹å®šç¾©
â””â”€â”€ utils/
    â””â”€â”€ validation.ts     # ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
```

### ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³

```typescript
// src/index.ts
import { Hono } from 'hono'
import { serve } from '@hono/node-server'
import { cors } from 'hono/cors'
import { logger } from 'hono/logger'
import { prettyJSON } from 'hono/pretty-json'

import authRoutes from './routes/auth'
import protectedRoutes from './routes/protected'

const app = new Hono()

// ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢è¨­å®š
app.use('*', logger())
app.use('*', prettyJSON())
app.use(
  '*',
  cors({
    origin: ['http://localhost:3000', 'http://localhost:5173'],
    allowHeaders: ['Content-Type', 'Authorization'],
    allowMethods: ['GET', 'POST', 'PUT', 'DELETE'],
    credentials: true,
  }),
)

// ãƒ«ãƒ¼ãƒˆè¨­å®š
app.route('/api/auth', authRoutes)
app.route('/api', protectedRoutes)

// ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
app.get('/health', (c) => {
  return c.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
  })
})

// 404ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
app.notFound((c) => {
  return c.json({ error: 'Not Found' }, 404)
})

// ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
app.onError((err, c) => {
  console.error('Application error:', err)
  return c.json(
    {
      error: 'Internal Server Error',
      message: process.env.NODE_ENV === 'development' ? err.message : undefined,
    },
    500,
  )
})

const port = Number(process.env.PORT) || 3001

console.log(`ğŸš€ Server running on http://localhost:${port}`)
serve({
  fetch: app.fetch,
  port,
})
```

## JWTèªè¨¼ã®å®Ÿè£…

### JWT ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

```typescript
// src/auth/jwt.ts
import jwt from 'jsonwebtoken'
import type { User } from '../types/auth'

const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-key'
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d'
const REFRESH_TOKEN_EXPIRES_IN = process.env.REFRESH_TOKEN_EXPIRES_IN || '30d'

export interface JWTPayload {
  userId: string
  email: string
  role?: string
  iat?: number
  exp?: number
}

export class JWTService {
  /**
   * ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆ
   */
  static generateAccessToken(user: User): string {
    const payload: JWTPayload = {
      userId: user.id,
      email: user.email,
      role: user.role,
    }

    return jwt.sign(payload, JWT_SECRET, {
      expiresIn: JWT_EXPIRES_IN,
      issuer: 'hono-auth-system',
      audience: 'hono-auth-client',
    })
  }

  /**
   * ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆ
   */
  static generateRefreshToken(user: User): string {
    const payload: JWTPayload = {
      userId: user.id,
      email: user.email,
    }

    return jwt.sign(payload, JWT_SECRET, {
      expiresIn: REFRESH_TOKEN_EXPIRES_IN,
      issuer: 'hono-auth-system',
      audience: 'hono-auth-refresh',
    })
  }

  /**
   * ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼
   */
  static verifyToken(token: string): JWTPayload | null {
    try {
      const decoded = jwt.verify(token, JWT_SECRET) as JWTPayload
      return decoded
    } catch (error) {
      console.error('JWT verification failed:', error)
      return null
    }
  }

  /**
   * ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ï¼ˆæ¤œè¨¼ãªã—ï¼‰
   */
  static decodeToken(token: string): JWTPayload | null {
    try {
      return jwt.decode(token) as JWTPayload
    } catch (error) {
      console.error('JWT decode failed:', error)
      return null
    }
  }

  /**
   * ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ã‚’ãƒã‚§ãƒƒã‚¯
   */
  static isTokenExpired(token: string): boolean {
    const decoded = this.decodeToken(token)
    if (!decoded || !decoded.exp) return true

    const currentTime = Math.floor(Date.now() / 1000)
    return decoded.exp < currentTime
  }

  /**
   * ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã‚’ç”Ÿæˆ
   */
  static generateTokenPair(user: User) {
    return {
      accessToken: this.generateAccessToken(user),
      refreshToken: this.generateRefreshToken(user),
      expiresIn: JWT_EXPIRES_IN,
      tokenType: 'Bearer',
    }
  }
}
```

### ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–

```typescript
// src/auth/password.ts
import bcrypt from 'bcryptjs'

export class PasswordService {
  private static readonly SALT_ROUNDS = 12

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–
   */
  static async hashPassword(password: string): Promise<string> {
    try {
      const salt = await bcrypt.genSalt(this.SALT_ROUNDS)
      return await bcrypt.hash(password, salt)
    } catch (error) {
      console.error('Password hashing failed:', error)
      throw new Error('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®ãƒãƒƒã‚·ãƒ¥åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ')
    }
  }

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œè¨¼
   */
  static async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {
    try {
      return await bcrypt.compare(password, hashedPassword)
    } catch (error) {
      console.error('Password verification failed:', error)
      return false
    }
  }

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦ã‚’ãƒã‚§ãƒƒã‚¯
   */
  static validatePasswordStrength(password: string): {
    isValid: boolean
    errors: string[]
  } {
    const errors: string[] = []

    if (password.length < 8) {
      errors.push('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™')
    }

    if (password.length > 128) {
      errors.push('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯128æ–‡å­—ä»¥ä¸‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™')
    }

    if (!/[a-z]/.test(password)) {
      errors.push('å°æ–‡å­—ã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™')
    }

    if (!/[A-Z]/.test(password)) {
      errors.push('å¤§æ–‡å­—ã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™')
    }

    if (!/\d/.test(password)) {
      errors.push('æ•°å­—ã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™')
    }

    if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
      errors.push('ç‰¹æ®Šæ–‡å­—ã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™')
    }

    // ã‚ˆãã‚ã‚‹ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯
    const commonPatterns = [
      /^(.)\1+$/, // åŒã˜æ–‡å­—ã®ç¹°ã‚Šè¿”ã—
      /^(012|123|234|345|456|567|678|789|890)+/, // é€£ç¶šã™ã‚‹æ•°å­—
      /^(abc|bcd|cde|def|efg|fgh|ghi|hij|ijk|jkl|klm|lmn|mno|nop|opq|pqr|qrs|rst|stu|tuv|uvw|vwx|wxy|xyz)+/i, // é€£ç¶šã™ã‚‹ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆ
    ]

    for (const pattern of commonPatterns) {
      if (pattern.test(password)) {
        errors.push('ã‚ˆã‚Šè¤‡é›‘ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„')
        break
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
    }
  }
}
```

### å‹å®šç¾©

```typescript
// src/types/auth.ts
export interface User {
  id: string
  email: string
  name: string
  role: 'user' | 'admin'
  createdAt: Date
  updatedAt: Date
}

export interface UserWithPassword extends User {
  password: string
}

export interface LoginRequest {
  email: string
  password: string
}

export interface RegisterRequest {
  email: string
  password: string
  name: string
}

export interface AuthResponse {
  user: Omit<User, 'password'>
  accessToken: string
  refreshToken: string
  expiresIn: string
  tokenType: string
}

export interface RefreshTokenRequest {
  refreshToken: string
}

// Contextæ‹¡å¼µç”¨ã®å‹
export interface AuthContext {
  user: User
}
```

### ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

```typescript
// src/utils/validation.ts
import { z } from 'zod'

export const loginSchema = z.object({
  email: z
    .string()
    .email('æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„')
    .min(1, 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯å¿…é ˆã§ã™'),
  password: z.string().min(1, 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯å¿…é ˆã§ã™'),
})

export const registerSchema = z.object({
  email: z
    .string()
    .email('æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„')
    .min(1, 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯å¿…é ˆã§ã™'),
  password: z
    .string()
    .min(8, 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™')
    .max(128, 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯128æ–‡å­—ä»¥ä¸‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™'),
  name: z.string().min(1, 'åå‰ã¯å¿…é ˆã§ã™').max(100, 'åå‰ã¯100æ–‡å­—ä»¥ä¸‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™'),
})

export const refreshTokenSchema = z.object({
  refreshToken: z.string().min(1, 'ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã¯å¿…é ˆã§ã™'),
})

export type LoginInput = z.infer<typeof loginSchema>
export type RegisterInput = z.infer<typeof registerSchema>
export type RefreshTokenInput = z.infer<typeof refreshTokenSchema>
```

## èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã®å®Ÿè£…

### èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢

```typescript
// src/auth/middleware.ts
import type { Context, Next } from 'hono'
import { HTTPException } from 'hono/http-exception'
import { JWTService } from './jwt'
import type { User, AuthContext } from '../types/auth'

// ç°¡æ˜“çš„ãªãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ãƒˆã‚¢ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä½¿ç”¨ï¼‰
const users: Map<string, User> = new Map()

// ãƒ‡ãƒ¢ç”¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’è¿½åŠ 
users.set('user1', {
  id: 'user1',
  email: 'user@example.com',
  name: 'Test User',
  role: 'user',
  createdAt: new Date(),
  updatedAt: new Date(),
})

users.set('admin1', {
  id: 'admin1',
  email: 'admin@example.com',
  name: 'Admin User',
  role: 'admin',
  createdAt: new Date(),
  updatedAt: new Date(),
})

/**
 * èªè¨¼ãŒå¿…è¦ãªãƒ«ãƒ¼ãƒˆã‚’ä¿è­·ã™ã‚‹ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
 */
export const authMiddleware = async (c: Context, next: Next) => {
  const authHeader = c.req.header('Authorization')

  if (!authHeader) {
    throw new HTTPException(401, {
      message: 'Authorization header is required',
    })
  }

  const token = authHeader.replace('Bearer ', '')

  if (!token) {
    throw new HTTPException(401, {
      message: 'Token is required',
    })
  }

  const payload = JWTService.verifyToken(token)

  if (!payload) {
    throw new HTTPException(401, {
      message: 'Invalid or expired token',
    })
  }

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰å–å¾—ï¼‰
  const user = users.get(payload.userId)

  if (!user) {
    throw new HTTPException(401, {
      message: 'User not found',
    })
  }

  // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’è¿½åŠ 
  c.set('user', user)

  await next()
}

/**
 * ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ãªãƒ«ãƒ¼ãƒˆã‚’ä¿è­·ã™ã‚‹ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
 */
export const adminMiddleware = async (c: Context, next: Next) => {
  const user = c.get('user') as User

  if (!user || user.role !== 'admin') {
    throw new HTTPException(403, {
      message: 'Admin access required',
    })
  }

  await next()
}

/**
 * ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ï¼ˆãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèªã™ã‚‹ãŒå¿…é ˆã§ã¯ãªã„ï¼‰
 */
export const optionalAuthMiddleware = async (c: Context, next: Next) => {
  const authHeader = c.req.header('Authorization')

  if (authHeader) {
    const token = authHeader.replace('Bearer ', '')
    const payload = JWTService.verifyToken(token)

    if (payload) {
      const user = users.get(payload.userId)
      if (user) {
        c.set('user', user)
      }
    }
  }

  await next()
}

/**
 * ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ï¼ˆç°¡æ˜“å®Ÿè£…ï¼‰
 */
const rateLimitStore = new Map<string, { count: number; resetTime: number }>()

export const rateLimitMiddleware = (maxRequests: number = 5, windowMs: number = 15 * 60 * 1000) => {
  return async (c: Context, next: Next) => {
    const clientIP = c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown'
    const now = Date.now()
    const windowStart = now - windowMs

    const clientData = rateLimitStore.get(clientIP)

    if (!clientData || clientData.resetTime < windowStart) {
      // æ–°ã—ã„ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã¾ãŸã¯æœŸé™åˆ‡ã‚Œ
      rateLimitStore.set(clientIP, { count: 1, resetTime: now + windowMs })
    } else if (clientData.count >= maxRequests) {
      // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã«å¼•ã£ã‹ã‹ã£ãŸ
      throw new HTTPException(429, {
        message: 'Too many requests. Please try again later.',
      })
    } else {
      // ã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—ã‚„ã™
      clientData.count++
    }

    await next()
  }
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ãƒˆã‚¢ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚µãƒ¼ãƒ“ã‚¹ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆï¼‰
export const userStore = {
  findByEmail: (email: string): User | undefined => {
    for (const user of users.values()) {
      if (user.email === email) {
        return user
      }
    }
    return undefined
  },

  findById: (id: string): User | undefined => {
    return users.get(id)
  },

  create: (userData: Omit<User, 'id' | 'createdAt' | 'updatedAt'>): User => {
    const user: User = {
      ...userData,
      id: `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date(),
      updatedAt: new Date(),
    }
    users.set(user.id, user)
    return user
  },

  // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä»˜ããƒ¦ãƒ¼ã‚¶ãƒ¼ç”¨ã®ç°¡æ˜“ã‚¹ãƒˆã‚¢
  userPasswords: new Map<string, string>(),
}
```

## èªè¨¼ãƒ«ãƒ¼ãƒˆã®å®Ÿè£…

### èªè¨¼é–¢é€£ãƒ«ãƒ¼ãƒˆ

```typescript
// src/routes/auth.ts
import { Hono } from 'hono'
import { HTTPException } from 'hono/http-exception'
import { JWTService } from '../auth/jwt'
import { PasswordService } from '../auth/password'
import { rateLimitMiddleware, userStore } from '../auth/middleware'
import {
  loginSchema,
  registerSchema,
  refreshTokenSchema,
  type LoginInput,
  type RegisterInput,
  type RefreshTokenInput,
} from '../utils/validation'
import type { AuthResponse } from '../types/auth'

const auth = new Hono()

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²
 */
auth.post('/register', rateLimitMiddleware(3, 15 * 60 * 1000), async (c) => {
  try {
    const body = await c.req.json()
    const validatedData = registerSchema.parse(body) as RegisterInput

    // ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
    const existingUser = userStore.findByEmail(validatedData.email)
    if (existingUser) {
      throw new HTTPException(409, {
        message: 'ã“ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™',
      })
    }

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦ãƒã‚§ãƒƒã‚¯
    const passwordValidation = PasswordService.validatePasswordStrength(validatedData.password)
    if (!passwordValidation.isValid) {
      throw new HTTPException(400, {
        message: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒè¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“',
        errors: passwordValidation.errors,
      })
    }

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–
    const hashedPassword = await PasswordService.hashPassword(validatedData.password)

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ä½œæˆ
    const user = userStore.create({
      email: validatedData.email,
      name: validatedData.name,
      role: 'user',
    })

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ä¿å­˜ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜ï¼‰
    userStore.userPasswords.set(user.id, hashedPassword)

    // JWTãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆ
    const tokenPair = JWTService.generateTokenPair(user)

    const response: AuthResponse = {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
      },
      ...tokenPair,
    }

    return c.json(response, 201)
  } catch (error) {
    if (error instanceof HTTPException) {
      throw error
    }

    if (error instanceof Error && error.name === 'ZodError') {
      throw new HTTPException(400, {
        message: 'ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼',
        errors: error.message,
      })
    }

    console.error('Registration error:', error)
    throw new HTTPException(500, {
      message: 'ç™»éŒ²å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ',
    })
  }
})

/**
 * ãƒ­ã‚°ã‚¤ãƒ³
 */
auth.post('/login', rateLimitMiddleware(5, 15 * 60 * 1000), async (c) => {
  try {
    const body = await c.req.json()
    const validatedData = loginSchema.parse(body) as LoginInput

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ¤œç´¢
    const user = userStore.findByEmail(validatedData.email)
    if (!user) {
      // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ãŸã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆã‚‚åŒã˜ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
      throw new HTTPException(401, {
        message: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¾ãŸã¯ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“',
      })
    }

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œè¨¼
    const hashedPassword = userStore.userPasswords.get(user.id)
    if (!hashedPassword) {
      throw new HTTPException(401, {
        message: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¾ãŸã¯ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“',
      })
    }

    const isPasswordValid = await PasswordService.verifyPassword(
      validatedData.password,
      hashedPassword,
    )

    if (!isPasswordValid) {
      throw new HTTPException(401, {
        message: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¾ãŸã¯ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“',
      })
    }

    // JWTãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆ
    const tokenPair = JWTService.generateTokenPair(user)

    const response: AuthResponse = {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
      },
      ...tokenPair,
    }

    return c.json(response)
  } catch (error) {
    if (error instanceof HTTPException) {
      throw error
    }

    if (error instanceof Error && error.name === 'ZodError') {
      throw new HTTPException(400, {
        message: 'ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼',
        errors: error.message,
      })
    }

    console.error('Login error:', error)
    throw new HTTPException(500, {
      message: 'ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ',
    })
  }
})

/**
 * ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
 */
auth.post('/refresh', rateLimitMiddleware(10, 15 * 60 * 1000), async (c) => {
  try {
    const body = await c.req.json()
    const validatedData = refreshTokenSchema.parse(body) as RefreshTokenInput

    // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼
    const payload = JWTService.verifyToken(validatedData.refreshToken)
    if (!payload) {
      throw new HTTPException(401, {
        message: 'Invalid refresh token',
      })
    }

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—
    const user = userStore.findById(payload.userId)
    if (!user) {
      throw new HTTPException(401, {
        message: 'User not found',
      })
    }

    // æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã‚’ç”Ÿæˆ
    const tokenPair = JWTService.generateTokenPair(user)

    return c.json(tokenPair)
  } catch (error) {
    if (error instanceof HTTPException) {
      throw error
    }

    if (error instanceof Error && error.name === 'ZodError') {
      throw new HTTPException(400, {
        message: 'ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼',
        errors: error.message,
      })
    }

    console.error('Token refresh error:', error)
    throw new HTTPException(500, {
      message: 'ãƒˆãƒ¼ã‚¯ãƒ³æ›´æ–°å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ',
    })
  }
})

/**
 * ãƒ­ã‚°ã‚¢ã‚¦ãƒˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼šãƒˆãƒ¼ã‚¯ãƒ³ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆå®Ÿè£…æ™‚ï¼‰
 */
auth.post('/logout', async (c) => {
  // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆã«è¿½åŠ 
  // ã¾ãŸã¯ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç„¡åŠ¹åŒ–
  return c.json({ message: 'ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ' })
})

/**
 * ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—
 */
import { authMiddleware } from '../auth/middleware'

auth.get('/me', authMiddleware, async (c) => {
  const user = c.get('user')
  return c.json({
    user: {
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    },
  })
})

export default auth
```

### ä¿è­·ã•ã‚ŒãŸãƒ«ãƒ¼ãƒˆ

```typescript
// src/routes/protected.ts
import { Hono } from 'hono'
import { authMiddleware, adminMiddleware } from '../auth/middleware'
import type { User } from '../types/auth'

const protected = new Hono()

/**
 * èªè¨¼ãŒå¿…è¦ãªä¸€èˆ¬ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ãƒ«ãƒ¼ãƒˆ
 */
protected.get('/profile', authMiddleware, async (c) => {
  const user = c.get('user') as User

  return c.json({
    message: 'ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±',
    user: {
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role,
    },
  })
})

/**
 * èªè¨¼ãŒå¿…è¦ãªãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
 */
protected.get('/dashboard', authMiddleware, async (c) => {
  const user = c.get('user') as User

  return c.json({
    message: `ã“ã‚“ã«ã¡ã¯ã€${user.name}ã•ã‚“`,
    dashboardData: {
      lastLogin: new Date().toISOString(),
      notifications: [],
      stats: {
        totalPosts: 0,
        totalViews: 0,
      },
    },
  })
})

/**
 * ç®¡ç†è€…å°‚ç”¨ãƒ«ãƒ¼ãƒˆ
 */
protected.get('/admin/users', authMiddleware, adminMiddleware, async (c) => {
  // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã‚’å–å¾—
  return c.json({
    message: 'ç®¡ç†è€…ç”¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§',
    users: [
      { id: 'user1', email: 'user@example.com', name: 'Test User', role: 'user' },
      { id: 'admin1', email: 'admin@example.com', name: 'Admin User', role: 'admin' },
    ],
  })
})

/**
 * ç®¡ç†è€…å°‚ç”¨ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±
 */
protected.get('/admin/system', authMiddleware, adminMiddleware, async (c) => {
  return c.json({
    message: 'ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±',
    system: {
      version: '1.0.0',
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      environment: process.env.NODE_ENV || 'development',
    },
  })
})

export default protected
```

## ç’°å¢ƒå¤‰æ•°ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š

### ç’°å¢ƒå¤‰æ•°è¨­å®š

```bash
# .env
NODE_ENV=development
PORT=3001

# JWTè¨­å®š
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_EXPIRES_IN=1h
REFRESH_TOKEN_EXPIRES_IN=7d

# CORSè¨­å®š
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:5173

# ãƒ¬ãƒ¼ãƒˆåˆ¶é™è¨­å®š
RATE_LIMIT_MAX_REQUESTS=100
RATE_LIMIT_WINDOW_MS=900000
```

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

#### 1. **ç’°å¢ƒå¤‰æ•°ã®ç®¡ç†**

```typescript
// src/config/env.ts
import { z } from 'zod'

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  PORT: z.string().transform(Number).default(3001),
  JWT_SECRET: z.string().min(32, 'JWT_SECRET must be at least 32 characters'),
  JWT_EXPIRES_IN: z.string().default('1h'),
  REFRESH_TOKEN_EXPIRES_IN: z.string().default('7d'),
  ALLOWED_ORIGINS: z.string().default('http://localhost:3000'),
})

export const env = envSchema.parse(process.env)
```

#### 2. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼**

```typescript
// src/middleware/security.ts
import type { Context, Next } from 'hono'

export const securityHeaders = async (c: Context, next: Next) => {
  await next()

  // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
  c.header('X-Content-Type-Options', 'nosniff')
  c.header('X-Frame-Options', 'DENY')
  c.header('X-XSS-Protection', '1; mode=block')
  c.header('Referrer-Policy', 'strict-origin-when-cross-origin')
  c.header('Permissions-Policy', 'camera=(), microphone=(), geolocation=()')

  // HSTSï¼ˆHTTPSã®å ´åˆã®ã¿ï¼‰
  if (c.req.header('x-forwarded-proto') === 'https') {
    c.header('Strict-Transport-Security', 'max-age=31536000; includeSubDomains')
  }
}
```

## ãƒ†ã‚¹ãƒˆã®å®Ÿè£…

### ãƒ†ã‚¹ãƒˆç’°å¢ƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

```bash
npm install -D vitest @vitest/ui supertest @types/supertest
```

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
  },
})
```

### èªè¨¼æ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆ

```typescript
// src/__tests__/auth.test.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { Hono } from 'hono'
import request from 'supertest'
import authRoutes from '../routes/auth'

const app = new Hono()
app.route('/api/auth', authRoutes)

describe('Authentication', () => {
  beforeEach(() => {
    // ãƒ†ã‚¹ãƒˆå‰ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ãƒˆã‚¢ã‚’ã‚¯ãƒªã‚¢
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä½¿ç”¨
  })

  describe('POST /api/auth/register', () => {
    it('should register a new user successfully', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'TestPassword123!',
        name: 'Test User',
      }

      const response = await request(app.fetch)
        .post('/api/auth/register')
        .send(userData)
        .expect(201)

      expect(response.body).toHaveProperty('user')
      expect(response.body).toHaveProperty('accessToken')
      expect(response.body).toHaveProperty('refreshToken')
      expect(response.body.user.email).toBe(userData.email)
      expect(response.body.user.name).toBe(userData.name)
    })

    it('should reject weak passwords', async () => {
      const userData = {
        email: 'test@example.com',
        password: '123',
        name: 'Test User',
      }

      const response = await request(app.fetch)
        .post('/api/auth/register')
        .send(userData)
        .expect(400)

      expect(response.body.message).toContain('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒè¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“')
    })

    it('should reject duplicate email addresses', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'TestPassword123!',
        name: 'Test User',
      }

      // æœ€åˆã®ç™»éŒ²
      await request(app.fetch).post('/api/auth/register').send(userData).expect(201)

      // é‡è¤‡ã™ã‚‹ç™»éŒ²
      const response = await request(app.fetch)
        .post('/api/auth/register')
        .send(userData)
        .expect(409)

      expect(response.body.message).toContain('æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™')
    })
  })

  describe('POST /api/auth/login', () => {
    it('should login with valid credentials', async () => {
      // ã¾ãšãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ç™»éŒ²
      const userData = {
        email: 'test@example.com',
        password: 'TestPassword123!',
        name: 'Test User',
      }

      await request(app.fetch).post('/api/auth/register').send(userData).expect(201)

      // ãƒ­ã‚°ã‚¤ãƒ³ã‚’è©¦è¡Œ
      const loginData = {
        email: userData.email,
        password: userData.password,
      }

      const response = await request(app.fetch).post('/api/auth/login').send(loginData).expect(200)

      expect(response.body).toHaveProperty('user')
      expect(response.body).toHaveProperty('accessToken')
      expect(response.body).toHaveProperty('refreshToken')
    })

    it('should reject invalid credentials', async () => {
      const loginData = {
        email: 'nonexistent@example.com',
        password: 'wrongpassword',
      }

      const response = await request(app.fetch).post('/api/auth/login').send(loginData).expect(401)

      expect(response.body.message).toContain('æ­£ã—ãã‚ã‚Šã¾ã›ã‚“')
    })
  })

  describe('GET /api/auth/me', () => {
    it('should return user info with valid token', async () => {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ã¨ãƒ­ã‚°ã‚¤ãƒ³
      const userData = {
        email: 'test@example.com',
        password: 'TestPassword123!',
        name: 'Test User',
      }

      await request(app.fetch).post('/api/auth/register').send(userData)

      const loginResponse = await request(app.fetch)
        .post('/api/auth/login')
        .send({ email: userData.email, password: userData.password })

      const token = loginResponse.body.accessToken

      // /me ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ãƒ†ã‚¹ãƒˆ
      const response = await request(app.fetch)
        .get('/api/auth/me')
        .set('Authorization', `Bearer ${token}`)
        .expect(200)

      expect(response.body.user.email).toBe(userData.email)
      expect(response.body.user.name).toBe(userData.name)
    })

    it('should reject requests without token', async () => {
      const response = await request(app.fetch).get('/api/auth/me').expect(401)

      expect(response.body.message).toContain('Authorization header is required')
    })
  })
})
```

## ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰é€£æºä¾‹

### React ã§ã®ä½¿ç”¨ä¾‹

```typescript
// frontend/src/hooks/useAuth.ts
import { useState, useEffect } from 'react'

interface User {
  id: string
  email: string
  name: string
  role: string
}

interface AuthState {
  user: User | null
  accessToken: string | null
  isLoading: boolean
  isAuthenticated: boolean
}

export const useAuth = () => {
  const [authState, setAuthState] = useState<AuthState>({
    user: null,
    accessToken: null,
    isLoading: true,
    isAuthenticated: false,
  })

  useEffect(() => {
    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
    const token = localStorage.getItem('accessToken')
    if (token) {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—
      fetchUserInfo(token)
    } else {
      setAuthState((prev) => ({ ...prev, isLoading: false }))
    }
  }, [])

  const fetchUserInfo = async (token: string) => {
    try {
      const response = await fetch('http://localhost:3001/api/auth/me', {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })

      if (response.ok) {
        const data = await response.json()
        setAuthState({
          user: data.user,
          accessToken: token,
          isLoading: false,
          isAuthenticated: true,
        })
      } else {
        // ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ãªå ´åˆ
        localStorage.removeItem('accessToken')
        localStorage.removeItem('refreshToken')
        setAuthState({
          user: null,
          accessToken: null,
          isLoading: false,
          isAuthenticated: false,
        })
      }
    } catch (error) {
      console.error('Failed to fetch user info:', error)
      setAuthState((prev) => ({ ...prev, isLoading: false }))
    }
  }

  const login = async (email: string, password: string) => {
    try {
      const response = await fetch('http://localhost:3001/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ email, password }),
      })

      if (response.ok) {
        const data = await response.json()

        // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜
        localStorage.setItem('accessToken', data.accessToken)
        localStorage.setItem('refreshToken', data.refreshToken)

        setAuthState({
          user: data.user,
          accessToken: data.accessToken,
          isLoading: false,
          isAuthenticated: true,
        })

        return { success: true }
      } else {
        const errorData = await response.json()
        return { success: false, error: errorData.message }
      }
    } catch (error) {
      console.error('Login failed:', error)
      return { success: false, error: 'ãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ' }
    }
  }

  const logout = () => {
    localStorage.removeItem('accessToken')
    localStorage.removeItem('refreshToken')
    setAuthState({
      user: null,
      accessToken: null,
      isLoading: false,
      isAuthenticated: false,
    })
  }

  return {
    ...authState,
    login,
    logout,
  }
}
```

## æœ¬ç•ªç’°å¢ƒã§ã®è€ƒæ…®äº‹é …

### ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

#### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š

- [ ] å¼·åŠ›ãªJWT_SECRETã‚’è¨­å®š
- [ ] HTTPS ã®å¼·åˆ¶
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ã®è¨­å®š
- [ ] CORS ã®é©åˆ‡ãªè¨­å®š
- [ ] ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã®å®Ÿè£…

#### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹

- [ ] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒ—ãƒ¼ãƒ«ã®è¨­å®š
- [ ] ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã®å®Ÿè£…
- [ ] ãƒ­ã‚°å‡ºåŠ›ã®æœ€é©åŒ–
- [ ] ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã®è¨­å®š

#### é‹ç”¨

- [ ] ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
- [ ] ãƒ­ã‚°ç›£è¦–
- [ ] ã‚¨ãƒ©ãƒ¼è¿½è·¡
- [ ] ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æˆ¦ç•¥

## ã¾ã¨ã‚

### å®Ÿè£…ã—ãŸæ©Ÿèƒ½

æœ¬è¨˜äº‹ã§ã¯ã€Honoã‚’ä½¿ç”¨ã—ã¦ä»¥ä¸‹ã®èªè¨¼æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ãŸï¼š

#### 1. **åŸºæœ¬èªè¨¼æ©Ÿèƒ½**

- ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ãƒ»ãƒ­ã‚°ã‚¤ãƒ³
- JWT ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆãƒ»æ¤œè¨¼
- ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–
- ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥

#### 2. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ©Ÿèƒ½**

- ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦ãƒã‚§ãƒƒã‚¯
- ãƒ¬ãƒ¼ãƒˆåˆ¶é™
- èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
- ç®¡ç†è€…æ¨©é™ãƒã‚§ãƒƒã‚¯

#### 3. **é–‹ç™ºæ”¯æ´æ©Ÿèƒ½**

- TypeScript å‹å®‰å…¨æ€§
- ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- ãƒ†ã‚¹ãƒˆå®Ÿè£…

### æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

#### 1. **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆ**

- Prisma ã‚„ Drizzle ORM ã®å°å…¥
- ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã®æ°¸ç¶šåŒ–
- ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã®æ”¹å–„

#### 2. **é«˜åº¦ãªæ©Ÿèƒ½**

- äºŒè¦ç´ èªè¨¼ï¼ˆ2FAï¼‰
- OAuth ãƒ—ãƒ­ãƒã‚¤ãƒ€é€£æº
- ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½
- ã‚¢ã‚«ã‚¦ãƒ³ãƒˆç¢ºèªãƒ¡ãƒ¼ãƒ«

#### 3. **é‹ç”¨æ”¹å–„**

- ãƒ­ã‚°ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
- è‡ªå‹•ãƒ†ã‚¹ãƒˆã®æ‹¡å……
- CI/CD ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

### æ¨å¥¨äº‹é …

Honoã‚’ä½¿ã£ãŸèªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã¯ã€è»½é‡ã§é«˜æ€§èƒ½ãªAPIã‚’æ§‹ç¯‰ã™ã‚‹ã®ã«é©ã—ã¦ã„ã‚‹ã€‚ãŸã ã—ã€æœ¬ç•ªç’°å¢ƒã§ã¯ä»¥ä¸‹ã®ç‚¹ã«æ³¨æ„ãŒå¿…è¦ï¼š

1. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ç¶™ç¶šçš„ãªæ›´æ–°**
2. **é©åˆ‡ãªãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ**
3. **ç›£è¦–ã¨ãƒ­ã‚°ç®¡ç†**
4. **å®šæœŸçš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»**

ç‹¬è‡ªèªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹ç¯‰ã¯å­¦ç¿’åŠ¹æœãŒé«˜ãã€è¦ä»¶ã«åˆã‚ã›ãŸæŸ”è»Ÿãªå®Ÿè£…ãŒå¯èƒ½ã ãŒã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ã‚‚ä¼´ã†ã€‚æœ¬è¨˜äº‹ã®å®Ÿè£…ã‚’å‚è€ƒã«ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®è¦ä»¶ã«å¿œã˜ã¦ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ã¦ã„ãŸã ããŸã„ã€‚
