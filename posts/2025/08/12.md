---
date: 2025-08-12
title: Effect完全ガイド：TypeScriptの次世代標準ライブラリで堅牢なアプリケーションを構築
description: Effectライブラリを使ったTypeScript開発の実践ガイド。型安全なエラーハンドリング、非同期処理、並行処理から、実際のプロジェクトでの導入方法まで、Effectの魅力と使い方を詳しく解説します。
tags:
  - typescript
  - effect
  - functional-programming
  - error-handling
  - async-programming
  - concurrency
  - standard-library
  - best-practices
prev:
  text: 'neverthrow完全ガイド：TypeScriptで関数型エラーハンドリングを実践する'
  link: '/posts/2025/08/11'
next:
  text: 'Pydantic完全ガイド：Pythonで型安全なデータバリデーションを実現する'
  link: '/posts/2025/08/14'
---

# Effect完全ガイド：TypeScriptの次世代標準ライブラリで堅牢なアプリケーションを構築

TypeScriptでより安全で保守性の高いアプリケーションを構築したいと思いませんか？本記事では、[Effect](https://effect.website/)ライブラリを使った次世代のTypeScript開発手法を詳しく解説します。型安全なエラーハンドリング、非同期処理、並行処理まで、Effectが提供する強力な機能をご紹介します。

## Effectとは

Effectは、TypeScriptの「不足している標準ライブラリ」を提供するライブラリです。関数型プログラミングの原則に基づいて設計され、型安全性、合成可能性、テスト可能性を最大限に高めたアプリケーション開発を可能にします。

### Effectの主要な特徴

- **最大限の型安全性**: エラーハンドリングから依存関係管理まで、すべてが型レベルで保証される
- **合成可能で再利用可能**: すべてのコンポーネントが組み合わせ可能
- **豊富なエコシステム**: 包括的なライブラリとパッケージ群
- **クラスタリングとワークフロー**: 分散処理と複雑なワークフローのサポート

## 基本的な使用方法

### 1. シンプルな処理

従来のTypeScriptとEffectの違いを見てみましょう。

```typescript
// 従来のTypeScript
const main = () => {
  console.log('Hello, World!')
}

main()

// Effectを使った書き方
import { Console, Effect } from 'effect'

const main = Console.log('Hello, World!')

Effect.runSync(main)
```

### 2. エラーハンドリング

Effectの最も強力な機能の一つが、型安全なエラーハンドリングです。

```typescript
import { Effect, Console } from 'effect'

// 従来のTypeScript（複雑で型安全性が低い）
async function getTodo(
  id: number,
): Promise<{ ok: true; todo: any } | { ok: false; error: 'InvalidJson' | 'RequestFailed' }> {
  try {
    const response = await fetch(`/todos/${id}`)
    if (!response.ok) throw new Error('Not OK!')
    try {
      const todo = await response.json()
      return { ok: true, todo }
    } catch (jsonError) {
      return { ok: false, error: 'InvalidJson' }
    }
  } catch (error) {
    return { ok: false, error: 'RequestFailed' }
  }
}

// Effectを使った書き方（簡潔で型安全）
const getTodo = (id: number): Effect.Effect<unknown, HttpClientError> =>
  httpClient.get(`/todos/${id}`).pipe(Effect.andThen((response) => response.json))
```

## 実践的な使用例

### 1. HTTPクライアントの使用

```typescript
import { Effect, HttpClient, Console } from 'effect'

interface Todo {
  id: number
  title: string
  completed: boolean
}

interface User {
  id: number
  name: string
  email: string
}

// ユーザーのTODOを取得する処理
const getUserTodos = (userId: number) =>
  Effect.gen(function* (_) {
    // ユーザー情報を取得
    const user = yield* _(
      HttpClient.get(`/users/${userId}`).pipe(
        Effect.andThen((response) => response.json as Effect.Effect<never, never, User>),
      ),
    )

    // ユーザーのTODOを取得
    const todos = yield* _(
      HttpClient.get(`/users/${userId}/todos`).pipe(
        Effect.andThen((response) => response.json as Effect.Effect<never, never, Todo[]>),
      ),
    )

    // 結果をログ出力
    yield* _(Console.log(`User: ${user.name}`))
    yield* _(Console.log(`Todos: ${todos.length} items`))

    return { user, todos }
  })

// 実行
const program = getUserTodos(1)
Effect.runPromise(program).then(console.log)
```

### 2. リトライとタイムアウト

```typescript
import { Effect, Schedule, Console } from 'effect'

// リトライ機能付きのAPI呼び出し
const fetchWithRetry = (url: string) =>
  HttpClient.get(url).pipe(
    Effect.retry(Schedule.exponential('100ms', 2).pipe(Schedule.compose(Schedule.recurs(3)))),
    Effect.timeout('5 seconds'),
    Effect.catchAll((error) =>
      Console.error(`Failed to fetch ${url}: ${error}`).pipe(
        Effect.andThen(() => Effect.fail(error)),
      ),
    ),
  )

// 使用例
const program = fetchWithRetry('/api/data')
Effect.runPromise(program)
```

### 3. 並行処理

```typescript
import { Effect, Console } from 'effect'

// 複数のAPIを並行で呼び出す
const fetchMultipleUsers = (userIds: number[]) =>
  Effect.gen(function* (_) {
    // 並行でユーザー情報を取得
    const users = yield* _(
      Effect.all(
        userIds.map((id) =>
          HttpClient.get(`/users/${id}`).pipe(Effect.andThen((response) => response.json)),
        ),
      ),
    )

    yield* _(Console.log(`Fetched ${users.length} users`))
    return users
  })

// 使用例
const program = fetchMultipleUsers([1, 2, 3, 4, 5])
Effect.runPromise(program)
```

### 4. 設定管理と依存性注入

```typescript
import { Effect, Config, Context } from 'effect'

// 設定の型定義
interface AppConfig {
  databaseUrl: string
  apiKey: string
  port: number
}

// 設定コンテキスト
const AppConfig = Context.Tag<AppConfig>()

// 設定を読み込む処理
const loadConfig = Config.string('DATABASE_URL').pipe(
  Config.zip(Config.string('API_KEY')),
  Config.zip(Config.number('PORT')),
  Config.map(([dbUrl, apiKey, port]) => ({
    databaseUrl: dbUrl,
    apiKey: apiKey,
    port: port,
  })),
)

// 設定を使用する処理
const connectToDatabase = Effect.gen(function* (_) {
  const config = yield* _(AppConfig)

  yield* _(Console.log(`Connecting to database: ${config.databaseUrl}`))
  // データベース接続処理...

  return 'Connected'
})

// プログラムの実行
const program = connectToDatabase.pipe(Effect.provideService(AppConfig, loadConfig))

Effect.runPromise(program)
```

## 高度な機能

### 1. ストリーム処理

```typescript
import { Effect, Stream, Console } from 'effect'

// ファイルをストリームで読み込む
const readFileStream = (filename: string) =>
  Stream.fromFile(filename).pipe(
    Stream.mapChunks((chunk) => Console.log(`Read chunk: ${chunk.length} bytes`)),
    Stream.runCollect,
  )

// 使用例
const program = readFileStream('large-file.txt')
Effect.runPromise(program)
```

### 2. スケジューリング

```typescript
import { Effect, Schedule, Console } from 'effect'

// 定期的なタスク実行
const periodicTask = Console.log('Running periodic task').pipe(
  Effect.repeat(Schedule.fixed('1 second').pipe(Schedule.compose(Schedule.recurs(10)))),
)

// 実行
Effect.runPromise(periodicTask)
```

### 3. メトリクスとトレーシング

```typescript
import { Effect, Metrics, Tracer } from 'effect'

// メトリクス付きの処理
const trackedOperation = Effect.gen(function* (_) {
  const counter = yield* _(Metrics.counter('api_calls'))

  yield* _(
    Tracer.span('api_call', () =>
      HttpClient.get('/api/data').pipe(Effect.tap(() => counter.increment(1))),
    ),
  )

  return 'Success'
})

// 実行
Effect.runPromise(trackedOperation)
```

## 段階的な導入方法

Effectは段階的に導入できます。既存のプロジェクトでも、複雑な部分から少しずつ移行することが可能です。

### 1. エラーハンドリングから始める

```typescript
// 既存のコード
async function processData(data: any) {
  try {
    const result = await validateData(data)
    return await saveData(result)
  } catch (error) {
    console.error('Processing failed:', error)
    throw error
  }
}

// Effectを使った書き方
const processData = (data: any) =>
  Effect.gen(function* (_) {
    const validated = yield* _(validateData(data))
    const saved = yield* _(saveData(validated))
    return saved
  }).pipe(
    Effect.catchAll((error) =>
      Console.error(`Processing failed: ${error}`).pipe(Effect.andThen(() => Effect.fail(error))),
    ),
  )
```

### 2. 非同期処理の改善

```typescript
// 従来のPromise.all
const fetchAll = async (urls: string[]) => {
  try {
    const responses = await Promise.all(urls.map((url) => fetch(url)))
    return await Promise.all(responses.map((response) => response.json()))
  } catch (error) {
    console.error('Fetch failed:', error)
    throw error
  }
}

// Effectを使った書き方
const fetchAll = (urls: string[]) =>
  Effect.all(
    urls.map((url) => HttpClient.get(url).pipe(Effect.andThen((response) => response.json))),
  ).pipe(
    Effect.catchAll((error) =>
      Console.error(`Fetch failed: ${error}`).pipe(Effect.andThen(() => Effect.fail(error))),
    ),
  )
```

## ベストプラクティス

### 1. エラー型の設計

```typescript
// 具体的で型安全なエラー型を定義
interface ValidationError {
  type: 'VALIDATION_ERROR'
  field: string
  message: string
}

interface DatabaseError {
  type: 'DATABASE_ERROR'
  code: string
  message: string
}

type AppError = ValidationError | DatabaseError

// Effectで使用
const validateUser = (user: any): Effect.Effect<never, ValidationError, User> =>
  Effect.try({
    try: () => UserSchema.parse(user),
    catch: (error) => ({
      type: 'VALIDATION_ERROR',
      field: 'user',
      message: error.message,
    }),
  })
```

### 2. テストでの使用

```typescript
import { Effect, TestContext } from 'effect'

describe('Effectのテスト', () => {
  it('成功ケースのテスト', async () => {
    const program = Effect.succeed('Success')
    const result = await Effect.runPromise(program)
    expect(result).toBe('Success')
  })

  it('エラーケースのテスト', async () => {
    const program = Effect.fail('Error')
    await expect(Effect.runPromise(program)).rejects.toBe('Error')
  })

  it('モックを使ったテスト', async () => {
    const mockHttpClient = HttpClient.of({
      get: () => Effect.succeed({ json: () => Effect.succeed({ id: 1, name: 'Test' }) }),
    })

    const program = HttpClient.get('/users/1').pipe(
      Effect.provideService(HttpClient, mockHttpClient),
    )

    const result = await Effect.runPromise(program)
    expect(result).toEqual({ id: 1, name: 'Test' })
  })
})
```

## まとめ

Effectは、TypeScriptの次世代標準ライブラリとして、型安全性、合成可能性、テスト可能性を大幅に向上させます。従来のtry/catchを使わないエラーハンドリング、非同期処理の簡潔な記述、並行処理の安全な実装など、多くの機能を提供しています。

段階的な導入が可能で、既存のプロジェクトでも複雑な部分から少しずつ移行できます。Effectの豊富なエコシステムと強力な型システムを活用して、より堅牢で保守性の高いTypeScriptアプリケーションを構築してみてください。

[Effect公式サイト](https://effect.website/)で詳細なドキュメントやサンプルを確認し、次世代のTypeScript開発を体験してみましょう。
