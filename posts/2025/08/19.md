---
date: 2025-08-19
title: TypeScriptによる画像軽量化処理：Canvas APIとWeb Workersを使った実践的な最適化手法
description: TypeScriptで画像の軽量化処理を実装する方法を詳しく解説。Canvas APIを使ったリサイズ・圧縮、Web Workersによる非同期処理、ファイルサイズ削減の実践テクニックまで、パフォーマンスを重視した画像最適化の実装方法を紹介します。
tags:
  - typescript
  - image-optimization
  - canvas-api
  - web-workers
  - performance
  - file-compression
  - web-development
  - frontend
prev:
  text: 'Terraform完全入門：初心者でもわかるインフラのコード化とベストプラクティス'
  link: '/posts/2025/08/18'
next:
  text: 'TypeScriptで実践する関数型エラーハンドリング：neverthrowとPrismaを使った副作用の安全な制御'
  link: '/posts/2025/08/22'
---

# TypeScriptによる画像軽量化処理：Canvas APIとWeb Workersを使った実践的な最適化手法

Webアプリケーションで画像を扱う際、ファイルサイズの最適化は重要な課題です。本記事では、TypeScriptを使って画像の軽量化処理を実装する方法を詳しく解説します。Canvas APIを使ったリサイズ・圧縮、Web Workersによる非同期処理、実践的な最適化テクニックまで、パフォーマンスを重視した画像処理の実装方法をご紹介します。

## 画像軽量化の重要性

現代のWebアプリケーションでは、画像がユーザー体験に大きな影響を与えます。適切な画像最適化により、以下のメリットが得られます：

- **ページ読み込み速度の向上**: ファイルサイズ削減による高速化
- **帯域幅の節約**: モバイルユーザーにとって重要な要素
- **SEOスコアの改善**: Core Web Vitalsの向上
- **ユーザー体験の向上**: スムーズなページ遷移

### 画像最適化の基本アプローチ

1. **リサイズ**: 表示サイズに合わせた適切な解像度
2. **圧縮**: 品質を保ちながらファイルサイズを削減
3. **フォーマット選択**: 用途に応じた最適な画像形式
4. **遅延読み込み**: 必要なタイミングでの読み込み

## Canvas APIを使った画像処理

### 基本的な画像リサイズ

Canvas APIを使った画像リサイズの基本実装を見てみましょう。

```typescript
interface ImageResizeOptions {
  readonly maxWidth: number
  readonly maxHeight: number
  readonly quality: number
  readonly format: 'image/jpeg' | 'image/png' | 'image/webp'
}

class ImageProcessor {
  /**
   * 画像をリサイズして軽量化する
   * @param file - 元の画像ファイル
   * @param options - リサイズオプション
   * @returns 処理後のBlob
   */
  static async resizeImage(file: File, options: ImageResizeOptions): Promise<Blob> {
    return new Promise((resolve, reject) => {
      const canvas = document.createElement('canvas')
      const ctx = canvas.getContext('2d')

      if (!ctx) {
        reject(new Error('Canvas context could not be created'))
        return
      }

      const img = new Image()
      img.onload = () => {
        // アスペクト比を保ちながらリサイズ
        const { width, height } = this.calculateDimensions(
          img.width,
          img.height,
          options.maxWidth,
          options.maxHeight,
        )

        canvas.width = width
        canvas.height = height

        // 高品質なリサイズ処理
        ctx.imageSmoothingEnabled = true
        ctx.imageSmoothingQuality = 'high'
        ctx.drawImage(img, 0, 0, width, height)

        // 指定された品質でBlobに変換
        canvas.toBlob(
          (blob) => {
            if (blob) {
              resolve(blob)
            } else {
              reject(new Error('Failed to create blob'))
            }
          },
          options.format,
          options.quality,
        )
      }

      img.onerror = () => reject(new Error('Failed to load image'))
      img.src = URL.createObjectURL(file)
    })
  }

  /**
   * アスペクト比を保ちながらリサイズ後のサイズを計算
   */
  private static calculateDimensions(
    originalWidth: number,
    originalHeight: number,
    maxWidth: number,
    maxHeight: number,
  ): { readonly width: number; readonly height: number } {
    const aspectRatio = originalWidth / originalHeight

    let width = originalWidth
    let height = originalHeight

    if (width > maxWidth) {
      width = maxWidth
      height = width / aspectRatio
    }

    if (height > maxHeight) {
      height = maxHeight
      width = height * aspectRatio
    }

    return { width: Math.round(width), height: Math.round(height) }
  }
}
```

### 複数画像の一括処理

複数の画像を効率的に処理するためのユーティリティクラスを実装します。

```typescript
interface BatchProcessResult {
  readonly originalFile: File
  readonly processedBlob: Blob
  readonly originalSize: number
  readonly processedSize: number
  readonly compressionRatio: number
}

class BatchImageProcessor {
  /**
   * 複数の画像を一括で処理
   */
  static async processBatch(
    files: readonly File[],
    options: ImageResizeOptions,
  ): Promise<readonly BatchProcessResult[]> {
    const results: BatchProcessResult[] = []

    for (const file of files) {
      try {
        const processedBlob = await ImageProcessor.resizeImage(file, options)
        const originalSize = file.size
        const processedSize = processedBlob.size
        const compressionRatio = ((originalSize - processedSize) / originalSize) * 100

        results.push({
          originalFile: file,
          processedBlob,
          originalSize,
          processedSize,
          compressionRatio,
        })
      } catch (error) {
        console.error(`Failed to process ${file.name}:`, error)
      }
    }

    return results
  }

  /**
   * 処理結果の統計情報を取得
   */
  static getStatistics(results: readonly BatchProcessResult[]) {
    const totalOriginalSize = results.reduce((sum, r) => sum + r.originalSize, 0)
    const totalProcessedSize = results.reduce((sum, r) => sum + r.processedSize, 0)
    const averageCompressionRatio =
      results.reduce((sum, r) => sum + r.compressionRatio, 0) / results.length

    return {
      totalOriginalSize,
      totalProcessedSize,
      totalSaved: totalOriginalSize - totalProcessedSize,
      averageCompressionRatio,
      processedCount: results.length,
    }
  }
}
```

## Web Workersを使った非同期処理

UIをブロックしないために、Web Workersを使って画像処理を非同期で実行します。

### Workerの実装

```typescript
// image-processor.worker.ts
interface WorkerMessage {
  readonly type: 'RESIZE_IMAGE'
  readonly payload: {
    readonly imageData: ImageBitmap
    readonly options: {
      readonly maxWidth: number
      readonly maxHeight: number
      readonly quality: number
      readonly format: 'image/jpeg' | 'image/png' | 'image/webp'
    }
  }
}

interface WorkerResponse {
  readonly type: 'RESIZE_COMPLETE'
  readonly payload: {
    readonly blob: Blob
    readonly originalSize: number
    readonly processedSize: number
  }
}

self.onmessage = async (event: MessageEvent<WorkerMessage>) => {
  if (event.data.type === 'RESIZE_IMAGE') {
    const { imageData, options } = event.data.payload

    try {
      const canvas = new OffscreenCanvas(imageData.width, imageData.height)
      const ctx = canvas.getContext('2d')

      if (!ctx) {
        throw new Error('Canvas context could not be created')
      }

      // リサイズ処理
      const { width, height } = calculateDimensions(
        imageData.width,
        imageData.height,
        options.maxWidth,
        options.maxHeight,
      )

      canvas.width = width
      canvas.height = height

      ctx.imageSmoothingEnabled = true
      ctx.imageSmoothingQuality = 'high'
      ctx.drawImage(imageData, 0, 0, width, height)

      // Blobに変換
      const blob = await canvas.convertToBlob({
        type: options.format,
        quality: options.quality,
      })

      const response: WorkerResponse = {
        type: 'RESIZE_COMPLETE',
        payload: {
          blob,
          originalSize: imageData.width * imageData.height * 4, // 概算
          processedSize: blob.size,
        },
      }

      self.postMessage(response)
    } catch (error) {
      self.postMessage({
        type: 'RESIZE_ERROR',
        payload: { error: error instanceof Error ? error.message : 'Unknown error' },
      })
    }
  }
}

function calculateDimensions(
  originalWidth: number,
  originalHeight: number,
  maxWidth: number,
  maxHeight: number,
): { readonly width: number; readonly height: number } {
  const aspectRatio = originalWidth / originalHeight

  let width = originalWidth
  let height = originalHeight

  if (width > maxWidth) {
    width = maxWidth
    height = width / aspectRatio
  }

  if (height > maxHeight) {
    height = maxHeight
    width = height * aspectRatio
  }

  return { width: Math.round(width), height: Math.round(height) }
}
```

### メインスレッドでのWorker使用

```typescript
class AsyncImageProcessor {
  private worker: Worker | null = null

  constructor() {
    if (typeof Worker !== 'undefined') {
      this.worker = new Worker(new URL('./image-processor.worker.ts', import.meta.url))
    }
  }

  /**
   * Web Workerを使って画像を非同期処理
   */
  async processWithWorker(file: File, options: ImageResizeOptions): Promise<Blob> {
    if (!this.worker) {
      // Workerが利用できない場合は同期処理にフォールバック
      return ImageProcessor.resizeImage(file, options)
    }

    return new Promise((resolve, reject) => {
      const imageBitmap = await createImageBitmap(file)

      this.worker!.postMessage({
        type: 'RESIZE_IMAGE',
        payload: { imageData: imageBitmap, options },
      })

      this.worker!.onmessage = (event) => {
        if (event.data.type === 'RESIZE_COMPLETE') {
          resolve(event.data.payload.blob)
        } else if (event.data.type === 'RESIZE_ERROR') {
          reject(new Error(event.data.payload.error))
        }
      }
    })
  }

  /**
   * Workerを破棄
   */
  destroy(): void {
    if (this.worker) {
      this.worker.terminate()
      this.worker = null
    }
  }
}
```

## 実践的な最適化テクニック

### プログレッシブJPEGの生成

```typescript
class ProgressiveImageProcessor {
  /**
   * プログレッシブJPEGを生成
   */
  static async createProgressiveJPEG(file: File, options: ImageResizeOptions): Promise<Blob> {
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')

    if (!ctx) {
      throw new Error('Canvas context could not be created')
    }

    const img = await this.loadImage(file)
    const { width, height } = ImageProcessor.calculateDimensions(
      img.width,
      img.height,
      options.maxWidth,
      options.maxHeight,
    )

    canvas.width = width
    canvas.height = height

    // 高品質な描画設定
    ctx.imageSmoothingEnabled = true
    ctx.imageSmoothingQuality = 'high'
    ctx.drawImage(img, 0, 0, width, height)

    // プログレッシブJPEGとして保存
    return new Promise((resolve, reject) => {
      canvas.toBlob(
        (blob) => {
          if (blob) {
            resolve(blob)
          } else {
            reject(new Error('Failed to create progressive JPEG'))
          }
        },
        'image/jpeg',
        options.quality,
      )
    })
  }

  private static loadImage(file: File): Promise<HTMLImageElement> {
    return new Promise((resolve, reject) => {
      const img = new Image()
      img.onload = () => resolve(img)
      img.onerror = () => reject(new Error('Failed to load image'))
      img.src = URL.createObjectURL(file)
    })
  }
}
```

### 画像の品質評価

```typescript
interface QualityMetrics {
  readonly fileSize: number
  readonly dimensions: { readonly width: number; readonly height: number }
  readonly aspectRatio: number
  readonly compressionRatio: number
  readonly estimatedBandwidth: number // 3G環境での推定読み込み時間
}

class ImageQualityAnalyzer {
  /**
   * 画像の品質指標を分析
   */
  static analyzeQuality(originalFile: File, processedBlob: Blob): QualityMetrics {
    const originalSize = originalFile.size
    const processedSize = processedBlob.size
    const compressionRatio = ((originalSize - processedSize) / originalSize) * 100

    // 画像サイズを取得
    return new Promise<QualityMetrics>((resolve) => {
      const img = new Image()
      img.onload = () => {
        const aspectRatio = img.width / img.height
        const estimatedBandwidth = this.estimateBandwidth(processedSize)

        resolve({
          fileSize: processedSize,
          dimensions: { width: img.width, height: img.height },
          aspectRatio,
          compressionRatio,
          estimatedBandwidth,
        })
      }
      img.src = URL.createObjectURL(processedBlob)
    })
  }

  /**
   * 3G環境での推定読み込み時間を計算（秒）
   */
  private static estimateBandwidth(fileSize: number): number {
    const threeGSpeed = 750 * 1024 // 750KB/s (3G環境の平均)
    return fileSize / threeGSpeed
  }
}
```

## 実装例：画像アップロードコンポーネント

実際の使用例として、Reactコンポーネントでの実装を見てみましょう。

```typescript
import React, { useState, useCallback, useRef } from 'react';

interface ImageUploaderProps {
  readonly onImagesProcessed: (results: readonly BatchProcessResult[]) => void;
  readonly maxFiles?: number;
  readonly maxFileSize?: number; // bytes
}

export const ImageUploader: React.FC<ImageUploaderProps> = ({
  onImagesProcessed,
  maxFiles = 10,
  maxFileSize = 10 * 1024 * 1024 // 10MB
}) => {
  const [isProcessing, setIsProcessing] = useState(false);
  const [progress, setProgress] = useState(0);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const processorRef = useRef<AsyncImageProcessor>(new AsyncImageProcessor());

  const handleFileSelect = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(event.target.files || []);

    if (files.length === 0) return;

    // ファイル数とサイズの検証
    if (files.length > maxFiles) {
      alert(`最大${maxFiles}個のファイルを選択してください`);
      return;
    }

    const oversizedFiles = files.filter(file => file.size > maxFileSize);
    if (oversizedFiles.length > 0) {
      alert(`${maxFileSize / (1024 * 1024)}MBを超えるファイルがあります`);
      return;
    }

    setIsProcessing(true);
    setProgress(0);

    try {
      const options: ImageResizeOptions = {
        maxWidth: 1920,
        maxHeight: 1080,
        quality: 0.8,
        format: 'image/jpeg'
      };

      const results = await BatchImageProcessor.processBatch(files, options);
      onImagesProcessed(results);

      const stats = BatchImageProcessor.getStatistics(results);
      console.log('処理完了:', stats);

    } catch (error) {
      console.error('画像処理エラー:', error);
      alert('画像の処理中にエラーが発生しました');
    } finally {
      setIsProcessing(false);
      setProgress(0);
    }
  }, [maxFiles, maxFileSize, onImagesProcessed]);

  return (
    <div className="image-uploader">
      <input
        ref={fileInputRef}
        type="file"
        multiple
        accept="image/*"
        onChange={handleFileSelect}
        disabled={isProcessing}
        style={{ display: 'none' }}
      />

      <button
        onClick={() => fileInputRef.current?.click()}
        disabled={isProcessing}
        className="upload-button"
      >
        {isProcessing ? '処理中...' : '画像を選択'}
      </button>

      {isProcessing && (
        <div className="progress-bar">
          <div
            className="progress-fill"
            style={{ width: `${progress}%` }}
          />
        </div>
      )}
    </div>
  );
};
```

## パフォーマンス最適化のベストプラクティス

### 1. メモリ管理

```typescript
class MemoryOptimizedProcessor {
  /**
   * メモリリークを防ぐための最適化された処理
   */
  static async processWithMemoryOptimization(
    file: File,
    options: ImageResizeOptions,
  ): Promise<Blob> {
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')

    if (!ctx) {
      throw new Error('Canvas context could not be created')
    }

    const img = new Image()

    try {
      const blob = await new Promise<Blob>((resolve, reject) => {
        img.onload = () => {
          const { width, height } = ImageProcessor.calculateDimensions(
            img.width,
            img.height,
            options.maxWidth,
            options.maxHeight,
          )

          canvas.width = width
          canvas.height = height

          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, 0, 0, width, height)

          canvas.toBlob(
            (blob) => {
              if (blob) {
                resolve(blob)
              } else {
                reject(new Error('Failed to create blob'))
              }
            },
            options.format,
            options.quality,
          )
        }

        img.onerror = () => reject(new Error('Failed to load image'))
        img.src = URL.createObjectURL(file)
      })

      return blob
    } finally {
      // メモリクリーンアップ
      URL.revokeObjectURL(img.src)
      canvas.width = 0
      canvas.height = 0
    }
  }
}
```

### 2. キャッシュ戦略

```typescript
class ImageCache {
  private static readonly cache = new Map<string, Blob>()
  private static readonly maxCacheSize = 50 // 最大キャッシュ数

  /**
   * キャッシュから画像を取得、なければ処理してキャッシュに保存
   */
  static async getOrProcess(file: File, options: ImageResizeOptions): Promise<Blob> {
    const cacheKey = this.generateCacheKey(file, options)

    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!
    }

    const processedBlob = await ImageProcessor.resizeImage(file, options)

    // キャッシュサイズ制限の確認
    if (this.cache.size >= this.maxCacheSize) {
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }

    this.cache.set(cacheKey, processedBlob)
    return processedBlob
  }

  private static generateCacheKey(file: File, options: ImageResizeOptions): string {
    return `${file.name}-${file.size}-${file.lastModified}-${JSON.stringify(options)}`
  }

  /**
   * キャッシュをクリア
   */
  static clear(): void {
    this.cache.clear()
  }
}
```

## まとめ

TypeScriptを使った画像軽量化処理は、Webアプリケーションのパフォーマンス向上に大きく貢献します。本記事で紹介した手法を活用することで、以下の効果が期待できます：

- **Canvas APIによる効率的な画像処理**: ブラウザネイティブの機能を活用した高速処理
- **Web Workersによる非同期処理**: UIブロッキングを防ぐスムーズなユーザー体験
- **適切なメモリ管理**: メモリリークを防ぐ安全な実装
- **キャッシュ戦略**: 重複処理を避ける効率的なシステム

特に重要なポイントは以下の通りです：

- **適切なリサイズ**: 表示サイズに合わせた最適な解像度設定
- **品質とファイルサイズのバランス**: 用途に応じた圧縮率の調整
- **非同期処理**: Web Workersを使ったUIブロッキングの回避
- **エラーハンドリング**: 堅牢なエラー処理とフォールバック機能
- **パフォーマンス監視**: 処理時間とメモリ使用量の最適化

これらの技術を組み合わせることで、ユーザー体験を損なうことなく、効率的な画像最適化システムを構築できます。TypeScriptの型安全性を活用し、保守性の高いコードを書くことで、長期的な運用にも対応できる堅牢なシステムを実現しましょう。
