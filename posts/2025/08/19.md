---
date: 2025-08-19
title: TypeScriptによる画像軽量化処理：Canvas APIとWeb Workersを使った実践的な最適化手法
description: TypeScriptで画像の軽量化処理を実装する方法を詳しく解説。Canvas APIを使ったリサイズ・圧縮、Web Workersによる非同期処理、ファイルサイズ削減の実践テクニックまで、パフォーマンスを重視した画像最適化の実装方法を紹介します。
tags:
    - typescript
    - image-optimization
    - canvas-api
    - web-workers
    - performance
    - file-compression
    - web-development
    - frontend
prev:
    text: "Terraform完全入門：初心者でもわかるインフラのコード化とベストプラクティス"
    link: "/posts/2025/08/18"
next:
    text: "TypeScriptで実践する関数型エラーハンドリング：neverthrowとPrismaを使った副作用の安全な制御"
    link: "/posts/2025/08/22"
---

# TypeScriptによる画像軽量化処理：Canvas APIとWeb Workersを使った実践的な最適化手法

Webアプリケーションで画像を扱う際、ファイルサイズの最適化は重要な課題です。本記事では、TypeScriptを使って画像の軽量化処理を実装する方法を詳しく解説します。Canvas APIを使ったリサイズ・圧縮、Web Workersによる非同期処理、実践的な最適化テクニックまで、パフォーマンスを重視した画像処理の実装方法をご紹介します。

## 画像軽量化の重要性

現代のWebアプリケーションでは、画像がユーザー体験に大きな影響を与えます。適切な画像最適化により、以下のメリットが得られます：

- **ページ読み込み速度の向上**: ファイルサイズ削減による高速化
- **帯域幅の節約**: モバイルユーザーにとって重要な要素
- **SEOスコアの改善**: Core Web Vitalsの向上
- **ユーザー体験の向上**: スムーズなページ遷移

### 画像最適化の基本アプローチ

1. **リサイズ**: 表示サイズに合わせた適切な解像度
2. **圧縮**: 品質を保ちながらファイルサイズを削減
3. **フォーマット選択**: 用途に応じた最適な画像形式
4. **遅延読み込み**: 必要なタイミングでの読み込み

## Canvas APIを使った画像処理

### 基本的な画像リサイズ

Canvas APIを使った画像リサイズの基本実装を見てみましょう。

```typescript
interface ImageResizeOptions {
  readonly maxWidth: number;
  readonly maxHeight: number;
  readonly quality: number;
  readonly format: 'image/jpeg' | 'image/png' | 'image/webp';
}

class ImageProcessor {
  /**
   * 画像をリサイズして軽量化する
   * @param file - 元の画像ファイル
   * @param options - リサイズオプション
   * @returns 処理後のBlob
   */
  static async resizeImage(
    file: File,
    options: ImageResizeOptions
  ): Promise<Blob> {
    return new Promise((resolve, reject) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      if (!ctx) {
        reject(new Error('Canvas context could not be created'));
        return;
      }

      const img = new Image();
      img.onload = () => {
        // アスペクト比を保ちながらリサイズ
        const { width, height } = this.calculateDimensions(
          img.width,
          img.height,
          options.maxWidth,
          options.maxHeight
        );

        canvas.width = width;
        canvas.height = height;

        // 高品質なリサイズ処理
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, 0, 0, width, height);

        // 指定された品質でBlobに変換
        canvas.toBlob(
          (blob) => {
            if (blob) {
              resolve(blob);
            } else {
              reject(new Error('Failed to create blob'));
            }
          },
          options.format,
          options.quality
        );
      };

      img.onerror = () => reject(new Error('Failed to load image'));
      img.src = URL.createObjectURL(file);
    });
  }

  /**
   * アスペクト比を保ちながらリサイズ後のサイズを計算
   */
  private static calculateDimensions(
    originalWidth: number,
    originalHeight: number,
    maxWidth: number,
    maxHeight: number
  ): { readonly width: number; readonly height: number } {
    const aspectRatio = originalWidth / originalHeight;
    
    let width = originalWidth;
    let height = originalHeight;

    if (width > maxWidth) {
      width = maxWidth;
      height = width / aspectRatio;
    }

    if (height > maxHeight) {
      height = maxHeight;
      width = height * aspectRatio;
    }

    return { width: Math.round(width), height: Math.round(height) };
  }
}
```

### 複数画像の一括処理

複数の画像を効率的に処理するためのユーティリティクラスを実装します。

```typescript
interface BatchProcessResult {
  readonly originalFile: File;
  readonly processedBlob: Blob;
  readonly originalSize: number;
  readonly processedSize: number;
  readonly compressionRatio: number;
}

class BatchImageProcessor {
  /**
   * 複数の画像を一括で処理
   */
  static async processBatch(
    files: readonly File[],
    options: ImageResizeOptions
  ): Promise<readonly BatchProcessResult[]> {
    const results: BatchProcessResult[] = [];

    for (const file of files) {
      try {
        const processedBlob = await ImageProcessor.resizeImage(file, options);
        const originalSize = file.size;
        const processedSize = processedBlob.size;
        const compressionRatio = ((originalSize - processedSize) / originalSize) * 100;

        results.push({
          originalFile: file,
          processedBlob,
          originalSize,
          processedSize,
          compressionRatio
        });
      } catch (error) {
        console.error(`Failed to process ${file.name}:`, error);
      }
    }

    return results;
  }

  /**
   * 処理結果の統計情報を取得
   */
  static getStatistics(results: readonly BatchProcessResult[]) {
    const totalOriginalSize = results.reduce((sum, r) => sum + r.originalSize, 0);
    const totalProcessedSize = results.reduce((sum, r) => sum + r.processedSize, 0);
    const averageCompressionRatio = results.reduce((sum, r) => sum + r.compressionRatio, 0) / results.length;

    return {
      totalOriginalSize,
      totalProcessedSize,
      totalSaved: totalOriginalSize - totalProcessedSize,
      averageCompressionRatio,
      processedCount: results.length
    };
  }
}
```

## Web Workersを使った非同期処理

UIをブロックしないために、Web Workersを使って画像処理を非同期で実行します。

### Workerの実装

```typescript
// image-processor.worker.ts
interface WorkerMessage {
  readonly type: 'RESIZE_IMAGE';
  readonly payload: {
    readonly imageData: ImageBitmap;
    readonly options: {
      readonly maxWidth: number;
      readonly maxHeight: number;
      readonly quality: number;
      readonly format: 'image/jpeg' | 'image/png' | 'image/webp';
    };
  };
}

interface WorkerResponse {
  readonly type: 'RESIZE_COMPLETE';
  readonly payload: {
    readonly blob: Blob;
    readonly originalSize: number;
    readonly processedSize: number;
  };
}

self.onmessage = async (event: MessageEvent<WorkerMessage>) => {
  if (event.data.type === 'RESIZE_IMAGE') {
    const { imageData, options } = event.data.payload;
    
    try {
      const canvas = new OffscreenCanvas(imageData.width, imageData.height);
      const ctx = canvas.getContext('2d');
      
      if (!ctx) {
        throw new Error('Canvas context could not be created');
      }

      // リサイズ処理
      const { width, height } = calculateDimensions(
        imageData.width,
        imageData.height,
        options.maxWidth,
        options.maxHeight
      );

      canvas.width = width;
      canvas.height = height;

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(imageData, 0, 0, width, height);

      // Blobに変換
      const blob = await canvas.convertToBlob({
        type: options.format,
        quality: options.quality
      });

      const response: WorkerResponse = {
        type: 'RESIZE_COMPLETE',
        payload: {
          blob,
          originalSize: imageData.width * imageData.height * 4, // 概算
          processedSize: blob.size
        }
      };

      self.postMessage(response);
    } catch (error) {
      self.postMessage({
        type: 'RESIZE_ERROR',
        payload: { error: error instanceof Error ? error.message : 'Unknown error' }
      });
    }
  }
};

function calculateDimensions(
  originalWidth: number,
  originalHeight: number,
  maxWidth: number,
  maxHeight: number
): { readonly width: number; readonly height: number } {
  const aspectRatio = originalWidth / originalHeight;
  
  let width = originalWidth;
  let height = originalHeight;

  if (width > maxWidth) {
    width = maxWidth;
    height = width / aspectRatio;
  }

  if (height > maxHeight) {
    height = maxHeight;
    width = height * aspectRatio;
  }

  return { width: Math.round(width), height: Math.round(height) };
}
```

### メインスレッドでのWorker使用

```typescript
class AsyncImageProcessor {
  private worker: Worker | null = null;

  constructor() {
    if (typeof Worker !== 'undefined') {
      this.worker = new Worker(new URL('./image-processor.worker.ts', import.meta.url));
    }
  }

  /**
   * Web Workerを使って画像を非同期処理
   */
  async processWithWorker(
    file: File,
    options: ImageResizeOptions
  ): Promise<Blob> {
    if (!this.worker) {
      // Workerが利用できない場合は同期処理にフォールバック
      return ImageProcessor.resizeImage(file, options);
    }

    return new Promise((resolve, reject) => {
      const imageBitmap = await createImageBitmap(file);
      
      this.worker!.postMessage({
        type: 'RESIZE_IMAGE',
        payload: { imageData: imageBitmap, options }
      });

      this.worker!.onmessage = (event) => {
        if (event.data.type === 'RESIZE_COMPLETE') {
          resolve(event.data.payload.blob);
        } else if (event.data.type === 'RESIZE_ERROR') {
          reject(new Error(event.data.payload.error));
        }
      };
    });
  }

  /**
   * Workerを破棄
   */
  destroy(): void {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
  }
}
```

## 実践的な最適化テクニック

### プログレッシブJPEGの生成

```typescript
class ProgressiveImageProcessor {
  /**
   * プログレッシブJPEGを生成
   */
  static async createProgressiveJPEG(
    file: File,
    options: ImageResizeOptions
  ): Promise<Blob> {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
      throw new Error('Canvas context could not be created');
    }

    const img = await this.loadImage(file);
    const { width, height } = ImageProcessor.calculateDimensions(
      img.width,
      img.height,
      options.maxWidth,
      options.maxHeight
    );

    canvas.width = width;
    canvas.height = height;

    // 高品質な描画設定
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(img, 0, 0, width, height);

    // プログレッシブJPEGとして保存
    return new Promise((resolve, reject) => {
      canvas.toBlob(
        (blob) => {
          if (blob) {
            resolve(blob);
          } else {
            reject(new Error('Failed to create progressive JPEG'));
          }
        },
        'image/jpeg',
        options.quality
      );
    });
  }

  private static loadImage(file: File): Promise<HTMLImageElement> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error('Failed to load image'));
      img.src = URL.createObjectURL(file);
    });
  }
}
```

### 画像の品質評価

```typescript
interface QualityMetrics {
  readonly fileSize: number;
  readonly dimensions: { readonly width: number; readonly height: number };
  readonly aspectRatio: number;
  readonly compressionRatio: number;
  readonly estimatedBandwidth: number; // 3G環境での推定読み込み時間
}

class ImageQualityAnalyzer {
  /**
   * 画像の品質指標を分析
   */
  static analyzeQuality(
    originalFile: File,
    processedBlob: Blob
  ): QualityMetrics {
    const originalSize = originalFile.size;
    const processedSize = processedBlob.size;
    const compressionRatio = ((originalSize - processedSize) / originalSize) * 100;

    // 画像サイズを取得
    return new Promise<QualityMetrics>((resolve) => {
      const img = new Image();
      img.onload = () => {
        const aspectRatio = img.width / img.height;
        const estimatedBandwidth = this.estimateBandwidth(processedSize);

        resolve({
          fileSize: processedSize,
          dimensions: { width: img.width, height: img.height },
          aspectRatio,
          compressionRatio,
          estimatedBandwidth
        });
      };
      img.src = URL.createObjectURL(processedBlob);
    });
  }

  /**
   * 3G環境での推定読み込み時間を計算（秒）
   */
  private static estimateBandwidth(fileSize: number): number {
    const threeGSpeed = 750 * 1024; // 750KB/s (3G環境の平均)
    return fileSize / threeGSpeed;
  }
}
```

## 実装例：画像アップロードコンポーネント

実際の使用例として、Reactコンポーネントでの実装を見てみましょう。

```typescript
import React, { useState, useCallback, useRef } from 'react';

interface ImageUploaderProps {
  readonly onImagesProcessed: (results: readonly BatchProcessResult[]) => void;
  readonly maxFiles?: number;
  readonly maxFileSize?: number; // bytes
}

export const ImageUploader: React.FC<ImageUploaderProps> = ({
  onImagesProcessed,
  maxFiles = 10,
  maxFileSize = 10 * 1024 * 1024 // 10MB
}) => {
  const [isProcessing, setIsProcessing] = useState(false);
  const [progress, setProgress] = useState(0);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const processorRef = useRef<AsyncImageProcessor>(new AsyncImageProcessor());

  const handleFileSelect = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(event.target.files || []);
    
    if (files.length === 0) return;
    
    // ファイル数とサイズの検証
    if (files.length > maxFiles) {
      alert(`最大${maxFiles}個のファイルを選択してください`);
      return;
    }

    const oversizedFiles = files.filter(file => file.size > maxFileSize);
    if (oversizedFiles.length > 0) {
      alert(`${maxFileSize / (1024 * 1024)}MBを超えるファイルがあります`);
      return;
    }

    setIsProcessing(true);
    setProgress(0);

    try {
      const options: ImageResizeOptions = {
        maxWidth: 1920,
        maxHeight: 1080,
        quality: 0.8,
        format: 'image/jpeg'
      };

      const results = await BatchImageProcessor.processBatch(files, options);
      onImagesProcessed(results);
      
      const stats = BatchImageProcessor.getStatistics(results);
      console.log('処理完了:', stats);
      
    } catch (error) {
      console.error('画像処理エラー:', error);
      alert('画像の処理中にエラーが発生しました');
    } finally {
      setIsProcessing(false);
      setProgress(0);
    }
  }, [maxFiles, maxFileSize, onImagesProcessed]);

  return (
    <div className="image-uploader">
      <input
        ref={fileInputRef}
        type="file"
        multiple
        accept="image/*"
        onChange={handleFileSelect}
        disabled={isProcessing}
        style={{ display: 'none' }}
      />
      
      <button
        onClick={() => fileInputRef.current?.click()}
        disabled={isProcessing}
        className="upload-button"
      >
        {isProcessing ? '処理中...' : '画像を選択'}
      </button>

      {isProcessing && (
        <div className="progress-bar">
          <div 
            className="progress-fill"
            style={{ width: `${progress}%` }}
          />
        </div>
      )}
    </div>
  );
};
```

## パフォーマンス最適化のベストプラクティス

### 1. メモリ管理

```typescript
class MemoryOptimizedProcessor {
  /**
   * メモリリークを防ぐための最適化された処理
   */
  static async processWithMemoryOptimization(
    file: File,
    options: ImageResizeOptions
  ): Promise<Blob> {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
      throw new Error('Canvas context could not be created');
    }

    const img = new Image();
    
    try {
      const blob = await new Promise<Blob>((resolve, reject) => {
        img.onload = () => {
          const { width, height } = ImageProcessor.calculateDimensions(
            img.width,
            img.height,
            options.maxWidth,
            options.maxHeight
          );

          canvas.width = width;
          canvas.height = height;

          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          ctx.drawImage(img, 0, 0, width, height);

          canvas.toBlob(
            (blob) => {
              if (blob) {
                resolve(blob);
              } else {
                reject(new Error('Failed to create blob'));
              }
            },
            options.format,
            options.quality
          );
        };

        img.onerror = () => reject(new Error('Failed to load image'));
        img.src = URL.createObjectURL(file);
      });

      return blob;
    } finally {
      // メモリクリーンアップ
      URL.revokeObjectURL(img.src);
      canvas.width = 0;
      canvas.height = 0;
    }
  }
}
```

### 2. キャッシュ戦略

```typescript
class ImageCache {
  private static readonly cache = new Map<string, Blob>();
  private static readonly maxCacheSize = 50; // 最大キャッシュ数

  /**
   * キャッシュから画像を取得、なければ処理してキャッシュに保存
   */
  static async getOrProcess(
    file: File,
    options: ImageResizeOptions
  ): Promise<Blob> {
    const cacheKey = this.generateCacheKey(file, options);
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!;
    }

    const processedBlob = await ImageProcessor.resizeImage(file, options);
    
    // キャッシュサイズ制限の確認
    if (this.cache.size >= this.maxCacheSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(cacheKey, processedBlob);
    return processedBlob;
  }

  private static generateCacheKey(file: File, options: ImageResizeOptions): string {
    return `${file.name}-${file.size}-${file.lastModified}-${JSON.stringify(options)}`;
  }

  /**
   * キャッシュをクリア
   */
  static clear(): void {
    this.cache.clear();
  }
}
```

## まとめ

TypeScriptを使った画像軽量化処理は、Webアプリケーションのパフォーマンス向上に大きく貢献します。本記事で紹介した手法を活用することで、以下の効果が期待できます：

- **Canvas APIによる効率的な画像処理**: ブラウザネイティブの機能を活用した高速処理
- **Web Workersによる非同期処理**: UIブロッキングを防ぐスムーズなユーザー体験
- **適切なメモリ管理**: メモリリークを防ぐ安全な実装
- **キャッシュ戦略**: 重複処理を避ける効率的なシステム

特に重要なポイントは以下の通りです：

- **適切なリサイズ**: 表示サイズに合わせた最適な解像度設定
- **品質とファイルサイズのバランス**: 用途に応じた圧縮率の調整
- **非同期処理**: Web Workersを使ったUIブロッキングの回避
- **エラーハンドリング**: 堅牢なエラー処理とフォールバック機能
- **パフォーマンス監視**: 処理時間とメモリ使用量の最適化

これらの技術を組み合わせることで、ユーザー体験を損なうことなく、効率的な画像最適化システムを構築できます。TypeScriptの型安全性を活用し、保守性の高いコードを書くことで、長期的な運用にも対応できる堅牢なシステムを実現しましょう。
