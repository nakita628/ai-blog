---
date: 2025-08-23
title: Drizzle ORMとSQLiteで実践する複雑なデータベース処理：JOIN・トランザクション・バッチ処理の完全ガイド
description: Drizzle ORMとSQLiteを組み合わせた複雑なデータベース処理を詳しく解説。JOIN、トランザクション、バッチ処理、パフォーマンス最適化まで、実践的なデータベース操作の実装方法を紹介します。
tags:
  - typescript
  - drizzle-orm
  - sqlite
  - database
  - joins
  - transactions
  - batch-processing
  - performance
prev:
  text: 'TypeScriptで実践する関数型エラーハンドリング：neverthrowとPrismaを使った副作用の安全な制御'
  link: '/posts/2025/08/22'
next:
  text: 'NestJSでClean ArchitectureなTodo REST APIを構築する'
  link: '/posts/2025/08/24'
---

# Drizzle ORMとSQLiteで実践する複雑なデータベース処理：JOIN・トランザクション・バッチ処理の完全ガイド

現代のWebアプリケーションでは、複雑なデータベース操作が避けられません。[Drizzle ORM](https://orm.drizzle.team/)は、TypeScriptファーストの軽量で高性能なORMとして注目を集めています。本記事では、Drizzle ORMとSQLiteを組み合わせた複雑なデータベース処理について詳しく解説します。JOIN、トランザクション、バッチ処理、パフォーマンス最適化まで、実践的なデータベース操作の実装方法をご紹介します。

## Drizzle ORMの基本概念

Drizzle ORMは、TypeScriptファーストの軽量で高性能なORMです。主な特徴は以下の通りです：

- **型安全性**: TypeScriptの型システムを活用した完全な型安全性
- **軽量性**: バンドルサイズが小さく、パフォーマンスが高い
- **SQLライク**: SQLに近い構文で直感的にクエリを書ける
- **多様なデータベース対応**: PostgreSQL、MySQL、SQLiteなど多数のデータベースをサポート
- **マイグレーション**: スキーマの変更を安全に管理

### 基本的なセットアップ

まず、必要なパッケージをインストールします：

```bash
npm install drizzle-orm better-sqlite3
npm install -D drizzle-kit @types/better-sqlite3
```

## スキーマ定義

### 基本的なテーブル定義

ブログシステムを例として、複雑なリレーションを持つスキーマを定義します：

```typescript
// schema/index.ts
import { sqliteTable, text, integer, real, blob } from 'drizzle-orm/sqlite-core'
import { relations } from 'drizzle-orm'

// ユーザーテーブル
export const users = sqliteTable('users', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  email: text('email').notNull().unique(),
  name: text('name').notNull(),
  avatar: text('avatar'),
  createdAt: integer('created_at', { mode: 'timestamp' }).$defaultFn(() => new Date()),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).$defaultFn(() => new Date()),
})

// カテゴリテーブル
export const categories = sqliteTable('categories', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text('name').notNull().unique(),
  description: text('description'),
  slug: text('slug').notNull().unique(),
  createdAt: integer('created_at', { mode: 'timestamp' }).$defaultFn(() => new Date()),
})

// 投稿テーブル
export const posts = sqliteTable('posts', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  title: text('title').notNull(),
  content: text('content').notNull(),
  excerpt: text('excerpt'),
  slug: text('slug').notNull().unique(),
  published: integer('published', { mode: 'boolean' }).notNull().default(false),
  authorId: text('author_id')
    .notNull()
    .references(() => users.id),
  categoryId: text('category_id').references(() => categories.id),
  viewCount: integer('view_count').notNull().default(0),
  createdAt: integer('created_at', { mode: 'timestamp' }).$defaultFn(() => new Date()),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).$defaultFn(() => new Date()),
})

// タグテーブル
export const tags = sqliteTable('tags', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text('name').notNull().unique(),
  slug: text('slug').notNull().unique(),
  createdAt: integer('created_at', { mode: 'timestamp' }).$defaultFn(() => new Date()),
})

// 投稿タグの中間テーブル
export const postTags = sqliteTable('post_tags', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  postId: text('post_id')
    .notNull()
    .references(() => posts.id),
  tagId: text('tag_id')
    .notNull()
    .references(() => tags.id),
  createdAt: integer('created_at', { mode: 'timestamp' }).$defaultFn(() => new Date()),
})

// コメントテーブル
export const comments = sqliteTable('comments', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  content: text('content').notNull(),
  authorName: text('author_name').notNull(),
  authorEmail: text('author_email').notNull(),
  postId: text('post_id')
    .notNull()
    .references(() => posts.id),
  parentId: text('parent_id').references(() => comments.id),
  approved: integer('approved', { mode: 'boolean' }).notNull().default(false),
  createdAt: integer('created_at', { mode: 'timestamp' }).$defaultFn(() => new Date()),
})

// リレーション定義
export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
  comments: many(comments),
}))

export const categoriesRelations = relations(categories, ({ many }) => ({
  posts: many(posts),
}))

export const postsRelations = relations(posts, ({ one, many }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id],
  }),
  category: one(categories, {
    fields: [posts.categoryId],
    references: [categories.id],
  }),
  comments: many(comments),
  postTags: many(postTags),
}))

export const tagsRelations = relations(tags, ({ many }) => ({
  postTags: many(postTags),
}))

export const postTagsRelations = relations(postTags, ({ one }) => ({
  post: one(posts, {
    fields: [postTags.postId],
    references: [posts.id],
  }),
  tag: one(tags, {
    fields: [postTags.tagId],
    references: [tags.id],
  }),
}))

export const commentsRelations = relations(comments, ({ one, many }) => ({
  post: one(posts, {
    fields: [comments.postId],
    references: [posts.id],
  }),
  parent: one(comments, {
    fields: [comments.parentId],
    references: [comments.id],
  }),
  replies: many(comments),
}))
```

## データベース接続

### SQLite接続の設定

```typescript
// lib/database.ts
import Database from 'better-sqlite3'
import { drizzle } from 'drizzle-orm/better-sqlite3'
import { migrate } from 'drizzle-orm/better-sqlite3/migrator'
import * as schema from '../schema'

const sqlite = new Database('blog.db')
export const db = drizzle(sqlite, { schema })

// マイグレーションの実行
export const runMigrations = () => {
  migrate(db, { migrationsFolder: './drizzle' })
}

// データベース接続のテスト
export const testConnection = () => {
  try {
    const result = sqlite.prepare('SELECT 1 as test').get()
    return result.test === 1
  } catch (error) {
    console.error('Database connection failed:', error)
    return false
  }
}
```

## 複雑なJOIN処理

### 基本的なJOIN

```typescript
// services/postService.ts
import { eq, and, desc, asc, count, sql } from 'drizzle-orm'
import { db } from '../lib/database'
import { posts, users, categories, comments, tags, postTags } from '../schema'

/**
 * 投稿とその関連データを取得（基本的なJOIN）
 */
export const getPostWithDetails = async (postId: string) => {
  const result = await db
    .select({
      id: posts.id,
      title: posts.title,
      content: posts.content,
      excerpt: posts.excerpt,
      slug: posts.slug,
      published: posts.published,
      viewCount: posts.viewCount,
      createdAt: posts.createdAt,
      author: {
        id: users.id,
        name: users.name,
        email: users.email,
        avatar: users.avatar,
      },
      category: {
        id: categories.id,
        name: categories.name,
        slug: categories.slug,
      },
    })
    .from(posts)
    .leftJoin(users, eq(posts.authorId, users.id))
    .leftJoin(categories, eq(posts.categoryId, categories.id))
    .where(eq(posts.id, postId))
    .limit(1)

  return result[0]
}

/**
 * 投稿一覧を取得（複数テーブルのJOIN）
 */
export const getPostsWithDetails = async (limit = 10, offset = 0) => {
  return await db
    .select({
      id: posts.id,
      title: posts.title,
      excerpt: posts.excerpt,
      slug: posts.slug,
      published: posts.published,
      viewCount: posts.viewCount,
      createdAt: posts.createdAt,
      author: {
        id: users.id,
        name: users.name,
        avatar: users.avatar,
      },
      category: {
        id: categories.id,
        name: categories.name,
        slug: categories.slug,
      },
      commentCount: count(comments.id),
    })
    .from(posts)
    .leftJoin(users, eq(posts.authorId, users.id))
    .leftJoin(categories, eq(posts.categoryId, categories.id))
    .leftJoin(comments, eq(posts.id, comments.postId))
    .where(eq(posts.published, true))
    .groupBy(posts.id, users.id, categories.id)
    .orderBy(desc(posts.createdAt))
    .limit(limit)
    .offset(offset)
}
```

### 複雑なJOIN（多対多リレーション）

```typescript
/**
 * 投稿とそのタグを取得（多対多JOIN）
 */
export const getPostWithTags = async (postId: string) => {
  const result = await db
    .select({
      id: posts.id,
      title: posts.title,
      content: posts.content,
      excerpt: posts.excerpt,
      slug: posts.slug,
      published: posts.published,
      createdAt: posts.createdAt,
      author: {
        id: users.id,
        name: users.name,
        email: users.email,
      },
      category: {
        id: categories.id,
        name: categories.name,
        slug: categories.slug,
      },
      tags: sql<string>`GROUP_CONCAT(${tags.name})`.as('tags'),
    })
    .from(posts)
    .leftJoin(users, eq(posts.authorId, users.id))
    .leftJoin(categories, eq(posts.categoryId, categories.id))
    .leftJoin(postTags, eq(posts.id, postTags.postId))
    .leftJoin(tags, eq(postTags.tagId, tags.id))
    .where(eq(posts.id, postId))
    .groupBy(posts.id, users.id, categories.id)

  return result[0]
}

/**
 * 特定のタグを持つ投稿を取得
 */
export const getPostsByTag = async (tagSlug: string, limit = 10, offset = 0) => {
  return await db
    .select({
      id: posts.id,
      title: posts.title,
      excerpt: posts.excerpt,
      slug: posts.slug,
      published: posts.published,
      viewCount: posts.viewCount,
      createdAt: posts.createdAt,
      author: {
        id: users.id,
        name: users.name,
        avatar: users.avatar,
      },
      category: {
        id: categories.id,
        name: categories.name,
        slug: categories.slug,
      },
    })
    .from(posts)
    .innerJoin(postTags, eq(posts.id, postTags.postId))
    .innerJoin(tags, eq(postTags.tagId, tags.id))
    .leftJoin(users, eq(posts.authorId, users.id))
    .leftJoin(categories, eq(posts.categoryId, categories.id))
    .where(and(eq(tags.slug, tagSlug), eq(posts.published, true)))
    .orderBy(desc(posts.createdAt))
    .limit(limit)
    .offset(offset)
}
```

### ネストしたJOIN（階層データ）

```typescript
/**
 * コメントとその返信を階層的に取得
 */
export const getCommentsWithReplies = async (postId: string) => {
  // 親コメントを取得
  const parentComments = await db
    .select({
      id: comments.id,
      content: comments.content,
      authorName: comments.authorName,
      authorEmail: comments.authorEmail,
      approved: comments.approved,
      createdAt: comments.createdAt,
    })
    .from(comments)
    .where(and(eq(comments.postId, postId), eq(comments.parentId, null)))
    .orderBy(desc(comments.createdAt))

  // 各親コメントの返信を取得
  const commentsWithReplies = await Promise.all(
    parentComments.map(async (parentComment) => {
      const replies = await db
        .select({
          id: comments.id,
          content: comments.content,
          authorName: comments.authorName,
          authorEmail: comments.authorEmail,
          approved: comments.approved,
          createdAt: comments.createdAt,
        })
        .from(comments)
        .where(eq(comments.parentId, parentComment.id))
        .orderBy(asc(comments.createdAt))

      return {
        ...parentComment,
        replies,
      }
    }),
  )

  return commentsWithReplies
}
```

## トランザクション処理

### 基本的なトランザクション

```typescript
// services/transactionService.ts
import { db } from '../lib/database'
import { posts, comments, users } from '../schema'
import { eq } from 'drizzle-orm'

/**
 * 投稿作成とコメントの同時作成（トランザクション）
 */
export const createPostWithComment = async (
  postData: {
    title: string
    content: string
    excerpt?: string
    slug: string
    authorId: string
  },
  commentData: {
    content: string
    authorName: string
    authorEmail: string
  },
) => {
  return await db.transaction(async (tx) => {
    // 投稿を作成
    const [post] = await tx.insert(posts).values(postData).returning()

    // コメントを作成
    const [comment] = await tx
      .insert(comments)
      .values({
        ...commentData,
        postId: post.id,
        approved: true,
      })
      .returning()

    return { post, comment }
  })
}

/**
 * 投稿削除と関連データの一括削除（トランザクション）
 */
export const deletePostWithRelatedData = async (postId: string) => {
  return await db.transaction(async (tx) => {
    // 関連するコメントを削除
    await tx.delete(comments).where(eq(comments.postId, postId))

    // 関連する投稿タグを削除
    await tx.delete(postTags).where(eq(postTags.postId, postId))

    // 投稿を削除
    const [deletedPost] = await tx.delete(posts).where(eq(posts.id, postId)).returning()

    return deletedPost
  })
}
```

### 複雑なトランザクション（条件分岐）

```typescript
/**
 * ユーザー登録と初期投稿の作成（条件付きトランザクション）
 */
export const registerUserWithInitialPost = async (
  userData: {
    email: string
    name: string
    avatar?: string
  },
  shouldCreatePost: boolean = false,
  postData?: {
    title: string
    content: string
    excerpt?: string
    slug: string
  },
) => {
  return await db.transaction(async (tx) => {
    // ユーザーを作成
    const [user] = await tx.insert(users).values(userData).returning()

    let post = null

    // 条件に応じて投稿を作成
    if (shouldCreatePost && postData) {
      ;[post] = await tx
        .insert(posts)
        .values({
          ...postData,
          authorId: user.id,
          published: false,
        })
        .returning()
    }

    return { user, post }
  })
}

/**
 * 投稿の公開状態変更と通知処理（トランザクション）
 */
export const publishPostWithNotifications = async (
  postId: string,
  shouldNotify: boolean = false,
) => {
  return await db.transaction(async (tx) => {
    // 投稿を公開
    const [post] = await tx
      .update(posts)
      .set({ published: true, updatedAt: new Date() })
      .where(eq(posts.id, postId))
      .returning()

    // 通知処理（実際の実装では外部APIを呼び出す）
    if (shouldNotify && post) {
      // ここで通知処理を実装
      console.log(`Post ${post.title} has been published!`)
    }

    return post
  })
}
```

## バッチ処理

### 大量データの一括挿入

```typescript
// services/batchService.ts
import { db } from '../lib/database'
import { posts, tags, postTags } from '../schema'
import { eq, inArray } from 'drizzle-orm'

/**
 * 複数の投稿を一括挿入
 */
export const batchInsertPosts = async (
  postsData: Array<{
    title: string
    content: string
    excerpt?: string
    slug: string
    authorId: string
    categoryId?: string
  }>,
) => {
  return await db.insert(posts).values(postsData).returning()
}

/**
 * 投稿とタグの関連付けを一括処理
 */
export const batchAssignTagsToPost = async (postId: string, tagIds: string[]) => {
  const postTagData = tagIds.map((tagId) => ({
    postId,
    tagId,
  }))

  return await db.insert(postTags).values(postTagData).returning()
}

/**
 * 複数の投稿のビュー数を一括更新
 */
export const batchUpdateViewCounts = async (
  updates: Array<{ postId: string; viewCount: number }>,
) => {
  return await db.transaction(async (tx) => {
    const results = await Promise.all(
      updates.map(async ({ postId, viewCount }) => {
        return await tx.update(posts).set({ viewCount }).where(eq(posts.id, postId)).returning()
      }),
    )

    return results.flat()
  })
}
```

### 大量データの一括削除

```typescript
/**
 * 非公開の古い投稿を一括削除
 */
export const batchDeleteOldDraftPosts = async (olderThanDays: number = 30) => {
  const cutoffDate = new Date()
  cutoffDate.setDate(cutoffDate.getDate() - olderThanDays)

  return await db.transaction(async (tx) => {
    // 削除対象の投稿IDを取得
    const postsToDelete = await tx
      .select({ id: posts.id })
      .from(posts)
      .where(and(eq(posts.published, false), sql`${posts.createdAt} < ${cutoffDate.getTime()}`))

    const postIds = postsToDelete.map((p) => p.id)

    if (postIds.length === 0) {
      return { deletedPosts: 0, deletedComments: 0, deletedPostTags: 0 }
    }

    // 関連するコメントを削除
    const deletedComments = await tx.delete(comments).where(inArray(comments.postId, postIds))

    // 関連する投稿タグを削除
    const deletedPostTags = await tx.delete(postTags).where(inArray(postTags.postId, postIds))

    // 投稿を削除
    const deletedPosts = await tx.delete(posts).where(inArray(posts.id, postIds))

    return {
      deletedPosts: postIds.length,
      deletedComments: deletedComments.changes || 0,
      deletedPostTags: deletedPostTags.changes || 0,
    }
  })
}
```

## パフォーマンス最適化

### インデックスの活用

```typescript
// schema/index.ts（インデックス追加）
import { index } from 'drizzle-orm/sqlite-core'

export const posts = sqliteTable(
  'posts',
  {
    // ... 既存のカラム定義
  },
  (table) => ({
    // 複合インデックス
    authorPublishedIdx: index('author_published_idx').on(table.authorId, table.published),
    categoryPublishedIdx: index('category_published_idx').on(table.categoryId, table.published),
    slugIdx: index('slug_idx').on(table.slug),
    createdAtIdx: index('created_at_idx').on(table.createdAt),
  }),
)

export const comments = sqliteTable(
  'comments',
  {
    // ... 既存のカラム定義
  },
  (table) => ({
    postIdIdx: index('post_id_idx').on(table.postId),
    parentIdIdx: index('parent_id_idx').on(table.parentId),
    approvedIdx: index('approved_idx').on(table.approved),
  }),
)
```

### クエリの最適化

```typescript
// services/optimizedService.ts
import { db } from '../lib/database'
import { posts, users, categories, comments } from '../schema'
import { eq, and, desc, asc, count, sql, gte, lte } from 'drizzle-orm'

/**
 * パフォーマンス最適化された投稿一覧取得
 */
export const getOptimizedPostsList = async (
  limit = 10,
  offset = 0,
  categoryId?: string,
  authorId?: string,
) => {
  // 条件を動的に構築
  const conditions = [eq(posts.published, true)]

  if (categoryId) {
    conditions.push(eq(posts.categoryId, categoryId))
  }

  if (authorId) {
    conditions.push(eq(posts.authorId, authorId))
  }

  return await db
    .select({
      id: posts.id,
      title: posts.title,
      excerpt: posts.excerpt,
      slug: posts.slug,
      viewCount: posts.viewCount,
      createdAt: posts.createdAt,
      author: {
        id: users.id,
        name: users.name,
        avatar: users.avatar,
      },
      category: {
        id: categories.id,
        name: categories.name,
        slug: categories.slug,
      },
      commentCount: count(comments.id),
    })
    .from(posts)
    .leftJoin(users, eq(posts.authorId, users.id))
    .leftJoin(categories, eq(posts.categoryId, categories.id))
    .leftJoin(comments, eq(posts.id, comments.postId))
    .where(and(...conditions))
    .groupBy(posts.id, users.id, categories.id)
    .orderBy(desc(posts.createdAt))
    .limit(limit)
    .offset(offset)
}

/**
 * 統計情報の効率的な取得
 */
export const getBlogStatistics = async () => {
  const [stats] = await db
    .select({
      totalPosts: count(posts.id),
      publishedPosts: count(posts.id),
      totalUsers: count(users.id),
      totalComments: count(comments.id),
      totalViews: sql<number>`SUM(${posts.viewCount})`.as('totalViews'),
    })
    .from(posts)
    .leftJoin(users, eq(posts.authorId, users.id))
    .leftJoin(comments, eq(posts.id, comments.postId))
    .where(eq(posts.published, true))

  return stats
}

/**
 * 期間指定での投稿統計
 */
export const getPostsByDateRange = async (startDate: Date, endDate: Date) => {
  return await db
    .select({
      date: sql<string>`DATE(${posts.createdAt}, 'unixepoch')`.as('date'),
      count: count(posts.id),
      totalViews: sql<number>`SUM(${posts.viewCount})`.as('totalViews'),
    })
    .from(posts)
    .where(
      and(
        gte(posts.createdAt, startDate.getTime()),
        lte(posts.createdAt, endDate.getTime()),
        eq(posts.published, true),
      ),
    )
    .groupBy(sql`DATE(${posts.createdAt}, 'unixepoch')`)
    .orderBy(asc(sql`DATE(${posts.createdAt}, 'unixepoch')`))
}
```

## 実践的な応用例

### 検索機能の実装

```typescript
// services/searchService.ts
import { db } from '../lib/database'
import { posts, users, categories, tags, postTags } from '../schema'
import { eq, or, like, and, desc } from 'drizzle-orm'

/**
 * 全文検索機能
 */
export const searchPosts = async (query: string, limit = 10, offset = 0) => {
  const searchTerm = `%${query}%`

  return await db
    .select({
      id: posts.id,
      title: posts.title,
      excerpt: posts.excerpt,
      slug: posts.slug,
      published: posts.published,
      viewCount: posts.viewCount,
      createdAt: posts.createdAt,
      author: {
        id: users.id,
        name: users.name,
        avatar: users.avatar,
      },
      category: {
        id: categories.id,
        name: categories.name,
        slug: categories.slug,
      },
      relevance: sql<number>`
        CASE 
          WHEN ${posts.title} LIKE ${searchTerm} THEN 3
          WHEN ${posts.content} LIKE ${searchTerm} THEN 2
          WHEN ${posts.excerpt} LIKE ${searchTerm} THEN 1
          ELSE 0
        END
      `.as('relevance'),
    })
    .from(posts)
    .leftJoin(users, eq(posts.authorId, users.id))
    .leftJoin(categories, eq(posts.categoryId, categories.id))
    .where(
      and(
        eq(posts.published, true),
        or(
          like(posts.title, searchTerm),
          like(posts.content, searchTerm),
          like(posts.excerpt, searchTerm),
        ),
      ),
    )
    .orderBy(desc(sql`relevance`), desc(posts.createdAt))
    .limit(limit)
    .offset(offset)
}

/**
 * タグによる検索
 */
export const searchPostsByTags = async (tagNames: string[], limit = 10, offset = 0) => {
  return await db
    .select({
      id: posts.id,
      title: posts.title,
      excerpt: posts.excerpt,
      slug: posts.slug,
      published: posts.published,
      viewCount: posts.viewCount,
      createdAt: posts.createdAt,
      author: {
        id: users.id,
        name: users.name,
        avatar: users.avatar,
      },
      category: {
        id: categories.id,
        name: categories.name,
        slug: categories.slug,
      },
      matchedTags: sql<string>`GROUP_CONCAT(${tags.name})`.as('matchedTags'),
    })
    .from(posts)
    .innerJoin(postTags, eq(posts.id, postTags.postId))
    .innerJoin(tags, eq(postTags.tagId, tags.id))
    .leftJoin(users, eq(posts.authorId, users.id))
    .leftJoin(categories, eq(posts.categoryId, categories.id))
    .where(and(eq(posts.published, true), sql`${tags.name} IN (${tagNames.join(',')})`))
    .groupBy(posts.id, users.id, categories.id)
    .orderBy(desc(posts.createdAt))
    .limit(limit)
    .offset(offset)
}
```

### データ分析機能

```typescript
// services/analyticsService.ts
import { db } from '../lib/database'
import { posts, users, comments, categories } from '../schema'
import { eq, and, desc, asc, count, sql, gte, lte } from 'drizzle-orm'

/**
 * 人気投稿ランキング
 */
export const getPopularPosts = async (limit = 10, days = 30) => {
  const cutoffDate = new Date()
  cutoffDate.setDate(cutoffDate.getDate() - days)

  return await db
    .select({
      id: posts.id,
      title: posts.title,
      slug: posts.slug,
      viewCount: posts.viewCount,
      createdAt: posts.createdAt,
      author: {
        id: users.id,
        name: users.name,
      },
      category: {
        id: categories.id,
        name: categories.name,
      },
      commentCount: count(comments.id),
    })
    .from(posts)
    .leftJoin(users, eq(posts.authorId, users.id))
    .leftJoin(categories, eq(posts.categoryId, categories.id))
    .leftJoin(comments, eq(posts.id, comments.postId))
    .where(and(eq(posts.published, true), gte(posts.createdAt, cutoffDate.getTime())))
    .groupBy(posts.id, users.id, categories.id)
    .orderBy(desc(posts.viewCount))
    .limit(limit)
}

/**
 * カテゴリ別統計
 */
export const getCategoryStatistics = async () => {
  return await db
    .select({
      categoryId: categories.id,
      categoryName: categories.name,
      categorySlug: categories.slug,
      postCount: count(posts.id),
      totalViews: sql<number>`SUM(${posts.viewCount})`.as('totalViews'),
      avgViews: sql<number>`AVG(${posts.viewCount})`.as('avgViews'),
    })
    .from(categories)
    .leftJoin(posts, eq(categories.id, posts.categoryId))
    .where(eq(posts.published, true))
    .groupBy(categories.id)
    .orderBy(desc(sql`postCount`))
}

/**
 * 著者別統計
 */
export const getAuthorStatistics = async () => {
  return await db
    .select({
      authorId: users.id,
      authorName: users.name,
      authorEmail: users.email,
      postCount: count(posts.id),
      totalViews: sql<number>`SUM(${posts.viewCount})`.as('totalViews'),
      avgViews: sql<number>`AVG(${posts.viewCount})`.as('avgViews'),
      totalComments: count(comments.id),
    })
    .from(users)
    .leftJoin(posts, eq(users.id, posts.authorId))
    .leftJoin(comments, eq(posts.id, comments.postId))
    .where(eq(posts.published, true))
    .groupBy(users.id)
    .orderBy(desc(sql`postCount`))
}
```

## まとめ

本記事では、Drizzle ORMとSQLiteを組み合わせた複雑なデータベース処理について詳しく解説しました。以下の重要な概念を学びました：

### 学んだポイント

1. **複雑なJOIN処理**: 多対多リレーションや階層データの効率的な取得
2. **トランザクション管理**: データの整合性を保つための安全な操作
3. **バッチ処理**: 大量データの効率的な処理
4. **パフォーマンス最適化**: インデックスとクエリの最適化
5. **実践的な応用**: 検索機能やデータ分析の実装

### Drizzle ORMの利点

[Drizzle ORM](https://orm.drizzle.team/)を使うことで、以下のメリットが得られます：

- **型安全性**: TypeScriptの型システムを活用した完全な型安全性
- **パフォーマンス**: 軽量で高速なクエリ実行
- **SQLライク**: 直感的で理解しやすいクエリ構文
- **柔軟性**: 複雑なクエリも簡単に構築可能
- **マイグレーション**: スキーマ変更の安全な管理

### 実践への応用

これらの概念は、以下のような場面で応用できます：

- **Eコマースシステム**: 商品、カテゴリ、注文の複雑なリレーション
- **SNSアプリケーション**: ユーザー、投稿、フォローの関係性
- **CMSシステム**: 記事、タグ、カテゴリの管理
- **分析システム**: 大量データの集計と分析
- **リアルタイムアプリケーション**: 高速なデータ取得と更新

Drizzle ORMとSQLiteを組み合わせることで、軽量で高性能なデータベース処理を実現できます。適切なスキーマ設計とクエリ最適化により、複雑なビジネスロジックも効率的に実装できるようになります。

いかがでしたか？Drizzle ORMとSQLiteを使った複雑なデータベース処理の魅力を感じていただけたでしょうか。次回は、より高度なデータベース操作や、他のデータベースとの比較についても詳しく解説していきたいと思います。
