---
date: 2025-08-16
title: TypeScriptでOCRを実装する完全ガイド：Tesseract.jsとOpenCV.jsを使った画像文字認識
description: TypeScriptでOCR（光学文字認識）を実装する方法を詳しく解説。Tesseract.js、OpenCV.js、Canvas APIを使った画像処理から、実際のWebアプリケーションでの活用例まで、TypeScript開発者向けのOCR実装ガイドを紹介します。
tags:
  - typescript
  - ocr
  - tesseract
  - opencv
  - image-processing
  - web-development
  - computer-vision
  - machine-learning
prev:
  text: 'TypeScript標準メソッド完全ガイド：配列・文字列・オブジェクトの実践的な使い方'
  link: '/posts/2025/08/15'
next:
  text: 'TypeScriptジェネリクス完全ガイド：never・unknown・型安全性を極める実践テクニック'
  link: '/posts/2025/08/17'
---

# TypeScriptでOCRを実装する完全ガイド：Tesseract.jsとOpenCV.jsを使った画像文字認識

TypeScriptでOCR（光学文字認識）機能を実装したいと思いませんか？本記事では、TypeScriptとWeb技術を組み合わせてOCRシステムを構築する方法を詳しく解説します。Tesseract.js、OpenCV.js、Canvas APIを使った画像処理から、実際のWebアプリケーションでの活用例まで、TypeScript開発者向けのOCR実装ガイドをご紹介します。

## OCRとは

OCR（Optical Character Recognition）は、画像やスキャンされた文書から文字を自動的に認識し、テキストデータに変換する技術です。近年では、Webブラウザ上でも高性能なOCRが実現できるようになり、TypeScriptと組み合わせることで型安全で保守性の高いOCRアプリケーションを構築できます。

### OCRの主要な用途

- **文書デジタル化**: スキャンされたPDFや画像からテキストを抽出
- **画像内テキスト認識**: SNSやWebサイトの画像から文字を読み取り
- **手書き文字認識**: 手書きのメモやノートのデジタル化
- **自動データ入力**: フォームやアンケートの自動処理
- **アクセシビリティ向上**: 視覚障害者向けのテキスト読み上げ

## 必要なライブラリとツール

### 主要なライブラリ

```typescript
// package.json の依存関係
{
  "dependencies": {
    "tesseract.js": "^4.1.1",
    "opencv-ts": "^1.2.1",
    "canvas": "^2.11.2"
  },
  "devDependencies": {
    "@types/node": "^20.0.0"
  }
}
```

### インストール方法

```bash
npm install tesseract.js opencv-ts canvas
npm install --save-dev @types/node
```

## Tesseract.jsを使った基本的なOCR実装

### 1. 基本的な文字認識

```typescript
import { createWorker } from 'tesseract.js'

interface OCRResult {
  readonly text: string
  readonly confidence: number
  readonly words: readonly {
    readonly text: string
    readonly confidence: number
    readonly bbox: {
      readonly x0: number
      readonly y0: number
      readonly x1: number
      readonly y1: number
    }
  }[]
}

class TesseractOCR {
  private worker: Tesseract.Worker | null = null

  async initialize(language: string = 'eng'): Promise<void> {
    this.worker = await createWorker(language)
  }

  async recognize(image: File | HTMLImageElement | HTMLCanvasElement): Promise<OCRResult> {
    if (!this.worker) {
      throw new Error('OCR worker is not initialized')
    }

    const result = await this.worker.recognize(image)

    return {
      text: result.data.text,
      confidence: result.data.confidence,
      words: result.data.words.map((word) => ({
        text: word.text,
        confidence: word.confidence,
        bbox: word.bbox,
      })),
    }
  }

  async terminate(): Promise<void> {
    if (this.worker) {
      await this.worker.terminate()
      this.worker = null
    }
  }
}
```

### 2. 画像前処理の実装

```typescript
interface ImagePreprocessingOptions {
  readonly grayscale?: boolean
  readonly threshold?: number
  readonly blur?: number
  readonly sharpen?: boolean
}

class ImagePreprocessor {
  private canvas: HTMLCanvasElement
  private ctx: CanvasRenderingContext2D

  constructor() {
    this.canvas = document.createElement('canvas')
    const context = this.canvas.getContext('2d')
    if (!context) {
      throw new Error('Failed to get canvas context')
    }
    this.ctx = context
  }

  async preprocessImage(
    image: HTMLImageElement | File,
    options: ImagePreprocessingOptions = {},
  ): Promise<HTMLCanvasElement> {
    // 画像をキャンバスに描画
    if (image instanceof File) {
      await this.loadImageFromFile(image)
    } else {
      this.canvas.width = image.width
      this.canvas.height = image.height
      this.ctx.drawImage(image, 0, 0)
    }

    // グレースケール変換
    if (options.grayscale) {
      this.convertToGrayscale()
    }

    // ぼかし処理
    if (options.blur && options.blur > 0) {
      this.applyBlur(options.blur)
    }

    // シャープ化
    if (options.sharpen) {
      this.applySharpen()
    }

    // 二値化
    if (options.threshold !== undefined) {
      this.applyThreshold(options.threshold)
    }

    return this.canvas
  }

  private async loadImageFromFile(file: File): Promise<void> {
    return new Promise((resolve, reject) => {
      const img = new Image()
      img.onload = () => {
        this.canvas.width = img.width
        this.canvas.height = img.height
        this.ctx.drawImage(img, 0, 0)
        resolve()
      }
      img.onerror = reject
      img.src = URL.createObjectURL(file)
    })
  }

  private convertToGrayscale(): void {
    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height)
    const data = imageData.data

    for (let i = 0; i < data.length; i += 4) {
      const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114
      data[i] = gray // Red
      data[i + 1] = gray // Green
      data[i + 2] = gray // Blue
    }

    this.ctx.putImageData(imageData, 0, 0)
  }

  private applyBlur(radius: number): void {
    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height)
    const blurredData = this.gaussianBlur(imageData, radius)
    this.ctx.putImageData(blurredData, 0, 0)
  }

  private gaussianBlur(imageData: ImageData, radius: number): ImageData {
    const data = imageData.data
    const width = imageData.width
    const height = imageData.height
    const result = new ImageData(width, height)

    // 簡易的なガウシアンブラー実装
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0,
          g = 0,
          b = 0,
          a = 0,
          count = 0

        for (let dy = -radius; dy <= radius; dy++) {
          for (let dx = -radius; dx <= radius; dx++) {
            const nx = x + dx
            const ny = y + dy

            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
              const index = (ny * width + nx) * 4
              r += data[index]
              g += data[index + 1]
              b += data[index + 2]
              a += data[index + 3]
              count++
            }
          }
        }

        const resultIndex = (y * width + x) * 4
        result.data[resultIndex] = r / count
        result.data[resultIndex + 1] = g / count
        result.data[resultIndex + 2] = b / count
        result.data[resultIndex + 3] = a / count
      }
    }

    return result
  }

  private applySharpen(): void {
    const kernel = [
      [0, -1, 0],
      [-1, 5, -1],
      [0, -1, 0],
    ]

    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height)
    const sharpenedData = this.applyConvolution(imageData, kernel)
    this.ctx.putImageData(sharpenedData, 0, 0)
  }

  private applyConvolution(imageData: ImageData, kernel: readonly number[][]): ImageData {
    const data = imageData.data
    const width = imageData.width
    const height = imageData.height
    const result = new ImageData(width, height)
    const kernelSize = kernel.length
    const half = Math.floor(kernelSize / 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0,
          g = 0,
          b = 0,
          a = 0

        for (let ky = 0; ky < kernelSize; ky++) {
          for (let kx = 0; kx < kernelSize; kx++) {
            const nx = x + kx - half
            const ny = y + ky - half

            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
              const index = (ny * width + nx) * 4
              const weight = kernel[ky][kx]
              r += data[index] * weight
              g += data[index + 1] * weight
              b += data[index + 2] * weight
              a += data[index + 3] * weight
            }
          }
        }

        const resultIndex = (y * width + x) * 4
        result.data[resultIndex] = Math.max(0, Math.min(255, r))
        result.data[resultIndex + 1] = Math.max(0, Math.min(255, g))
        result.data[resultIndex + 2] = Math.max(0, Math.min(255, b))
        result.data[resultIndex + 3] = Math.max(0, Math.min(255, a))
      }
    }

    return result
  }

  private applyThreshold(threshold: number): void {
    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height)
    const data = imageData.data

    for (let i = 0; i < data.length; i += 4) {
      const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114
      const value = gray > threshold ? 255 : 0
      data[i] = value // Red
      data[i + 1] = value // Green
      data[i + 2] = value // Blue
    }

    this.ctx.putImageData(imageData, 0, 0)
  }
}
```

## OpenCV.jsを使った高度な画像処理

### 1. OpenCV.jsの初期化と基本操作

```typescript
import cv from 'opencv-ts'

interface OpenCVOCRResult {
  readonly text: string
  readonly confidence: number
  readonly boundingBoxes: readonly {
    readonly x: number
    readonly y: number
    readonly width: number
    readonly height: number
  }[]
}

class OpenCVOCR {
  private isInitialized = false

  async initialize(): Promise<void> {
    if (typeof window !== 'undefined') {
      await cv.ready
      this.isInitialized = true
    }
  }

  async detectTextRegions(image: HTMLImageElement): Promise<OpenCVOCRResult> {
    if (!this.isInitialized) {
      throw new Error('OpenCV is not initialized')
    }

    // 画像をMatに変換
    const src = cv.imread(image)
    const gray = new cv.Mat()
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)

    // ノイズ除去
    const denoised = new cv.Mat()
    cv.medianBlur(gray, denoised, 3)

    // エッジ検出
    const edges = new cv.Mat()
    cv.Canny(denoised, edges, 50, 150)

    // 輪郭検出
    const contours = new cv.MatVector()
    const hierarchy = new cv.Mat()
    cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)

    // テキスト領域の候補を抽出
    const textRegions: Array<{
      readonly x: number
      readonly y: number
      readonly width: number
      readonly height: number
    }> = []

    for (let i = 0; i < contours.size(); i++) {
      const contour = contours.get(i)
      const area = cv.contourArea(contour)

      // 面積が一定以上の輪郭のみを対象
      if (area > 100) {
        const rect = cv.boundingRect(contour)
        const aspectRatio = rect.width / rect.height

        // テキストらしい縦横比の領域を抽出
        if (aspectRatio > 0.5 && aspectRatio < 10) {
          textRegions.push({
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height,
          })
        }
      }
    }

    // メモリ解放
    src.delete()
    gray.delete()
    denoised.delete()
    edges.delete()
    contours.delete()
    hierarchy.delete()

    return {
      text: '', // Tesseract.jsで実際の文字認識を行う
      confidence: 0,
      boundingBoxes: textRegions,
    }
  }
}
```

### 2. 画像の品質向上処理

```typescript
class ImageEnhancer {
  async enhanceForOCR(image: HTMLImageElement): Promise<HTMLCanvasElement> {
    const src = cv.imread(image)

    // グレースケール変換
    const gray = new cv.Mat()
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)

    // 適応的ヒストグラム平坦化
    const enhanced = new cv.Mat()
    cv.equalizeHist(gray, enhanced)

    // ノイズ除去（バイラテラルフィルタ）
    const denoised = new cv.Mat()
    cv.bilateralFilter(enhanced, denoised, 9, 75, 75)

    // シャープ化
    const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3))
    const sharpened = new cv.Mat()
    cv.morphologyEx(denoised, sharpened, cv.MORPH_GRADIENT, kernel)

    // 結果をキャンバスに描画
    const canvas = document.createElement('canvas')
    canvas.width = image.width
    canvas.height = image.height
    cv.imshow(canvas, sharpened)

    // メモリ解放
    src.delete()
    gray.delete()
    enhanced.delete()
    denoised.delete()
    sharpened.delete()
    kernel.delete()

    return canvas
  }
}
```

## 実践的なOCRアプリケーションの実装

### 1. ファイルアップロード機能付きOCRコンポーネント

```typescript
interface OCRAppState {
  readonly isProcessing: boolean
  readonly result: OCRResult | null
  readonly error: string | null
  readonly processingTime: number | null
}

class OCRApplication {
  private ocr: TesseractOCR
  private preprocessor: ImagePreprocessor
  private enhancer: ImageEnhancer
  private state: OCRAppState = {
    isProcessing: false,
    result: null,
    error: null,
    processingTime: null,
  }

  constructor() {
    this.ocr = new TesseractOCR()
    this.preprocessor = new ImagePreprocessor()
    this.enhancer = new ImageEnhancer()
  }

  async initialize(): Promise<void> {
    await this.ocr.initialize('jpn+eng') // 日本語と英語をサポート
  }

  async processImage(file: File): Promise<OCRResult> {
    const startTime = performance.now()

    try {
      this.updateState({ isProcessing: true, error: null })

      // 画像の前処理
      const preprocessedCanvas = await this.preprocessor.preprocessImage(file, {
        grayscale: true,
        blur: 1,
        sharpen: true,
        threshold: 128,
      })

      // 画像の品質向上
      const enhancedCanvas = await this.enhancer.enhanceForOCR(preprocessedCanvas)

      // OCR実行
      const result = await this.ocr.recognize(enhancedCanvas)

      const processingTime = performance.now() - startTime
      this.updateState({
        isProcessing: false,
        result,
        processingTime,
      })

      return result
    } catch (error) {
      const processingTime = performance.now() - startTime
      this.updateState({
        isProcessing: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        processingTime,
      })
      throw error
    }
  }

  private updateState(updates: Partial<OCRAppState>): void {
    this.state = { ...this.state, ...updates }
    this.notifyStateChange()
  }

  private notifyStateChange(): void {
    // 状態変更を通知する処理（イベントエミッターなど）
    console.log('State updated:', this.state)
  }

  getState(): OCRAppState {
    return { ...this.state }
  }

  async cleanup(): Promise<void> {
    await this.ocr.terminate()
  }
}
```

### 2. React/Vue.jsでの統合例

```typescript
// React フックの例
import { useState, useEffect, useCallback } from 'react'

interface UseOCRReturn {
  readonly isProcessing: boolean
  readonly result: OCRResult | null
  readonly error: string | null
  readonly processingTime: number | null
  readonly processImage: (file: File) => Promise<void>
}

export const useOCR = (): UseOCRReturn => {
  const [app] = useState(() => new OCRApplication())
  const [state, setState] = useState<OCRAppState>({
    isProcessing: false,
    result: null,
    error: null,
    processingTime: null,
  })

  useEffect(() => {
    app.initialize()
    return () => {
      app.cleanup()
    }
  }, [app])

  const processImage = useCallback(
    async (file: File) => {
      try {
        const result = await app.processImage(file)
        setState((prev) => ({ ...prev, result }))
      } catch (error) {
        setState((prev) => ({
          ...prev,
          error: error instanceof Error ? error.message : 'Unknown error',
        }))
      }
    },
    [app],
  )

  return {
    ...state,
    processImage,
  }
}
```

## パフォーマンス最適化とベストプラクティス

### 1. ワーカースレッドの活用

```typescript
class OCRWorkerManager {
  private workers: TesseractOCR[] = []
  private maxWorkers: number

  constructor(maxWorkers: number = navigator.hardwareConcurrency || 4) {
    this.maxWorkers = maxWorkers
  }

  async initialize(): Promise<void> {
    const initPromises = Array.from({ length: this.maxWorkers }, async () => {
      const worker = new TesseractOCR()
      await worker.initialize()
      return worker
    })

    this.workers = await Promise.all(initPromises)
  }

  async processBatch(images: readonly File[]): Promise<readonly OCRResult[]> {
    const results: OCRResult[] = []
    const chunks = this.chunkArray(images, this.maxWorkers)

    for (const chunk of chunks) {
      const chunkPromises = chunk.map((image, index) => this.workers[index].recognize(image))
      const chunkResults = await Promise.all(chunkPromises)
      results.push(...chunkResults)
    }

    return results
  }

  private chunkArray<T>(array: readonly T[], size: number): T[][] {
    const chunks: T[][] = []
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size))
    }
    return chunks
  }

  async cleanup(): Promise<void> {
    await Promise.all(this.workers.map((worker) => worker.terminate()))
    this.workers = []
  }
}
```

### 2. キャッシュ機能の実装

```typescript
class OCRCache {
  private cache = new Map<string, OCRResult>()

  generateKey(image: File): string {
    return `${image.name}-${image.size}-${image.lastModified}`
  }

  get(image: File): OCRResult | undefined {
    const key = this.generateKey(image)
    return this.cache.get(key)
  }

  set(image: File, result: OCRResult): void {
    const key = this.generateKey(image)
    this.cache.set(key, result)
  }

  clear(): void {
    this.cache.clear()
  }
}
```

## まとめ

TypeScriptとOCR技術を組み合わせることで、型安全で保守性の高い文字認識アプリケーションを構築できます。Tesseract.jsとOpenCV.jsを活用した画像処理、適切な前処理、パフォーマンス最適化により、高精度なOCRシステムを実現できます。

特に重要なポイントは以下の通りです：

- **画像前処理の重要性**: 適切な前処理により認識精度が大幅に向上する
- **型安全性の確保**: TypeScriptの型システムを活用して堅牢なコードを書く
- **パフォーマンスの最適化**: ワーカースレッドやキャッシュを活用して効率的な処理を実現する
- **エラーハンドリング**: 適切なエラー処理によりユーザー体験を向上させる

これらの技術を習得することで、Webブラウザ上で動作する高性能なOCRアプリケーションを開発できます。実践的なプロジェクトで積極的に活用し、より良いユーザー体験を提供していきましょう。
