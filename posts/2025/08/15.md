---
date: 2025-08-15
title: TypeScript標準メソッド完全ガイド：配列・文字列・オブジェクトの実践的な使い方
description: TypeScriptで使用される標準メソッドを徹底解説。配列操作、文字列処理、オブジェクト操作から、型安全な開発に役立つ実践的なテクニックまで、TypeScript開発者必見のメソッド集を詳しく紹介します。
tags:
    - typescript
    - javascript
    - standard-library
    - array-methods
    - string-methods
    - object-methods
    - functional-programming
    - best-practices
prev:
    text: "Pydantic完全ガイド：Pythonで型安全なデータバリデーションを実現する"
    link: "/posts/2025/08/14"
next:
    text: "TypeScriptでOCRを実装する完全ガイド：Tesseract.jsとOpenCV.jsを使った画像文字認識"
    link: "/posts/2025/08/16"
---

# TypeScript標準メソッド完全ガイド：配列・文字列・オブジェクトの実践的な使い方

TypeScriptで開発する際に、標準メソッドを効果的に活用できていますか？本記事では、TypeScriptで使用される主要な標準メソッドを、実践的な例とともに詳しく解説します。配列操作、文字列処理、オブジェクト操作から、型安全な開発に役立つテクニックまで、TypeScript開発者にとって必須の知識をご紹介します。

## 配列メソッド

### 基本的な配列操作

TypeScriptの配列メソッドは、型安全性を保ちながら効率的なデータ処理を実現します。

#### map - 配列の変換

```typescript
// 数値配列を文字列配列に変換
const numbers: readonly number[] = [1, 2, 3, 4, 5]
const strings: readonly string[] = numbers.map(n => n.toString())
// ['1', '2', '3', '4', '5']

// オブジェクト配列の変換
interface User {
  readonly id: number
  readonly name: string
  readonly age: number
}

const users: readonly User[] = [
  { id: 1, name: 'Alice', age: 25 },
  { id: 2, name: 'Bob', age: 30 },
  { id: 3, name: 'Charlie', age: 35 }
]

const userNames: readonly string[] = users.map(user => user.name)
// ['Alice', 'Bob', 'Charlie']

// インデックスを活用した変換
const indexedStrings: readonly string[] = numbers.map((n, index) => `${index}: ${n}`)
// ['0: 1', '1: 2', '2: 3', '3: 4', '4: 5']
```

#### filter - 条件に基づくフィルタリング

```typescript
// 偶数のみを抽出
const evenNumbers: readonly number[] = numbers.filter(n => n % 2 === 0)
// [2, 4]

// 複雑な条件でのフィルタリング
const adults: readonly User[] = users.filter(user => user.age >= 30)
// [{ id: 2, name: 'Bob', age: 30 }, { id: 3, name: 'Charlie', age: 35 }]

// 型ガードを活用したフィルタリング
const mixedData: readonly (string | number)[] = ['hello', 42, 'world', 100]
const stringsOnly: readonly string[] = mixedData.filter((item): item is string => 
  typeof item === 'string'
)
// ['hello', 'world']
```

#### reduce - 配列の集約

```typescript
// 数値配列の合計
const sum: number = numbers.reduce((acc, curr) => acc + curr, 0)
// 15

// オブジェクト配列の集約
const totalAge: number = users.reduce((acc, user) => acc + user.age, 0)
// 90

// 複雑な集約処理
interface Product {
  readonly id: number
  readonly name: string
  readonly price: number
  readonly category: string
}

const products: readonly Product[] = [
  { id: 1, name: 'Laptop', price: 1000, category: 'Electronics' },
  { id: 2, name: 'Book', price: 20, category: 'Books' },
  { id: 3, name: 'Phone', price: 500, category: 'Electronics' }
]

// カテゴリ別の価格合計
const categoryTotals: Record<string, number> = products.reduce((acc, product) => {
  acc[product.category] = (acc[product.category] || 0) + product.price
  return acc
}, {} as Record<string, number>)
// { Electronics: 1500, Books: 20 }
```

### 高度な配列操作

#### flatMap - 平坦化と変換の組み合わせ

```typescript
// ネストした配列の平坦化
const nestedArrays: readonly number[][] = [[1, 2], [3, 4], [5, 6]]
const flattened: readonly number[] = nestedArrays.flatMap(arr => arr)
// [1, 2, 3, 4, 5, 6]

// 条件付きの要素展開
const expandedNumbers: readonly number[] = numbers.flatMap(n => 
  n % 2 === 0 ? [n, n * 2] : [n]
)
// [1, 2, 4, 3, 4, 8, 5]
```

#### find と findIndex - 要素の検索

```typescript
// 条件に合う最初の要素を検索
const firstAdult: User | undefined = users.find(user => user.age >= 30)
// { id: 2, name: 'Bob', age: 30 }

// インデックスの検索
const adultIndex: number = users.findIndex(user => user.age >= 30)
// 1

// 存在しない場合の処理
const youngUser: User | undefined = users.find(user => user.age < 20)
// undefined
```

## 文字列メソッド

### 基本的な文字列操作

#### 検索と置換

```typescript
const text = 'Hello, TypeScript World!'

// 部分文字列の検索
const hasTypeScript: boolean = text.includes('TypeScript')
// true

// 位置の検索
const typeScriptIndex: number = text.indexOf('TypeScript')
// 7

// 末尾からの検索
const lastOIndex: number = text.lastIndexOf('o')
// 15

// 置換
const replaced: string = text.replace('TypeScript', 'JavaScript')
// 'Hello, JavaScript World!'

// グローバル置換
const globalReplaced: string = text.replaceAll('o', '0')
// 'Hell0, TypeScript W0rld!'
```

#### 分割と結合

```typescript
// 文字列の分割
const words: readonly string[] = text.split(' ')
// ['Hello,', 'TypeScript', 'World!']

// 複数の区切り文字での分割
const complexText = 'apple,banana;orange grape'
const fruits: readonly string[] = complexText.split(/[,;\s]/)
// ['apple', 'banana', 'orange', 'grape']

// 配列の結合
const joined: string = words.join(' - ')
// 'Hello, - TypeScript - World!'
```

#### 大文字小文字の変換

```typescript
const mixedCase = 'TypeScript Programming'

// 大文字変換
const upperCase: string = mixedCase.toUpperCase()
// 'TYPESCRIPT PROGRAMMING'

// 小文字変換
const lowerCase: string = mixedCase.toLowerCase()
// 'typescript programming'

// タイトルケース（最初の文字のみ大文字）
const titleCase: string = mixedCase.charAt(0).toUpperCase() + 
  mixedCase.slice(1).toLowerCase()
// 'Typescript programming'
```

### 高度な文字列処理

#### パディングとトリミング

```typescript
const shortText = 'Hello'

// 左側にパディング
const leftPadded: string = shortText.padStart(10, '*')
// '*****Hello'

// 右側にパディング
const rightPadded: string = shortText.padEnd(10, '*')
// 'Hello*****'

// 空白の削除
const trimmedText = '  Hello World  '
const trimmed: string = trimmedText.trim()
// 'Hello World'

// 左側のみ削除
const leftTrimmed: string = trimmedText.trimStart()
// 'Hello World  '

// 右側のみ削除
const rightTrimmed: string = trimmedText.trimEnd()
// '  Hello World'
```

#### 部分文字列の抽出

```typescript
const longText = 'TypeScript is awesome!'

// 指定位置から末尾まで
const fromIndex5: string = longText.substring(5)
// 'cript is awesome!'

// 指定範囲
const range5to10: string = longText.substring(5, 10)
// 'cript'

// slice メソッド（負のインデックス対応）
const last5Chars: string = longText.slice(-5)
// 'some!'

const rangeWithNegative: string = longText.slice(5, -6)
// 'cript is awe'
```

## オブジェクトメソッド

### オブジェクトの操作

#### キーと値の取得

```typescript
const person = {
  name: 'Alice',
  age: 25,
  city: 'Tokyo'
} as const

// キーの取得
const keys: readonly string[] = Object.keys(person)
// ['name', 'age', 'city']

// 値の取得
const values: readonly (string | number)[] = Object.values(person)
// ['Alice', 25, 'Tokyo']

// エントリの取得
const entries: readonly [string, string | number][] = Object.entries(person)
// [['name', 'Alice'], ['age', 25], ['city', 'Tokyo']]
```

#### オブジェクトの作成と結合

```typescript
// オブジェクトの作成
const newObj = Object.create(null)
// プロトタイプなしのオブジェクト

// オブジェクトの結合
const obj1 = { a: 1, b: 2 }
const obj2 = { c: 3, d: 4 }
const combined = Object.assign({}, obj1, obj2)
// { a: 1, b: 2, c: 3, d: 4 }

// スプレッド構文を使用した結合
const spreadCombined = { ...obj1, ...obj2 }
// { a: 1, b: 2, c: 3, d: 4 }

// プロパティの存在確認
const hasName: boolean = Object.prototype.hasOwnProperty.call(person, 'name')
// true

// より安全な方法（Object.hasOwn）
const hasAge: boolean = Object.hasOwn(person, 'age')
// true
```

### 高度なオブジェクト操作

#### プロパティの定義

```typescript
// プロパティの定義
const configurableObj: Record<string, unknown> = {}

Object.defineProperty(configurableObj, 'readOnly', {
  value: 'cannot be changed',
  writable: false,
  enumerable: true,
  configurable: false
})

// 複数プロパティの定義
Object.defineProperties(configurableObj, {
  computed: {
    get() {
      return this.readOnly + ' - computed'
    },
    enumerable: true
  },
  hidden: {
    value: 'not enumerable',
    enumerable: false
  }
})
```

#### オブジェクトの凍結

```typescript
// 浅い凍結（プロパティの変更を防ぐ）
const frozenObj = Object.freeze({ name: 'Alice', details: { age: 25 } })
// frozenObj.name = 'Bob' // TypeError

// 深い凍結の実装
const deepFreeze = <T extends Record<string, unknown>>(obj: T): T => {
  Object.keys(obj).forEach(prop => {
    if (typeof obj[prop] === 'object' && obj[prop] !== null) {
      deepFreeze(obj[prop] as Record<string, unknown>)
    }
  })
  return Object.freeze(obj)
}

const deeplyFrozen = deepFreeze({ 
  name: 'Alice', 
  details: { age: 25, city: 'Tokyo' } 
})
```

## 実践的な使用例

### データ変換パイプライン

```typescript
interface RawData {
  readonly id: string
  readonly name: string
  readonly score: string
  readonly category: string
}

interface ProcessedData {
  readonly id: number
  readonly name: string
  readonly score: number
  readonly category: string
  readonly grade: string
}

const rawData: readonly RawData[] = [
  { id: '1', name: 'Alice', score: '85', category: 'A' },
  { id: '2', name: 'Bob', score: '92', category: 'B' },
  { id: '3', name: 'Charlie', score: '78', category: 'A' }
]

// データ変換パイプライン
const processedData: readonly ProcessedData[] = rawData
  .filter(item => item.score !== '') // 空のスコアを除外
  .map(item => ({
    id: parseInt(item.id, 10),
    name: item.name.trim(),
    score: parseInt(item.score, 10),
    category: item.category,
    grade: parseInt(item.score, 10) >= 90 ? 'A' : 
           parseInt(item.score, 10) >= 80 ? 'B' : 'C'
  }))
  .filter(item => item.score >= 80) // 80点以上のみ
  .sort((a, b) => b.score - a.score) // スコア順でソート
```

### 型安全なユーティリティ関数

```typescript
// 配列の重複除去（型安全）
const unique = <T>(array: readonly T[]): readonly T[] => 
  Array.from(new Set(array))

// オブジェクトの深いコピー
const deepClone = <T>(obj: T): T => {
  if (obj === null || typeof obj !== 'object') {
    return obj
  }
  
  if (obj instanceof Date) {
    return new Date(obj.getTime()) as T
  }
  
  if (Array.isArray(obj)) {
    return obj.map(item => deepClone(item)) as T
  }
  
  const cloned = {} as T
  Object.keys(obj).forEach(key => {
    cloned[key as keyof T] = deepClone(obj[key as keyof T])
  })
  
  return cloned
}

// 条件付きオブジェクト作成
const createConditionalObject = <T extends Record<string, unknown>>(
  condition: boolean,
  trueProps: T,
  falseProps: Partial<T> = {}
): T => condition ? trueProps : { ...trueProps, ...falseProps }
```

## パフォーマンスの最適化

### メソッドチェーンの最適化

```typescript
// 非効率な例
const inefficient = numbers
  .map(n => n * 2)
  .filter(n => n > 5)
  .map(n => n.toString())
  .filter(s => s.length > 1)

// 効率的な例（一度のループで処理）
const efficient = numbers
  .reduce<string[]>((acc, n) => {
    const doubled = n * 2
    if (doubled > 5) {
      const str = doubled.toString()
      if (str.length > 1) {
        acc.push(str)
      }
    }
    return acc
  }, [])
```

### メモ化による最適化

```typescript
// 高価な計算のメモ化
const memoize = <T extends readonly unknown[], R>(
  fn: (...args: T) => R
): ((...args: T) => R) => {
  const cache = new Map<string, R>()
  
  return (...args: T): R => {
    const key = JSON.stringify(args)
    if (cache.has(key)) {
      return cache.get(key)!
    }
    
    const result = fn(...args)
    cache.set(key, result)
    return result
  }
}

// 使用例
const expensiveCalculation = memoize((n: number): number => {
  // 重い計算をシミュレート
  return n * n * n
})
```

## まとめ

TypeScriptの標準メソッドは、型安全性を保ちながら効率的なデータ処理を実現する強力なツールです。配列メソッド、文字列メソッド、オブジェクトメソッドを適切に組み合わせることで、読みやすく保守性の高いコードを書くことができます。

特に重要なポイントは以下の通りです：

- **型安全性**: TypeScriptの型システムを活用して、コンパイル時にエラーを検出する
- **不変性**: `readonly`配列や`const`アサーションを活用して、予期しない変更を防ぐ
- **関数型プログラミング**: メソッドチェーンを活用して、宣言的なコードを書く
- **パフォーマンス**: 適切なメソッドを選択し、必要に応じて最適化を行う

これらのメソッドを習得することで、TypeScriptでの開発効率とコード品質を大幅に向上させることができます。実践的なプロジェクトで積極的に活用し、より良いTypeScriptコードを書いていきましょう。
