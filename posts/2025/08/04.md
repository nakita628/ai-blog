---
date: 2025-08-04
title: VitestとPrismaで実践するモックテスト：TypeScriptによる効率的なテスト設計
description: VitestとPrismaを組み合わせたモックテストの実装方法を解説。TypeScriptの型安全性を活かしたテストケースの作成から、Prismaクライアントのモック化、テストの自動化まで詳しく紹介します。
tags:
    - typescript
    - vitest
    - prisma
    - testing
    - mock
    - database
    - orm
prev:
    text: "OpenAPIとモックを活用した効率的なAPIテスト設計"
    link: "/posts/2025/08/02"
next:
    text: "AWSの実践的な活用：インフラストラクチャの設計から運用まで"
    link: "/posts/2025/08/05"
---

# VitestとPrismaで実践するモックテスト：TypeScriptによる効率的なテスト設計

データベースを使用するアプリケーションのテストでは、Prismaのモック化が重要です。本記事では、VitestとTypeScriptを使用して、効率的なモックテストを実装する方法を解説します。

## テスト環境のセットアップ

```ts
import { beforeEach, describe, expect, it, vi } from 'vitest'
import { PrismaClient } from '@prisma/client'
import { mockDeep, mockReset } from 'vitest-mock-extended'

// グローバルモックの設定
const prisma = mockDeep<PrismaClient>()

// テストごとのモックリセット
beforeEach(() => {
  mockReset(prisma)
})
```

## サービス層のテスト実装例

```ts
// ユーザーサービスの実装
class UserService {
  constructor(private prisma: PrismaClient) {}

  async createUser(data: { name: string; email: string }) {
    return this.prisma.user.create({
      data,
      select: {
        id: true,
        name: true,
        email: true
      }
    })
  }

  async updateUser(id: number, data: { name?: string; email?: string }) {
    return this.prisma.user.update({
      where: { id },
      data,
      select: {
        id: true,
        name: true,
        email: true
      }
    })
  }
}

// テストケース
describe('UserService', () => {
  const service = new UserService(prisma)

  it('should create a user', async () => {
    const mockUser = {
      id: 1,
      name: 'Test User',
      email: 'test@example.com'
    }
    
    prisma.user.create.mockResolvedValue(mockUser)
    
    const result = await service.createUser({
      name: 'Test User',
      email: 'test@example.com'
    })
    
    expect(result).toEqual(mockUser)
    expect(prisma.user.create).toHaveBeenCalledWith({
      data: {
        name: 'Test User',
        email: 'test@example.com'
      },
      select: {
        id: true,
        name: true,
        email: true
      }
    })
  })
})
```

## トランザクション処理のテスト

```ts
describe('Transaction Tests', () => {
  it('should handle nested transactions', async () => {
    const mockTx = mockDeep<PrismaClient>()
    prisma.$transaction.mockImplementation(async (cb) => {
      return cb(mockTx)
    })

    const service = new UserService(prisma)
    await service.createUserWithProfile({
      user: { name: 'Test', email: 'test@example.com' },
      profile: { bio: 'Test bio' }
    })
    
    expect(mockTx.user.create).toHaveBeenCalled()
    expect(mockTx.profile.create).toHaveBeenCalled()
  })
})
```

## エラーハンドリングのテスト

```ts
describe('Error Handling', () => {
  it('should handle database errors', async () => {
    prisma.user.create.mockRejectedValue(
      new Error('Unique constraint violation')
    )

    const service = new UserService(prisma)
    await expect(
      service.createUser({
        name: 'Test',
        email: 'existing@example.com'
      })
    ).rejects.toThrow('Unique constraint violation')
  })
})
```

## モックテストのベストプラクティス

1. モックの粒度設計
   - 必要最小限のモック化
   - 副作用の分離
   - テストの意図を明確に

2. 型安全性の確保
   - `vitest-mock-extended`の活用
   - 厳密な型チェックの維持
   - コンパイル時のエラー検出

3. テストケースの設計
   - 境界値テストの実施
   - エッジケースの考慮
   - テストカバレッジの確認

## まとめ

VitestとPrismaを組み合わせることで、型安全で効率的なモックテストが実現できます。適切なモック化と厳密な型チェックにより、テストの品質と保守性が向上します。本記事の手法を参考に、堅牢なテスト設計を目指しましょう。
