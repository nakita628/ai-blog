---
date: 2025-08-22
title: TypeScriptで実践する関数型エラーハンドリング：neverthrowとPrismaを使った副作用の安全な制御
description: TypeScriptでneverthrowとPrismaを組み合わせた実践的な関数型プログラミングを解説。副作用を持つデータベース操作をResult型で安全に制御し、エラーハンドリングを型安全に実装する方法を詳しく紹介します。
tags:
  - typescript
  - functional-programming
  - neverthrow
  - prisma
  - error-handling
  - database
  - result-type
  - side-effects
prev:
  text: 'TypeScriptによる画像軽量化処理：Canvas APIとWeb Workersを使った実践的な最適化手法'
  link: '/posts/2025/08/19'
next:
  text: 'Drizzle ORMとSQLiteで実践する複雑なデータベース処理：JOIN・トランザクション・バッチ処理の完全ガイド'
  link: '/posts/2025/08/23'
---

# TypeScriptで実践する関数型エラーハンドリング：neverthrowとPrismaを使った副作用の安全な制御

現代のWebアプリケーション開発では、データベース操作や外部APIとの通信など、多くの副作用を伴う処理が必要です。本記事では、TypeScriptでneverthrowとPrismaを組み合わせた実践的な関数型プログラミングについて詳しく解説します。副作用を持つ処理をResult型で安全に制御し、型安全なエラーハンドリングを実現する方法をご紹介します。

## 関数型プログラミングと副作用の課題

関数型プログラミングでは、純粋関数（副作用を持たない関数）を重視しますが、実際のアプリケーションでは以下のような副作用が避けられません：

- **データベース操作**: データの読み書き
- **ファイルI/O**: ファイルの読み書き
- **ネットワーク通信**: API呼び出し
- **ログ出力**: デバッグ情報の記録
- **状態管理**: グローバル状態の変更

これらの副作用を適切に制御し、エラーハンドリングを型安全に行うために、neverthrowのResult型が非常に有効です。

### neverthrowの基本概念

[neverthrow](https://www.npmjs.com/package/neverthrow)は、TypeScriptで関数型エラーハンドリングを実現するライブラリです。主な特徴は以下の通りです：

- **Result型**: 成功（Ok）または失敗（Err）を表現
- **型安全**: TypeScriptの型システムを活用した安全なエラーハンドリング
- **関数型**: メソッドチェーンによる宣言的な処理
- **例外禁止**: throwを使わずにエラーを表現

## Prismaとneverthrowの組み合わせ

### 基本的なセットアップ

まず、必要なパッケージをインストールします：

```bash
npm install neverthrow @prisma/client
npm install -D prisma
```

### Prismaスキーマの定義

ユーザー管理システムを例として、Prismaスキーマを定義します：

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  posts     Post[]
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  String
  author    User     @relation(fields: [authorId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

## 型安全なエラー定義

### ドメインエラーの定義

関数型プログラミングでは、エラーを型として明示的に定義します：

```typescript
// types/errors.ts
export type DatabaseError =
  | { readonly _tag: 'ConnectionError'; readonly message: string }
  | { readonly _tag: 'QueryError'; readonly message: string; readonly code: string }
  | { readonly _tag: 'TransactionError'; readonly message: string }

export type ValidationError =
  | { readonly _tag: 'InvalidEmail'; readonly value: string }
  | { readonly _tag: 'InvalidName'; readonly value: string }
  | { readonly _tag: 'RequiredField'; readonly field: string }

export type UserError =
  | { readonly _tag: 'UserNotFound'; readonly id: string }
  | { readonly _tag: 'UserAlreadyExists'; readonly email: string }
  | { readonly _tag: 'InvalidUserData'; readonly issues: readonly ValidationError[] }

export type PostError =
  | { readonly _tag: 'PostNotFound'; readonly id: string }
  | { readonly _tag: 'InvalidPostData'; readonly issues: readonly ValidationError[] }
  | { readonly _tag: 'Unauthorized'; readonly userId: string; readonly postId: string }

export type AppError = DatabaseError | UserError | PostError
```

## バリデーション層の実装

### Zodを使った型安全なバリデーション

```typescript
// schemas/user.ts
import { z } from 'zod'
import { Result, ok, err } from 'neverthrow'
import type { ValidationError } from '../types/errors'

export const UserCreateSchema = z.object({
  email: z.string().email('有効なメールアドレスを入力してください'),
  name: z.string().min(1, '名前は必須です').max(100, '名前は100文字以内で入力してください'),
})

export const UserUpdateSchema = UserCreateSchema.partial()

export type UserCreate = z.infer<typeof UserCreateSchema>
export type UserUpdate = z.infer<typeof UserUpdateSchema>

/**
 * ユーザー作成データのバリデーション
 */
export const validateUserCreate = (data: unknown): Result<UserCreate, ValidationError[]> => {
  const result = UserCreateSchema.safeParse(data)

  if (result.success) {
    return ok(result.data)
  }

  const errors: ValidationError[] = result.error.issues.map((issue) => ({
    _tag: 'RequiredField' as const,
    field: issue.path.join('.'),
  }))

  return err(errors)
}

/**
 * ユーザー更新データのバリデーション
 */
export const validateUserUpdate = (data: unknown): Result<UserUpdate, ValidationError[]> => {
  const result = UserUpdateSchema.safeParse(data)

  if (result.success) {
    return ok(result.data)
  }

  const errors: ValidationError[] = result.error.issues.map((issue) => ({
    _tag: 'RequiredField' as const,
    field: issue.path.join('.'),
  }))

  return err(errors)
}
```

## データベース操作層の実装

### Prismaクライアントのラッパー

```typescript
// lib/prisma.ts
import { PrismaClient } from '@prisma/client'
import { Result, ok, err } from 'neverthrow'
import type { DatabaseError } from '../types/errors'

const prisma = new PrismaClient()

/**
 * PrismaエラーをResult型に変換するユーティリティ
 */
const handlePrismaError = (error: unknown): DatabaseError => {
  if (error instanceof Error) {
    return {
      _tag: 'QueryError',
      message: error.message,
      code: 'UNKNOWN',
    }
  }

  return {
    _tag: 'QueryError',
    message: 'Unknown database error',
    code: 'UNKNOWN',
  }
}

/**
 * データベース接続のテスト
 */
export const testConnection = async (): Promise<Result<void, DatabaseError>> => {
  try {
    await prisma.$connect()
    return ok(undefined)
  } catch (error) {
    return err({
      _tag: 'ConnectionError',
      message: error instanceof Error ? error.message : 'Connection failed',
    })
  }
}

export { prisma }
```

### ユーザー操作の実装

```typescript
// services/userService.ts
import { Result, ok, err } from 'neverthrow'
import { prisma, handlePrismaError } from '../lib/prisma'
import {
  validateUserCreate,
  validateUserUpdate,
  type UserCreate,
  type UserUpdate,
} from '../schemas/user'
import type { UserError, DatabaseError, AppError } from '../types/errors'

/**
 * ユーザー作成サービス
 */
export const createUser = async (data: unknown): Promise<Result<{ id: string }, AppError>> => {
  // バリデーション
  const validationResult = validateUserCreate(data)
  if (validationResult.isErr()) {
    return err({ _tag: 'InvalidUserData', issues: validationResult.error })
  }

  const userData = validationResult.value

  try {
    // 既存ユーザーのチェック
    const existingUser = await prisma.user.findUnique({
      where: { email: userData.email },
    })

    if (existingUser) {
      return err({ _tag: 'UserAlreadyExists', email: userData.email })
    }

    // ユーザー作成
    const user = await prisma.user.create({
      data: userData,
    })

    return ok({ id: user.id })
  } catch (error) {
    return err(handlePrismaError(error))
  }
}

/**
 * ユーザー取得サービス
 */
export const getUserById = async (
  id: string,
): Promise<Result<{ id: string; email: string; name: string | null }, AppError>> => {
  try {
    const user = await prisma.user.findUnique({
      where: { id },
      select: { id: true, email: true, name: true },
    })

    if (!user) {
      return err({ _tag: 'UserNotFound', id })
    }

    return ok(user)
  } catch (error) {
    return err(handlePrismaError(error))
  }
}

/**
 * ユーザー更新サービス
 */
export const updateUser = async (
  id: string,
  data: unknown,
): Promise<Result<{ id: string }, AppError>> => {
  // バリデーション
  const validationResult = validateUserUpdate(data)
  if (validationResult.isErr()) {
    return err({ _tag: 'InvalidUserData', issues: validationResult.error })
  }

  const userData = validationResult.value

  try {
    // ユーザーの存在確認
    const existingUser = await prisma.user.findUnique({
      where: { id },
    })

    if (!existingUser) {
      return err({ _tag: 'UserNotFound', id })
    }

    // メールアドレスの重複チェック（変更がある場合）
    if (userData.email && userData.email !== existingUser.email) {
      const duplicateUser = await prisma.user.findUnique({
        where: { email: userData.email },
      })

      if (duplicateUser) {
        return err({ _tag: 'UserAlreadyExists', email: userData.email })
      }
    }

    // ユーザー更新
    await prisma.user.update({
      where: { id },
      data: userData,
    })

    return ok({ id })
  } catch (error) {
    return err(handlePrismaError(error))
  }
}

/**
 * ユーザー削除サービス
 */
export const deleteUser = async (id: string): Promise<Result<void, AppError>> => {
  try {
    const user = await prisma.user.findUnique({
      where: { id },
    })

    if (!user) {
      return err({ _tag: 'UserNotFound', id })
    }

    await prisma.user.delete({
      where: { id },
    })

    return ok(undefined)
  } catch (error) {
    return err(handlePrismaError(error))
  }
}
```

## 投稿操作の実装

```typescript
// services/postService.ts
import { Result, ok, err } from 'neverthrow'
import { prisma, handlePrismaError } from '../lib/prisma'
import type { PostError, DatabaseError, AppError } from '../types/errors'

/**
 * 投稿作成サービス
 */
export const createPost = async (
  authorId: string,
  data: { title: string; content?: string },
): Promise<Result<{ id: string }, AppError>> => {
  try {
    // 著者の存在確認
    const author = await prisma.user.findUnique({
      where: { id: authorId },
    })

    if (!author) {
      return err({ _tag: 'UserNotFound', id: authorId })
    }

    // 投稿作成
    const post = await prisma.post.create({
      data: {
        title: data.title,
        content: data.content,
        authorId,
      },
    })

    return ok({ id: post.id })
  } catch (error) {
    return err(handlePrismaError(error))
  }
}

/**
 * 投稿取得サービス
 */
export const getPostById = async (
  id: string,
): Promise<
  Result<
    {
      id: string
      title: string
      content: string | null
      published: boolean
      authorId: string
    },
    AppError
  >
> => {
  try {
    const post = await prisma.post.findUnique({
      where: { id },
    })

    if (!post) {
      return err({ _tag: 'PostNotFound', id })
    }

    return ok(post)
  } catch (error) {
    return err(handlePrismaError(error))
  }
}

/**
 * 投稿更新サービス（権限チェック付き）
 */
export const updatePost = async (
  postId: string,
  userId: string,
  data: { title?: string; content?: string; published?: boolean },
): Promise<Result<{ id: string }, AppError>> => {
  try {
    const post = await prisma.post.findUnique({
      where: { id: postId },
    })

    if (!post) {
      return err({ _tag: 'PostNotFound', id: postId })
    }

    // 権限チェック
    if (post.authorId !== userId) {
      return err({ _tag: 'Unauthorized', userId, postId })
    }

    // 投稿更新
    await prisma.post.update({
      where: { id: postId },
      data,
    })

    return ok({ id: postId })
  } catch (error) {
    return err(handlePrismaError(error))
  }
}
```

## トランザクション処理の実装

### 複数操作の原子性保証

```typescript
// services/transactionService.ts
import { Result, ok, err } from 'neverthrow'
import { prisma, handlePrismaError } from '../lib/prisma'
import type { DatabaseError } from '../types/errors'

/**
 * トランザクション内で複数の操作を実行
 */
export const executeTransaction = async <T>(
  operations: () => Promise<T>,
): Promise<Result<T, DatabaseError>> => {
  try {
    const result = await prisma.$transaction(operations)
    return ok(result)
  } catch (error) {
    return err(handlePrismaError(error))
  }
}

/**
 * ユーザーと投稿を同時に作成する例
 */
export const createUserWithPost = async (
  userData: { email: string; name: string },
  postData: { title: string; content?: string },
): Promise<Result<{ userId: string; postId: string }, DatabaseError>> => {
  return executeTransaction(async () => {
    const user = await prisma.user.create({
      data: userData,
    })

    const post = await prisma.post.create({
      data: {
        ...postData,
        authorId: user.id,
      },
    })

    return { userId: user.id, postId: post.id }
  })
}
```

## アプリケーション層の実装

### コントローラーの実装

```typescript
// controllers/userController.ts
import { Request, Response } from 'express'
import { Result } from 'neverthrow'
import * as userService from '../services/userService'
import type { AppError } from '../types/errors'

/**
 * エラーレスポンスの生成
 */
const createErrorResponse = (error: AppError): { status: number; message: string } => {
  switch (error._tag) {
    case 'UserNotFound':
      return { status: 404, message: `ユーザーが見つかりません: ${error.id}` }
    case 'UserAlreadyExists':
      return { status: 409, message: `メールアドレスが既に使用されています: ${error.email}` }
    case 'InvalidUserData':
      return { status: 400, message: '入力データが無効です' }
    case 'ConnectionError':
    case 'QueryError':
    case 'TransactionError':
      return { status: 500, message: 'データベースエラーが発生しました' }
    default:
      return { status: 500, message: '予期しないエラーが発生しました' }
  }
}

/**
 * ユーザー作成コントローラー
 */
export const createUser = async (req: Request, res: Response): Promise<void> => {
  const result = await userService.createUser(req.body)

  result
    .map((user) => {
      res.status(201).json({
        success: true,
        data: user,
      })
    })
    .mapErr((error) => {
      const { status, message } = createErrorResponse(error)
      res.status(status).json({
        success: false,
        error: message,
      })
    })
}

/**
 * ユーザー取得コントローラー
 */
export const getUser = async (req: Request, res: Response): Promise<void> => {
  const { id } = req.params
  const result = await userService.getUserById(id)

  result
    .map((user) => {
      res.status(200).json({
        success: true,
        data: user,
      })
    })
    .mapErr((error) => {
      const { status, message } = createErrorResponse(error)
      res.status(status).json({
        success: false,
        error: message,
      })
    })
}

/**
 * ユーザー更新コントローラー
 */
export const updateUser = async (req: Request, res: Response): Promise<void> => {
  const { id } = req.params
  const result = await userService.updateUser(id, req.body)

  result
    .map((user) => {
      res.status(200).json({
        success: true,
        data: user,
      })
    })
    .mapErr((error) => {
      const { status, message } = createErrorResponse(error)
      res.status(status).json({
        success: false,
        error: message,
      })
    })
}
```

## テストの実装

### 関数型プログラミングのテスト

```typescript
// tests/userService.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { PrismaClient } from '@prisma/client'
import * as userService from '../services/userService'
import { ok, err } from 'neverthrow'

const prisma = new PrismaClient()

describe('UserService', () => {
  beforeEach(async () => {
    await prisma.user.deleteMany()
  })

  afterEach(async () => {
    await prisma.user.deleteMany()
  })

  describe('createUser', () => {
    it('有効なデータでユーザーを作成できる', async () => {
      const userData = {
        email: 'test@example.com',
        name: 'Test User',
      }

      const result = await userService.createUser(userData)

      expect(result.isOk()).toBe(true)
      if (result.isOk()) {
        expect(result.value).toHaveProperty('id')
      }
    })

    it('無効なメールアドレスでエラーを返す', async () => {
      const userData = {
        email: 'invalid-email',
        name: 'Test User',
      }

      const result = await userService.createUser(userData)

      expect(result.isErr()).toBe(true)
      if (result.isErr()) {
        expect(result.error._tag).toBe('InvalidUserData')
      }
    })

    it('重複するメールアドレスでエラーを返す', async () => {
      const userData = {
        email: 'test@example.com',
        name: 'Test User',
      }

      // 最初のユーザーを作成
      await userService.createUser(userData)

      // 同じメールアドレスで再度作成
      const result = await userService.createUser(userData)

      expect(result.isErr()).toBe(true)
      if (result.isErr()) {
        expect(result.error._tag).toBe('UserAlreadyExists')
      }
    })
  })

  describe('getUserById', () => {
    it('存在するユーザーを取得できる', async () => {
      const userData = {
        email: 'test@example.com',
        name: 'Test User',
      }

      const createResult = await userService.createUser(userData)
      expect(createResult.isOk()).toBe(true)

      if (createResult.isOk()) {
        const userId = createResult.value.id
        const getResult = await userService.getUserById(userId)

        expect(getResult.isOk()).toBe(true)
        if (getResult.isOk()) {
          expect(getResult.value.email).toBe(userData.email)
          expect(getResult.value.name).toBe(userData.name)
        }
      }
    })

    it('存在しないユーザーIDでエラーを返す', async () => {
      const result = await userService.getUserById('non-existent-id')

      expect(result.isErr()).toBe(true)
      if (result.isErr()) {
        expect(result.error._tag).toBe('UserNotFound')
      }
    })
  })
})
```

## 実践的な応用例

### 複雑なビジネスロジックの実装

```typescript
// services/complexUserService.ts
import { Result, ok, err } from 'neverthrow'
import { prisma, handlePrismaError } from '../lib/prisma'
import * as userService from './userService'
import * as postService from './postService'
import type { AppError } from '../types/errors'

/**
 * ユーザーとその投稿を一括で取得
 */
export const getUserWithPosts = async (
  userId: string,
): Promise<
  Result<
    {
      user: { id: string; email: string; name: string | null }
      posts: Array<{ id: string; title: string; published: boolean }>
    },
    AppError
  >
> => {
  try {
    const [userResult, posts] = await Promise.all([
      userService.getUserById(userId),
      prisma.post.findMany({
        where: { authorId: userId },
        select: { id: true, title: true, published: true },
      }),
    ])

    return userResult.map((user) => ({
      user,
      posts,
    }))
  } catch (error) {
    return err(handlePrismaError(error))
  }
}

/**
 * ユーザーの統計情報を取得
 */
export const getUserStats = async (
  userId: string,
): Promise<
  Result<
    {
      totalPosts: number
      publishedPosts: number
      draftPosts: number
    },
    AppError
  >
> => {
  try {
    const stats = await prisma.post.groupBy({
      by: ['published'],
      where: { authorId: userId },
      _count: { id: true },
    })

    const totalPosts = stats.reduce((sum, stat) => sum + stat._count.id, 0)
    const publishedPosts = stats.find((stat) => stat.published)?._count.id ?? 0
    const draftPosts = totalPosts - publishedPosts

    return ok({
      totalPosts,
      publishedPosts,
      draftPosts,
    })
  } catch (error) {
    return err(handlePrismaError(error))
  }
}
```

## まとめ

本記事では、TypeScriptでneverthrowとPrismaを組み合わせた実践的な関数型プログラミングについて詳しく解説しました。以下の重要な概念を学びました：

### 学んだポイント

1. **型安全なエラーハンドリング**: Result型を使うことで、例外を使わずにエラーを安全に処理できます
2. **副作用の制御**: データベース操作などの副作用を適切に境界に隔離できます
3. **バリデーションの統合**: ZodとResult型を組み合わせて、型安全なバリデーションを実現できます
4. **トランザクション処理**: 複数の操作を原子性を保って実行できます
5. **テスト容易性**: 純粋関数とResult型により、テストが書きやすくなります

### 実践への応用

これらの概念は、以下のような場面で応用できます：

- **マイクロサービス間の通信**: API呼び出しのエラーハンドリング
- **ファイル操作**: ファイルI/Oの安全な処理
- **外部API連携**: サードパーティAPIとの通信
- **バッチ処理**: 大量データの安全な処理
- **リアルタイム処理**: WebSocketなどの非同期通信

### neverthrowの利点

[neverthrow](https://www.npmjs.com/package/neverthrow)を使うことで、以下のメリットが得られます：

- **型安全性**: TypeScriptの型システムを活用した安全なエラーハンドリング
- **関数型**: メソッドチェーンによる宣言的な処理
- **例外禁止**: throwを使わずにエラーを表現
- **テスト容易性**: エラーケースのテストが簡単
- **保守性**: エラーハンドリングの漏れを防ぐ

関数型プログラミングの原則を理解し、適切なツールを選択することで、保守性が高く、バグの少ないコードを書くことができます。TypeScriptの型システムと組み合わせることで、さらに安全で信頼性の高いアプリケーション開発が可能になります。

いかがでしたか？neverthrowとPrismaを組み合わせた関数型プログラミングの魅力を感じていただけたでしょうか。次回は、より高度な関数型プログラミングのテクニックや、他のライブラリとの組み合わせについても詳しく解説していきたいと思います。
