---
date: 2025-08-30
title: TypeScriptで学ぶ現実世界のアルゴリズム：交通、経済、自然現象の数値モデル化
description: 交通渋滞、経済循環、生態系の変化など、身近な現象をTypeScriptのアルゴリズムで表現する方法を解説。ライブラリなしで実装できる数値シミュレーションの実践例。
tags:
    - typescript
    - algorithm
    - simulation
    - modeling
    - mathematics
    - real-world
    - data-structures
prev:
    text: "Redis完全ガイド：高速データベースの使い方と実用事例"
    link: "/posts/2025/08/29"
next:
    text: "TypeScriptで学ぶWebスクレイピング：実装からベストプラクティスまで完全ガイド"
    link: "/posts/2025/08/31"
---

# TypeScriptで学ぶ現実世界のアルゴリズム：交通、経済、自然現象の数値モデル化

現実世界の複雑な現象をアルゴリズムで表現することは、プログラミングの理解を深める最良の方法の一つです。この記事では、交通渋滞、経済循環、生態系の変化など、身近な現象をTypeScriptで数値モデル化する方法を解説します。

## 交通渋滞のシミュレーション

### セルラーオートマトンモデル

交通渋滞を単純化したセルラーオートマトンで表現してみましょう。

```typescript
type Cell = {
  readonly hasCar: boolean;
  readonly speed: number;
  readonly maxSpeed: number;
};

type Road = readonly Cell[];

// 交通ルールの実装
const updateTraffic = (road: Road): Road => {
  return road.map((cell, index) => {
    if (!cell.hasCar) return cell;
    
    // 前方の車との距離を計算
    const distanceToNext = findDistanceToNextCar(road, index);
    
    // 速度を更新（安全距離を保つ）
    const newSpeed = Math.min(
      cell.speed + 1, // 加速
      cell.maxSpeed,  // 最高速度
      distanceToNext - 1 // 安全距離
    );
    
    // 減速（ランダム性を追加）
    const finalSpeed = Math.random() < 0.1 
      ? Math.max(0, newSpeed - 1) 
      : newSpeed;
    
    return {
      ...cell,
      speed: finalSpeed
    };
  });
};

// 車の移動
const moveCars = (road: Road): Road => {
  const newRoad = road.map(() => ({ hasCar: false, speed: 0, maxSpeed: 5 }));
  
  road.forEach((cell, index) => {
    if (cell.hasCar && cell.speed > 0) {
      const newPosition = (index + cell.speed) % road.length;
      newRoad[newPosition] = {
        hasCar: true,
        speed: cell.speed,
        maxSpeed: cell.maxSpeed
      };
    }
  });
  
  return newRoad;
};

// 前方の車との距離を計算
const findDistanceToNextCar = (road: Road, currentIndex: number): number => {
  for (let i = 1; i <= road.length; i++) {
    const checkIndex = (currentIndex + i) % road.length;
    if (road[checkIndex].hasCar) {
      return i;
    }
  }
  return road.length;
};

// シミュレーション実行
const simulateTraffic = (roadLength: number, carCount: number, steps: number): readonly Road[] => {
  // 初期状態の生成
  let road: Road = Array.from({ length: roadLength }, (_, index) => ({
    hasCar: index < carCount,
    speed: 0,
    maxSpeed: 5
  }));
  
  const history: Road[] = [road];
  
  for (let step = 0; step < steps; step++) {
    road = moveCars(updateTraffic(road));
    history.push(road);
  }
  
  return history;
};

// 渋滞の分析
const analyzeTraffic = (history: readonly Road[]): {
  readonly averageSpeed: number;
  readonly congestionLevel: number;
  readonly flowRate: number;
} => {
  const lastRoad = history[history.length - 1];
  const cars = lastRoad.filter(cell => cell.hasCar);
  
  const averageSpeed = cars.length > 0 
    ? cars.reduce((sum, car) => sum + car.speed, 0) / cars.length 
    : 0;
  
  const congestionLevel = cars.length / lastRoad.length;
  const flowRate = averageSpeed * congestionLevel;
  
  return { averageSpeed, congestionLevel, flowRate };
};
```

## 経済循環のモデル

### 単純な経済モデル

経済の基本的な循環を表現するモデルを作成します。

```typescript
type EconomicAgent = {
  readonly id: string;
  readonly money: number;
  readonly goods: number;
  readonly consumptionRate: number;
  readonly productionRate: number;
};

type Economy = {
  readonly agents: readonly EconomicAgent[];
  readonly totalMoney: number;
  readonly totalGoods: number;
  readonly inflation: number;
};

// 経済取引の実行
const executeTransaction = (
  buyer: EconomicAgent,
  seller: EconomicAgent,
  price: number,
  quantity: number
): readonly [EconomicAgent, EconomicAgent] => {
  if (buyer.money < price * quantity || seller.goods < quantity) {
    return [buyer, seller];
  }
  
  const newBuyer: EconomicAgent = {
    ...buyer,
    money: buyer.money - price * quantity,
    goods: buyer.goods + quantity
  };
  
  const newSeller: EconomicAgent = {
    ...seller,
    money: seller.money + price * quantity,
    goods: seller.goods - quantity
  };
  
  return [newBuyer, newSeller];
};

// 経済サイクルの更新
const updateEconomy = (economy: Economy): Economy => {
  let newAgents = economy.agents.map(agent => {
    // 生産活動
    const production = agent.productionRate * (1 + Math.random() * 0.2);
    
    // 消費活動
    const consumption = Math.min(
      agent.consumptionRate * agent.goods,
      agent.goods
    );
    
    return {
      ...agent,
      goods: agent.goods + production - consumption,
      money: agent.money * (1 - economy.inflation * 0.01)
    };
  });
  
  // ランダムな取引を実行
  for (let i = 0; i < newAgents.length * 2; i++) {
    const buyerIndex = Math.floor(Math.random() * newAgents.length);
    const sellerIndex = Math.floor(Math.random() * newAgents.length);
    
    if (buyerIndex !== sellerIndex) {
      const buyer = newAgents[buyerIndex];
      const seller = newAgents[sellerIndex];
      const price = 10 + Math.random() * 20;
      const quantity = Math.random() * 5;
      
      const [newBuyer, newSeller] = executeTransaction(buyer, seller, price, quantity);
      newAgents[buyerIndex] = newBuyer;
      newAgents[sellerIndex] = newSeller;
    }
  }
  
  const totalMoney = newAgents.reduce((sum, agent) => sum + agent.money, 0);
  const totalGoods = newAgents.reduce((sum, agent) => sum + agent.goods, 0);
  
  // インフレーションの計算
  const inflation = Math.max(0, (economy.totalMoney - totalMoney) / economy.totalMoney);
  
  return {
    agents: newAgents,
    totalMoney,
    totalGoods,
    inflation
  };
};

// 経済シミュレーション
const simulateEconomy = (
  agentCount: number,
  initialMoney: number,
  steps: number
): readonly Economy[] => {
  const initialAgents: EconomicAgent[] = Array.from({ length: agentCount }, (_, i) => ({
    id: `agent-${i}`,
    money: initialMoney,
    goods: 10,
    consumptionRate: 0.1 + Math.random() * 0.2,
    productionRate: 0.05 + Math.random() * 0.15
  }));
  
  let economy: Economy = {
    agents: initialAgents,
    totalMoney: agentCount * initialMoney,
    totalGoods: agentCount * 10,
    inflation: 0
  };
  
  const history: Economy[] = [economy];
  
  for (let step = 0; step < steps; step++) {
    economy = updateEconomy(economy);
    history.push(economy);
  }
  
  return history;
};
```

## 生態系の捕食者-被食者モデル

### ロトカ・ヴォルテラ方程式

生態系の基本的な相互作用を表現する数値モデルです。

```typescript
type Ecosystem = {
  readonly prey: number;
  readonly predator: number;
  readonly time: number;
};

type EcosystemParams = {
  readonly preyGrowthRate: number;
  readonly preyDeathRate: number;
  readonly predatorGrowthRate: number;
  readonly predatorDeathRate: number;
};

// ロトカ・ヴォルテラ方程式の実装
const updateEcosystem = (
  ecosystem: Ecosystem,
  params: EcosystemParams,
  deltaTime: number
): Ecosystem => {
  const { prey, predator, time } = ecosystem;
  const { preyGrowthRate, preyDeathRate, predatorGrowthRate, predatorDeathRate } = params;
  
  // 被食者の変化率
  const preyChange = preyGrowthRate * prey - preyDeathRate * prey * predator;
  
  // 捕食者の変化率
  const predatorChange = predatorGrowthRate * prey * predator - predatorDeathRate * predator;
  
  const newPrey = Math.max(0, prey + preyChange * deltaTime);
  const newPredator = Math.max(0, predator + predatorChange * deltaTime);
  
  return {
    prey: newPrey,
    predator: newPredator,
    time: time + deltaTime
  };
};

// 生態系シミュレーション
const simulateEcosystem = (
  initialPrey: number,
  initialPredator: number,
  params: EcosystemParams,
  duration: number,
  deltaTime: number
): readonly Ecosystem[] => {
  let ecosystem: Ecosystem = {
    prey: initialPrey,
    predator: initialPredator,
    time: 0
  };
  
  const history: Ecosystem[] = [ecosystem];
  const steps = Math.floor(duration / deltaTime);
  
  for (let step = 0; step < steps; step++) {
    ecosystem = updateEcosystem(ecosystem, params, deltaTime);
    history.push(ecosystem);
  }
  
  return history;
};

// 生態系の安定性分析
const analyzeEcosystem = (history: readonly Ecosystem[]): {
  readonly isStable: boolean;
  readonly averagePrey: number;
  readonly averagePredator: number;
  readonly cyclePeriod: number | null;
} => {
  const recentHistory = history.slice(-100);
  const preyValues = recentHistory.map(e => e.prey);
  const predatorValues = recentHistory.map(e => e.predator);
  
  const averagePrey = preyValues.reduce((sum, value) => sum + value, 0) / preyValues.length;
  const averagePredator = predatorValues.reduce((sum, value) => sum + value, 0) / predatorValues.length;
  
  // 周期性の検出（簡易版）
  const cyclePeriod = detectCycle(preyValues);
  
  // 安定性の判定
  const preyVariance = calculateVariance(preyValues);
  const predatorVariance = calculateVariance(predatorValues);
  const isStable = preyVariance < 100 && predatorVariance < 100;
  
  return { isStable, averagePrey, averagePredator, cyclePeriod };
};

// 分散の計算
const calculateVariance = (values: readonly number[]): number => {
  const mean = values.reduce((sum, value) => sum + value, 0) / values.length;
  return values.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / values.length;
};

// 周期性の検出（簡易版）
const detectCycle = (values: readonly number[]): number | null => {
  if (values.length < 20) return null;
  
  // 自己相関を使用した周期性検出
  for (let lag = 5; lag < values.length / 2; lag++) {
    let correlation = 0;
    let count = 0;
    
    for (let i = 0; i < values.length - lag; i++) {
      correlation += values[i] * values[i + lag];
      count++;
    }
    
    if (count > 0) {
      correlation /= count;
      if (correlation > 0.7) {
        return lag;
      }
    }
  }
  
  return null;
};
```

## 天気予報の簡易モデル

### マルコフ連鎖による天気予報

```typescript
type Weather = 'sunny' | 'cloudy' | 'rainy';

type WeatherTransition = {
  readonly from: Weather;
  readonly to: Weather;
  readonly probability: number;
};

type WeatherModel = {
  readonly transitions: readonly WeatherTransition[];
  readonly currentWeather: Weather;
};

// 天気遷移の確率行列
const createWeatherModel = (): WeatherModel => {
  const transitions: WeatherTransition[] = [
    { from: 'sunny', to: 'sunny', probability: 0.7 },
    { from: 'sunny', to: 'cloudy', probability: 0.2 },
    { from: 'sunny', to: 'rainy', probability: 0.1 },
    { from: 'cloudy', to: 'sunny', probability: 0.3 },
    { from: 'cloudy', to: 'cloudy', probability: 0.5 },
    { from: 'cloudy', to: 'rainy', probability: 0.2 },
    { from: 'rainy', to: 'sunny', probability: 0.2 },
    { from: 'rainy', to: 'cloudy', probability: 0.3 },
    { from: 'rainy', to: 'rainy', probability: 0.5 }
  ];
  
  return {
    transitions,
    currentWeather: 'sunny'
  };
};

// 次の天気を予測
const predictNextWeather = (model: WeatherModel): Weather => {
  const relevantTransitions = model.transitions.filter(
    t => t.from === model.currentWeather
  );
  
  const random = Math.random();
  let cumulativeProbability = 0;
  
  for (const transition of relevantTransitions) {
    cumulativeProbability += transition.probability;
    if (random <= cumulativeProbability) {
      return transition.to;
    }
  }
  
  return model.currentWeather; // フォールバック
};

// 天気予報シミュレーション
const simulateWeather = (
  model: WeatherModel,
  days: number
): readonly Weather[] => {
  const forecast: Weather[] = [model.currentWeather];
  let currentWeather = model.currentWeather;
  
  for (let day = 1; day < days; day++) {
    currentWeather = predictNextWeather({ ...model, currentWeather });
    forecast.push(currentWeather);
  }
  
  return forecast;
};

// 天気統計の分析
const analyzeWeather = (forecast: readonly Weather[]): {
  readonly sunnyDays: number;
  readonly cloudyDays: number;
  readonly rainyDays: number;
  readonly longestStreak: number;
} => {
  const counts = {
    sunny: forecast.filter(w => w === 'sunny').length,
    cloudy: forecast.filter(w => w === 'cloudy').length,
    rainy: forecast.filter(w => w === 'rainy').length
  };
  
  // 最長連続日数の計算
  let currentStreak = 1;
  let longestStreak = 1;
  
  for (let i = 1; i < forecast.length; i++) {
    if (forecast[i] === forecast[i - 1]) {
      currentStreak++;
      longestStreak = Math.max(longestStreak, currentStreak);
    } else {
      currentStreak = 1;
    }
  }
  
  return {
    sunnyDays: counts.sunny,
    cloudyDays: counts.cloudy,
    rainyDays: counts.rainy,
    longestStreak
  };
};
```

## 実装例と実行結果

### 交通シミュレーションの実行

```typescript
// 交通シミュレーションの実行例
const trafficResult = simulateTraffic(50, 10, 100);
const trafficAnalysis = analyzeTraffic(trafficResult);

console.log('交通分析結果:', {
  平均速度: trafficAnalysis.averageSpeed.toFixed(2),
  混雑度: (trafficAnalysis.congestionLevel * 100).toFixed(1) + '%',
  交通流量: trafficAnalysis.flowRate.toFixed(2)
});
```

### 経済シミュレーションの実行

```typescript
// 経済シミュレーションの実行例
const economyResult = simulateEconomy(20, 1000, 50);
const finalEconomy = economyResult[economyResult.length - 1];

console.log('経済分析結果:', {
  総貨幣量: finalEconomy.totalMoney.toFixed(0),
  総財貨量: finalEconomy.totalGoods.toFixed(1),
  インフレ率: (finalEconomy.inflation * 100).toFixed(2) + '%'
});
```

### 生態系シミュレーションの実行

```typescript
// 生態系シミュレーションの実行例
const ecosystemParams: EcosystemParams = {
  preyGrowthRate: 0.1,
  preyDeathRate: 0.01,
  predatorGrowthRate: 0.001,
  predatorDeathRate: 0.05
};

const ecosystemResult = simulateEcosystem(100, 10, ecosystemParams, 100, 0.1);
const ecosystemAnalysis = analyzeEcosystem(ecosystemResult);

console.log('生態系分析結果:', {
  安定性: ecosystemAnalysis.isStable ? '安定' : '不安定',
  平均被食者数: ecosystemAnalysis.averagePrey.toFixed(1),
  平均捕食者数: ecosystemAnalysis.averagePredator.toFixed(1),
  周期: ecosystemAnalysis.cyclePeriod || '検出されません'
});
```

## まとめ

この記事では、現実世界の複雑な現象をTypeScriptのアルゴリズムで表現する方法を紹介しました：

- **交通渋滞**: セルラーオートマトンによる車の移動モデル
- **経済循環**: エージェントベースの取引シミュレーション
- **生態系**: ロトカ・ヴォルテラ方程式による捕食者-被食者モデル
- **天気予報**: マルコフ連鎖による確率的予測

これらのモデルは現実の複雑さを単純化していますが、基本的な原理を理解し、プログラミングの応用力を高めるのに役立ちます。実際の応用では、より詳細なパラメータや外部ライブラリを使用することで、より正確なシミュレーションが可能になります。
