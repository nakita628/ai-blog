---
date: 2025-08-30
title: TypeScriptで学ぶ現実世界のアルゴリズム：交通、経済、自然現象の数値モデル化
description: 交通渋滞、経済循環、生態系の変化など、身近な現象をTypeScriptのアルゴリズムで表現する方法を解説。ライブラリなしで実装できる数値シミュレーションの実践例。
tags:
  - typescript
  - algorithm
  - simulation
  - modeling
  - mathematics
  - real-world
  - data-structures
prev:
  text: 'Redis完全ガイド：高速データベースの使い方と実用事例'
  link: '/posts/2025/08/29'
next:
  text: 'TypeScriptで学ぶWebスクレイピング：実装からベストプラクティスまで完全ガイド'
  link: '/posts/2025/08/31'
---

# TypeScriptで学ぶ現実世界のアルゴリズム：交通、経済、自然現象の数値モデル化

現実世界の複雑な現象をアルゴリズムで表現することは、プログラミングの理解を深める最良の方法の一つです。この記事では、交通渋滞、経済循環、生態系の変化など、身近な現象をTypeScriptで数値モデル化する方法を解説します。

## 交通渋滞のシミュレーション

### セルラーオートマトンモデル

交通渋滞を単純化したセルラーオートマトンで表現してみましょう。

```typescript
type Cell = {
  readonly hasCar: boolean
  readonly speed: number
  readonly maxSpeed: number
}

type Road = readonly Cell[]

// 交通ルールの実装
const updateTraffic = (road: Road): Road => {
  return road.map((cell, index) => {
    if (!cell.hasCar) return cell

    // 前方の車との距離を計算
    const distanceToNext = findDistanceToNextCar(road, index)

    // 速度を更新（安全距離を保つ）
    const newSpeed = Math.min(
      cell.speed + 1, // 加速
      cell.maxSpeed, // 最高速度
      distanceToNext - 1, // 安全距離
    )

    // 減速（ランダム性を追加）
    const finalSpeed = Math.random() < 0.1 ? Math.max(0, newSpeed - 1) : newSpeed

    return {
      ...cell,
      speed: finalSpeed,
    }
  })
}

// 車の移動
const moveCars = (road: Road): Road => {
  const newRoad = road.map(() => ({ hasCar: false, speed: 0, maxSpeed: 5 }))

  road.forEach((cell, index) => {
    if (cell.hasCar && cell.speed > 0) {
      const newPosition = (index + cell.speed) % road.length
      newRoad[newPosition] = {
        hasCar: true,
        speed: cell.speed,
        maxSpeed: cell.maxSpeed,
      }
    }
  })

  return newRoad
}

// 前方の車との距離を計算
const findDistanceToNextCar = (road: Road, currentIndex: number): number => {
  for (let i = 1; i <= road.length; i++) {
    const checkIndex = (currentIndex + i) % road.length
    if (road[checkIndex].hasCar) {
      return i
    }
  }
  return road.length
}

// シミュレーション実行
const simulateTraffic = (roadLength: number, carCount: number, steps: number): readonly Road[] => {
  // 初期状態の生成
  let road: Road = Array.from({ length: roadLength }, (_, index) => ({
    hasCar: index < carCount,
    speed: 0,
    maxSpeed: 5,
  }))

  const history: Road[] = [road]

  for (let step = 0; step < steps; step++) {
    road = moveCars(updateTraffic(road))
    history.push(road)
  }

  return history
}

// 渋滞の分析
const analyzeTraffic = (
  history: readonly Road[],
): {
  readonly averageSpeed: number
  readonly congestionLevel: number
  readonly flowRate: number
} => {
  const lastRoad = history[history.length - 1]
  const cars = lastRoad.filter((cell) => cell.hasCar)

  const averageSpeed =
    cars.length > 0 ? cars.reduce((sum, car) => sum + car.speed, 0) / cars.length : 0

  const congestionLevel = cars.length / lastRoad.length
  const flowRate = averageSpeed * congestionLevel

  return { averageSpeed, congestionLevel, flowRate }
}
```

## 経済循環のモデル

### 単純な経済モデル

経済の基本的な循環を表現するモデルを作成します。

```typescript
type EconomicAgent = {
  readonly id: string
  readonly money: number
  readonly goods: number
  readonly consumptionRate: number
  readonly productionRate: number
}

type Economy = {
  readonly agents: readonly EconomicAgent[]
  readonly totalMoney: number
  readonly totalGoods: number
  readonly inflation: number
}

// 経済取引の実行
const executeTransaction = (
  buyer: EconomicAgent,
  seller: EconomicAgent,
  price: number,
  quantity: number,
): readonly [EconomicAgent, EconomicAgent] => {
  if (buyer.money < price * quantity || seller.goods < quantity) {
    return [buyer, seller]
  }

  const newBuyer: EconomicAgent = {
    ...buyer,
    money: buyer.money - price * quantity,
    goods: buyer.goods + quantity,
  }

  const newSeller: EconomicAgent = {
    ...seller,
    money: seller.money + price * quantity,
    goods: seller.goods - quantity,
  }

  return [newBuyer, newSeller]
}

// 経済サイクルの更新
const updateEconomy = (economy: Economy): Economy => {
  let newAgents = economy.agents.map((agent) => {
    // 生産活動
    const production = agent.productionRate * (1 + Math.random() * 0.2)

    // 消費活動
    const consumption = Math.min(agent.consumptionRate * agent.goods, agent.goods)

    return {
      ...agent,
      goods: agent.goods + production - consumption,
      money: agent.money * (1 - economy.inflation * 0.01),
    }
  })

  // ランダムな取引を実行
  for (let i = 0; i < newAgents.length * 2; i++) {
    const buyerIndex = Math.floor(Math.random() * newAgents.length)
    const sellerIndex = Math.floor(Math.random() * newAgents.length)

    if (buyerIndex !== sellerIndex) {
      const buyer = newAgents[buyerIndex]
      const seller = newAgents[sellerIndex]
      const price = 10 + Math.random() * 20
      const quantity = Math.random() * 5

      const [newBuyer, newSeller] = executeTransaction(buyer, seller, price, quantity)
      newAgents[buyerIndex] = newBuyer
      newAgents[sellerIndex] = newSeller
    }
  }

  const totalMoney = newAgents.reduce((sum, agent) => sum + agent.money, 0)
  const totalGoods = newAgents.reduce((sum, agent) => sum + agent.goods, 0)

  // インフレーションの計算
  const inflation = Math.max(0, (economy.totalMoney - totalMoney) / economy.totalMoney)

  return {
    agents: newAgents,
    totalMoney,
    totalGoods,
    inflation,
  }
}

// 経済シミュレーション
const simulateEconomy = (
  agentCount: number,
  initialMoney: number,
  steps: number,
): readonly Economy[] => {
  const initialAgents: EconomicAgent[] = Array.from({ length: agentCount }, (_, i) => ({
    id: `agent-${i}`,
    money: initialMoney,
    goods: 10,
    consumptionRate: 0.1 + Math.random() * 0.2,
    productionRate: 0.05 + Math.random() * 0.15,
  }))

  let economy: Economy = {
    agents: initialAgents,
    totalMoney: agentCount * initialMoney,
    totalGoods: agentCount * 10,
    inflation: 0,
  }

  const history: Economy[] = [economy]

  for (let step = 0; step < steps; step++) {
    economy = updateEconomy(economy)
    history.push(economy)
  }

  return history
}
```

## 生態系の捕食者-被食者モデル

### ロトカ・ヴォルテラ方程式

生態系の基本的な相互作用を表現する数値モデルです。

```typescript
type Ecosystem = {
  readonly prey: number
  readonly predator: number
  readonly time: number
}

type EcosystemParams = {
  readonly preyGrowthRate: number
  readonly preyDeathRate: number
  readonly predatorGrowthRate: number
  readonly predatorDeathRate: number
}

// ロトカ・ヴォルテラ方程式の実装
const updateEcosystem = (
  ecosystem: Ecosystem,
  params: EcosystemParams,
  deltaTime: number,
): Ecosystem => {
  const { prey, predator, time } = ecosystem
  const { preyGrowthRate, preyDeathRate, predatorGrowthRate, predatorDeathRate } = params

  // 被食者の変化率
  const preyChange = preyGrowthRate * prey - preyDeathRate * prey * predator

  // 捕食者の変化率
  const predatorChange = predatorGrowthRate * prey * predator - predatorDeathRate * predator

  const newPrey = Math.max(0, prey + preyChange * deltaTime)
  const newPredator = Math.max(0, predator + predatorChange * deltaTime)

  return {
    prey: newPrey,
    predator: newPredator,
    time: time + deltaTime,
  }
}

// 生態系シミュレーション
const simulateEcosystem = (
  initialPrey: number,
  initialPredator: number,
  params: EcosystemParams,
  duration: number,
  deltaTime: number,
): readonly Ecosystem[] => {
  let ecosystem: Ecosystem = {
    prey: initialPrey,
    predator: initialPredator,
    time: 0,
  }

  const history: Ecosystem[] = [ecosystem]
  const steps = Math.floor(duration / deltaTime)

  for (let step = 0; step < steps; step++) {
    ecosystem = updateEcosystem(ecosystem, params, deltaTime)
    history.push(ecosystem)
  }

  return history
}

// 生態系の安定性分析
const analyzeEcosystem = (
  history: readonly Ecosystem[],
): {
  readonly isStable: boolean
  readonly averagePrey: number
  readonly averagePredator: number
  readonly cyclePeriod: number | null
} => {
  const recentHistory = history.slice(-100)
  const preyValues = recentHistory.map((e) => e.prey)
  const predatorValues = recentHistory.map((e) => e.predator)

  const averagePrey = preyValues.reduce((sum, value) => sum + value, 0) / preyValues.length
  const averagePredator =
    predatorValues.reduce((sum, value) => sum + value, 0) / predatorValues.length

  // 周期性の検出（簡易版）
  const cyclePeriod = detectCycle(preyValues)

  // 安定性の判定
  const preyVariance = calculateVariance(preyValues)
  const predatorVariance = calculateVariance(predatorValues)
  const isStable = preyVariance < 100 && predatorVariance < 100

  return { isStable, averagePrey, averagePredator, cyclePeriod }
}

// 分散の計算
const calculateVariance = (values: readonly number[]): number => {
  const mean = values.reduce((sum, value) => sum + value, 0) / values.length
  return values.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / values.length
}

// 周期性の検出（簡易版）
const detectCycle = (values: readonly number[]): number | null => {
  if (values.length < 20) return null

  // 自己相関を使用した周期性検出
  for (let lag = 5; lag < values.length / 2; lag++) {
    let correlation = 0
    let count = 0

    for (let i = 0; i < values.length - lag; i++) {
      correlation += values[i] * values[i + lag]
      count++
    }

    if (count > 0) {
      correlation /= count
      if (correlation > 0.7) {
        return lag
      }
    }
  }

  return null
}
```

## 天気予報の簡易モデル

### マルコフ連鎖による天気予報

```typescript
type Weather = 'sunny' | 'cloudy' | 'rainy'

type WeatherTransition = {
  readonly from: Weather
  readonly to: Weather
  readonly probability: number
}

type WeatherModel = {
  readonly transitions: readonly WeatherTransition[]
  readonly currentWeather: Weather
}

// 天気遷移の確率行列
const createWeatherModel = (): WeatherModel => {
  const transitions: WeatherTransition[] = [
    { from: 'sunny', to: 'sunny', probability: 0.7 },
    { from: 'sunny', to: 'cloudy', probability: 0.2 },
    { from: 'sunny', to: 'rainy', probability: 0.1 },
    { from: 'cloudy', to: 'sunny', probability: 0.3 },
    { from: 'cloudy', to: 'cloudy', probability: 0.5 },
    { from: 'cloudy', to: 'rainy', probability: 0.2 },
    { from: 'rainy', to: 'sunny', probability: 0.2 },
    { from: 'rainy', to: 'cloudy', probability: 0.3 },
    { from: 'rainy', to: 'rainy', probability: 0.5 },
  ]

  return {
    transitions,
    currentWeather: 'sunny',
  }
}

// 次の天気を予測
const predictNextWeather = (model: WeatherModel): Weather => {
  const relevantTransitions = model.transitions.filter((t) => t.from === model.currentWeather)

  const random = Math.random()
  let cumulativeProbability = 0

  for (const transition of relevantTransitions) {
    cumulativeProbability += transition.probability
    if (random <= cumulativeProbability) {
      return transition.to
    }
  }

  return model.currentWeather // フォールバック
}

// 天気予報シミュレーション
const simulateWeather = (model: WeatherModel, days: number): readonly Weather[] => {
  const forecast: Weather[] = [model.currentWeather]
  let currentWeather = model.currentWeather

  for (let day = 1; day < days; day++) {
    currentWeather = predictNextWeather({ ...model, currentWeather })
    forecast.push(currentWeather)
  }

  return forecast
}

// 天気統計の分析
const analyzeWeather = (
  forecast: readonly Weather[],
): {
  readonly sunnyDays: number
  readonly cloudyDays: number
  readonly rainyDays: number
  readonly longestStreak: number
} => {
  const counts = {
    sunny: forecast.filter((w) => w === 'sunny').length,
    cloudy: forecast.filter((w) => w === 'cloudy').length,
    rainy: forecast.filter((w) => w === 'rainy').length,
  }

  // 最長連続日数の計算
  let currentStreak = 1
  let longestStreak = 1

  for (let i = 1; i < forecast.length; i++) {
    if (forecast[i] === forecast[i - 1]) {
      currentStreak++
      longestStreak = Math.max(longestStreak, currentStreak)
    } else {
      currentStreak = 1
    }
  }

  return {
    sunnyDays: counts.sunny,
    cloudyDays: counts.cloudy,
    rainyDays: counts.rainy,
    longestStreak,
  }
}
```

## 実装例と実行結果

### 交通シミュレーションの実行

```typescript
// 交通シミュレーションの実行例
const trafficResult = simulateTraffic(50, 10, 100)
const trafficAnalysis = analyzeTraffic(trafficResult)

console.log('交通分析結果:', {
  平均速度: trafficAnalysis.averageSpeed.toFixed(2),
  混雑度: (trafficAnalysis.congestionLevel * 100).toFixed(1) + '%',
  交通流量: trafficAnalysis.flowRate.toFixed(2),
})
```

### 経済シミュレーションの実行

```typescript
// 経済シミュレーションの実行例
const economyResult = simulateEconomy(20, 1000, 50)
const finalEconomy = economyResult[economyResult.length - 1]

console.log('経済分析結果:', {
  総貨幣量: finalEconomy.totalMoney.toFixed(0),
  総財貨量: finalEconomy.totalGoods.toFixed(1),
  インフレ率: (finalEconomy.inflation * 100).toFixed(2) + '%',
})
```

### 生態系シミュレーションの実行

```typescript
// 生態系シミュレーションの実行例
const ecosystemParams: EcosystemParams = {
  preyGrowthRate: 0.1,
  preyDeathRate: 0.01,
  predatorGrowthRate: 0.001,
  predatorDeathRate: 0.05,
}

const ecosystemResult = simulateEcosystem(100, 10, ecosystemParams, 100, 0.1)
const ecosystemAnalysis = analyzeEcosystem(ecosystemResult)

console.log('生態系分析結果:', {
  安定性: ecosystemAnalysis.isStable ? '安定' : '不安定',
  平均被食者数: ecosystemAnalysis.averagePrey.toFixed(1),
  平均捕食者数: ecosystemAnalysis.averagePredator.toFixed(1),
  周期: ecosystemAnalysis.cyclePeriod || '検出されません',
})
```

## まとめ

この記事では、現実世界の複雑な現象をTypeScriptのアルゴリズムで表現する方法を紹介しました：

- **交通渋滞**: セルラーオートマトンによる車の移動モデル
- **経済循環**: エージェントベースの取引シミュレーション
- **生態系**: ロトカ・ヴォルテラ方程式による捕食者-被食者モデル
- **天気予報**: マルコフ連鎖による確率的予測

これらのモデルは現実の複雑さを単純化していますが、基本的な原理を理解し、プログラミングの応用力を高めるのに役立ちます。実際の応用では、より詳細なパラメータや外部ライブラリを使用することで、より正確なシミュレーションが可能になります。
