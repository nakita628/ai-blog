---
date: 2025-08-27
title: Auth.js (NextAuth v5) 完全ガイド：Prisma連携とJWTセッション両方の実装パターン
description: Auth.js (NextAuth v5) のベストプラクティスを初心者向けに徹底解説。Prismaアダプタを使ったデータベースセッション管理とJWTセッション戦略の両方の実装例、セキュリティ設定、OAuth認証まで網羅。
tags:
    - auth-js
    - nextauth
    - next-js
    - prisma
    - authentication
    - jwt
    - oauth
    - typescript
prev:
    text: "Cloud Run完全入門：初心者でもわかるサーバーレスアプリ開発の始め方"
    link: "/posts/2025/08/26"
next: false
---

# Auth.js (NextAuth v5) 完全ガイド：Prisma連携とJWTセッション両方の実装パターン

Auth.js（旧NextAuth.js）は、Next.jsアプリケーションに認証機能を簡単に追加できる強力なライブラリだ。v5では大幅な改良が行われ、より柔軟で安全な認証システムを構築できるようになった。本記事では、初心者にもわかりやすくAuth.jsの基本概念から実装まで、Prisma連携とJWTセッション両方のパターンを詳しく解説する。

## Auth.js v5の基本概念と変更点

### NextAuth v4からの主な変更点

Auth.js v5（NextAuth v5）では、以下の重要な変更が行われた：

```mermaid
graph TB
    subgraph "v4 (旧版)"
        A[pages/api/auth/[...nextauth].js]
        B[getServerSession]
        C[NEXTAUTH_* 環境変数]
        D[withAuth ミドルウェア]
    end
    
    subgraph "v5 (新版)"
        E[auth.ts 設定ファイル]
        F[auth() 統一関数]
        G[AUTH_* 環境変数]
        H[export { auth as middleware }]
    end
    
    A --> E
    B --> F
    C --> G
    D --> H
    
    style E fill:#c8e6c9
    style F fill:#c8e6c9
    style G fill:#c8e6c9
    style H fill:#c8e6c9
```

**主な改善点**：
- **設定の一元化**: すべての設定を `auth.ts` に集約
- **API の統一**: `auth()` 関数ですべての認証処理を統一
- **環境変数の統一**: `AUTH_*` プレフィックスに統一
- **TypeScript サポート強化**: 型安全性の向上
- **App Router 完全対応**: Next.js 14+ の App Router に最適化

### 基本的なファイル構成

Auth.js v5の標準的なファイル構成は以下の通り：

```
project/
├── auth.ts                           # 認証設定（メイン）
├── middleware.ts                      # ルート保護
├── app/
│   └── api/
│       └── auth/
│           └── [...nextauth]/
│               └── route.ts           # API ルート
└── types/
    └── next-auth.d.ts                # 型定義拡張
```

### セッション戦略の選択

Auth.js v5では2つのセッション戦略から選択できる：

#### 1. Database Strategy（データベース戦略）
- セッション情報をデータベースに保存
- より安全だが、データベースアクセスが必要
- Prisma、Drizzle等のアダプタを使用

#### 2. JWT Strategy（JWT戦略）
- セッション情報をJWTトークンに保存
- データベース不要で高速
- 適切な実装が必要

```mermaid
graph LR
    subgraph "Database Strategy"
        A[ユーザーログイン] --> B[セッションをDBに保存]
        B --> C[セッションIDをクッキーに保存]
        C --> D[リクエスト時にDBから読み取り]
    end
    
    subgraph "JWT Strategy"
        E[ユーザーログイン] --> F[JWT トークン生成]
        F --> G[JWTをクッキーに保存]
        G --> H[リクエスト時にJWT検証]
    end
    
    style B fill:#e3f2fd
    style D fill:#e3f2fd
    style F fill:#fff3e0
    style H fill:#fff3e0
```

## Prismaアダプタを使ったデータベースセッション管理

Database Strategyを使用する場合、Prismaアダプタを使ってデータベースでセッション管理を行う方法を詳しく見てみよう。

### 必要なパッケージのインストール

```bash
# 基本パッケージ
npm install next-auth@beta @auth/prisma-adapter prisma @prisma/client

# 開発用パッケージ
npm install -D prisma
```

### Prismaスキーマの設定

Auth.js用のテーブルを定義する。以下は必要最小限のスキーマ：

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // または "mysql", "sqlite"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime? @map("email_verified")
  image         String?
  role          String    @default("user") // カスタムフィールド例
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  accounts Account[]
  sessions Session[]

  @@map("users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}
```

### Prismaクライアントの設定

```typescript
// lib/prisma.ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
```

### Auth.js設定（Prismaアダプタ使用）

```typescript
// auth.ts
import NextAuth, { type NextAuthConfig } from "next-auth"
import { PrismaAdapter } from "@auth/prisma-adapter"
import { prisma } from "@/lib/prisma"
import Google from "next-auth/providers/google"
import GitHub from "next-auth/providers/github"

export const authConfig = {
  // 本番環境では必須
  trustHost: true,
  
  // Prismaアダプタを使用してデータベース戦略を有効化
  adapter: PrismaAdapter(prisma),
  session: { strategy: "database" },
  
  providers: [
    Google({
      clientId: process.env.AUTH_GOOGLE_ID,
      clientSecret: process.env.AUTH_GOOGLE_SECRET,
    }),
    GitHub({
      clientId: process.env.AUTH_GITHUB_ID,
      clientSecret: process.env.AUTH_GITHUB_SECRET,
    }),
  ],

  callbacks: {
    // セッション情報をカスタマイズ
    session({ session, user }) {
      if (session.user) {
        session.user.id = user.id
        session.user.role = (user as any).role
      }
      return session
    },
    
    // ユーザー作成時の処理
    async signIn({ user, account, profile }) {
      // 必要に応じてユーザー作成時の処理を追加
      return true
    },
  },

  // カスタムページの設定（オプション）
  pages: {
    signIn: '/auth/signin',
    error: '/auth/error',
  },
} satisfies NextAuthConfig

export const { auth, handlers, signIn, signOut } = NextAuth(authConfig)
```

### 環境変数の設定

```env
# .env.local
# データベース接続
DATABASE_URL="postgresql://username:password@localhost:5432/myapp"

# Auth.js設定
AUTH_SECRET="your-secret-key-here" # npx auth secret で生成
AUTH_TRUST_HOST=true

# OAuth プロバイダ設定
AUTH_GOOGLE_ID="your-google-client-id"
AUTH_GOOGLE_SECRET="your-google-client-secret"
AUTH_GITHUB_ID="your-github-client-id"
AUTH_GITHUB_SECRET="your-github-client-secret"
```

### APIルートの設定

```typescript
// app/api/auth/[...nextauth]/route.ts
import { handlers } from "@/auth"

export const { GET, POST } = handlers
```

### ミドルウェアによるルート保護

```typescript
// middleware.ts
export { auth as middleware } from "@/auth"

export const config = {
  // 保護したいルートを指定
  matcher: [
    "/((?!api|_next/static|_next/image|favicon.ico).*)",
  ],
}
```

### 使用例：Server Componentでの認証チェック

```typescript
// app/dashboard/page.tsx
import { auth } from "@/auth"
import { redirect } from "next/navigation"

export default async function Dashboard() {
  const session = await auth()
  
  if (!session) {
    redirect("/auth/signin")
  }

  return (
    <div>
      <h1>ダッシュボード</h1>
      <p>こんにちは、{session.user?.name}さん</p>
      <p>あなたの役割: {session.user?.role}</p>
    </div>
  )
}
```

### 使用例：Client Componentでの認証チェック

```typescript
// app/profile/page.tsx
"use client"

import { useSession } from "next-auth/react"
import { SessionProvider } from "next-auth/react"

function ProfileContent() {
  const { data: session, status } = useSession()

  if (status === "loading") return <p>読み込み中...</p>
  if (status === "unauthenticated") return <p>ログインしてください</p>

  return (
    <div>
      <h1>プロフィール</h1>
      <p>名前: {session?.user?.name}</p>
      <p>メール: {session?.user?.email}</p>
    </div>
  )
}

export default function Profile() {
  return (
    <SessionProvider>
      <ProfileContent />
    </SessionProvider>
  )
}
```

### Prisma Studio でデータ確認

```bash
# データベースマイグレーション
npx prisma migrate dev --name init

# Prisma Studio起動（データベースの内容を視覚的に確認）
npx prisma studio
```

## JWTセッション戦略の実装

JWT（JSON Web Token）戦略は、データベースを使わずにセッション情報をトークンに保存する方法だ。高速でスケーラブルだが、適切な実装が必要になる。

### JWTセッション戦略のメリット・デメリット

#### メリット
- **高速**: データベースアクセス不要
- **スケーラブル**: サーバー間でセッション共有が容易
- **軽量**: データベース不要で運用が簡単
- **ステートレス**: サーバー側でセッション状態を保持しない

#### デメリット
- **セキュリティリスク**: トークンが漏洩すると危険
- **サイズ制限**: クッキーサイズの制限（通常4KB）
- **即座の無効化困難**: ログアウト時の即座無効化が難しい
- **情報更新の遅延**: ユーザー情報変更の反映に時間がかかる

```mermaid
graph TB
    subgraph "JWT Strategy の流れ"
        A[ユーザーログイン] --> B[JWT生成]
        B --> C[JWTにユーザー情報を埋め込み]
        C --> D[暗号化してクッキーに保存]
        D --> E[リクエスト時にJWT検証]
        E --> F[トークンからユーザー情報を取得]
    end
    
    subgraph "セキュリティ考慮点"
        G[適切な有効期限設定]
        H[強力な暗号化]
        I[機密情報の除外]
        J[定期的なトークン更新]
    end
    
    style G fill:#ffebee
    style H fill:#ffebee
    style I fill:#ffebee
    style J fill:#ffebee
```

### JWT戦略のAuth.js設定

```typescript
// auth.ts (JWT戦略版)
import NextAuth, { type NextAuthConfig } from "next-auth"
import Google from "next-auth/providers/google"
import GitHub from "next-auth/providers/github"
import Credentials from "next-auth/providers/credentials"
import bcrypt from "bcryptjs"

export const authConfig = {
  trustHost: true,
  
  // JWT戦略を明示的に指定
  session: { 
    strategy: "jwt",
    maxAge: 30 * 24 * 60 * 60, // 30日
  },
  
  providers: [
    Google,
    GitHub,
    Credentials({
      name: "credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          return null
        }

        // 実際の実装では、データベースからユーザーを検索
        const user = await getUserFromDatabase(credentials.email as string)
        
        if (!user) {
          return null
        }

        const isPasswordValid = await bcrypt.compare(
          credentials.password as string,
          user.hashedPassword
        )

        if (!isPasswordValid) {
          return null
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
        }
      }
    })
  ],

  callbacks: {
    // JWTにカスタム情報を追加
    jwt({ token, user, trigger, session }) {
      // 初回サインイン時にユーザー情報をJWTに追加
      if (user) {
        token.id = user.id
        token.role = (user as any).role
      }
      
      // セッション更新時の処理
      if (trigger === "update" && session) {
        token.name = session.user.name
        token.email = session.user.email
      }
      
      return token
    },
    
    // セッションオブジェクトをカスタマイズ
    session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string
        session.user.role = token.role as string
      }
      return session
    },
  },

  // JWT設定
  jwt: {
    // JWT の有効期限（デフォルトは30日）
    maxAge: 30 * 24 * 60 * 60,
  },
} satisfies NextAuthConfig

export const { auth, handlers, signIn, signOut } = NextAuth(authConfig)

// ダミー関数（実際の実装では適切なデータベースアクセスを行う）
async function getUserFromDatabase(email: string) {
  // データベースからユーザーを取得する実装
  // 例: Prismaを使用する場合
  // return await prisma.user.findUnique({ where: { email } })
  return null
}
```

### TypeScript型定義の拡張

```typescript
// types/next-auth.d.ts
import { DefaultSession } from "next-auth"
import "next-auth"
import "@auth/core/jwt"

declare module "next-auth" {
  interface Session {
    user: {
      id: string
      role: string
    } & DefaultSession["user"]
  }
  
  interface User {
    role: string
  }
}

declare module "@auth/core/jwt" {
  interface JWT {
    id: string
    role: string
  }
}
```

### セッション更新の実装

JWT戦略では、ユーザー情報の更新時にセッションも更新する必要がある：

```typescript
// app/profile/update/page.tsx
"use client"

import { useSession } from "next-auth/react"
import { useState } from "react"

export default function UpdateProfile() {
  const { data: session, update } = useSession()
  const [name, setName] = useState(session?.user?.name || "")

  const handleUpdate = async () => {
    // サーバー側でユーザー情報を更新
    const response = await fetch("/api/user/update", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ name }),
    })

    if (response.ok) {
      // セッションを更新（JWTトークンを再生成）
      await update({
        user: {
          ...session?.user,
          name: name,
        },
      })
    }
  }

  return (
    <div>
      <h1>プロフィール更新</h1>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="名前"
      />
      <button onClick={handleUpdate}>更新</button>
    </div>
  )
}
```

### JWT戦略でのセキュリティ強化

```typescript
// auth.ts (セキュリティ強化版)
import NextAuth, { type NextAuthConfig } from "next-auth"

export const authConfig = {
  session: { 
    strategy: "jwt",
    maxAge: 24 * 60 * 60, // 24時間（短めに設定）
  },
  
  callbacks: {
    jwt({ token, user }) {
      if (user) {
        token.id = user.id
        token.role = (user as any).role
        // セキュリティのため、機密情報は含めない
        // token.password = user.password // ❌ 絶対にしない
      }
      
      // トークンの有効期限チェック
      const now = Math.floor(Date.now() / 1000)
      if (token.exp && token.exp < now) {
        return null // 期限切れトークンを無効化
      }
      
      return token
    },
    
    session({ session, token }) {
      if (session.user && token) {
        session.user.id = token.id as string
        session.user.role = token.role as string
      }
      return session
    },
  },

  // セキュリティ設定
  jwt: {
    maxAge: 24 * 60 * 60, // 24時間
    // カスタム暗号化設定（オプション）
    encode: async ({ token, secret }) => {
      // カスタム暗号化ロジック
      return defaultEncode({ token, secret })
    },
    decode: async ({ token, secret }) => {
      // カスタム復号化ロジック
      return defaultDecode({ token, secret })
    },
  },
} satisfies NextAuthConfig
```

### JWT vs Database Strategy 比較表

| 項目 | JWT Strategy | Database Strategy |
|------|--------------|-------------------|
| **パフォーマンス** | 高速（DB不要） | やや低速（DB必要） |
| **スケーラビリティ** | 優秀 | 普通 |
| **セキュリティ** | 注意が必要 | 高い |
| **セッション無効化** | 困難 | 簡単 |
| **情報更新** | 複雑 | 簡単 |
| **サーバー負荷** | 低い | 高い |
| **実装複雑さ** | 中程度 | 簡単 |
| **適用場面** | 高トラフィック | 一般的なアプリ |

### どちらを選ぶべきか？

#### JWT戦略を選ぶべき場合
- **高トラフィック**のアプリケーション
- **マイクロサービス**アーキテクチャ
- **データベース負荷を抑えたい**場合
- **ステートレス**な設計が必要

#### Database戦略を選ぶべき場合
- **セキュリティが最重要**
- **即座のセッション無効化**が必要
- **ユーザー情報の頻繁な更新**がある
- **一般的なWebアプリケーション**

## セキュリティのベストプラクティス

Auth.jsを本番環境で安全に運用するためのセキュリティベストプラクティスを解説する。

### 環境変数の適切な設定

#### 必須環境変数

```env
# .env.local
# 🔐 認証シークレット（必須）
AUTH_SECRET="your-super-secret-key-here"  # npx auth secret で生成

# 🌐 ホスト設定
AUTH_TRUST_HOST=true  # 本番環境では必須

# 🔗 リダイレクト設定（プレビュー環境等で必要）
AUTH_REDIRECT_PROXY_URL="https://your-app.vercel.app"

# 📧 OAuth プロバイダ設定
AUTH_GOOGLE_ID="your-google-client-id"
AUTH_GOOGLE_SECRET="your-google-client-secret"
AUTH_GITHUB_ID="your-github-client-id"  
AUTH_GITHUB_SECRET="your-github-client-secret"

# 🗄️ データベース（Database戦略使用時）
DATABASE_URL="postgresql://user:password@localhost:5432/myapp"
```

#### 環境変数のセキュリティチェックリスト

- [ ] `AUTH_SECRET`は十分に長い（最低32文字）
- [ ] 本番環境では`AUTH_TRUST_HOST=true`を設定
- [ ] OAuth のClient SecretはGitにコミットしない
- [ ] 環境ごとに異なる`AUTH_SECRET`を使用
- [ ] `.env.local`を`.gitignore`に追加

### OAuth プロバイダのセキュリティ設定

#### Google OAuth の安全な設定

```typescript
// auth.ts
import Google from "next-auth/providers/google"

export const authConfig = {
  providers: [
    Google({
      clientId: process.env.AUTH_GOOGLE_ID,
      clientSecret: process.env.AUTH_GOOGLE_SECRET,
      authorization: {
        params: {
          // 必要最小限のスコープのみ要求
          scope: "openid email profile",
          // フィッシング攻撃を防ぐためのパラメータ
          prompt: "consent",
          access_type: "offline",
          response_type: "code",
        },
      },
    }),
  ],
  
  callbacks: {
    // OAuth サインイン時の検証
    async signIn({ user, account, profile }) {
      // メールドメイン制限の例
      const allowedDomains = ["yourdomain.com", "partner.com"]
      const email = user.email
      
      if (email && allowedDomains.length > 0) {
        const domain = email.split("@")[1]
        if (!allowedDomains.includes(domain)) {
          return false // サインインを拒否
        }
      }
      
      // 必要に応じて追加の検証ロジック
      return true
    },
  },
}
```

#### GitHub OAuth の設定

```typescript
import GitHub from "next-auth/providers/github"

GitHub({
  clientId: process.env.AUTH_GITHUB_ID,
  clientSecret: process.env.AUTH_GITHUB_SECRET,
  authorization: {
    params: {
      // 必要最小限のスコープ
      scope: "read:user user:email",
    },
  },
})
```

### Credentials認証のセキュリティ強化

```typescript
// auth.ts
import Credentials from "next-auth/providers/credentials"
import bcrypt from "bcryptjs"
import { rateLimit } from "@/lib/rate-limit"

export const authConfig = {
  providers: [
    Credentials({
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials, req) {
        if (!credentials?.email || !credentials?.password) {
          return null
        }

        // レート制限チェック
        const clientIP = req.headers?.["x-forwarded-for"] || "unknown"
        const rateLimitResult = await rateLimit(clientIP as string)
        
        if (!rateLimitResult.success) {
          throw new Error("Too many attempts. Please try again later.")
        }

        try {
          // データベースからユーザーを取得
          const user = await getUserByEmail(credentials.email)
          
          if (!user) {
            // ユーザーが存在しない場合もパスワードチェックを実行
            // タイミング攻撃を防ぐため
            await bcrypt.compare("dummy", "$2a$10$dummy.hash.to.prevent.timing.attacks")
            return null
          }

          // アカウントロック状態をチェック
          if (user.lockedUntil && user.lockedUntil > new Date()) {
            throw new Error("Account is temporarily locked")
          }

          // パスワード検証
          const isPasswordValid = await bcrypt.compare(
            credentials.password,
            user.hashedPassword
          )

          if (!isPasswordValid) {
            // 失敗回数を増やす
            await incrementFailedAttempts(user.id)
            return null
          }

          // 成功時は失敗回数をリセット
          await resetFailedAttempts(user.id)

          return {
            id: user.id,
            email: user.email,
            name: user.name,
            role: user.role,
          }
        } catch (error) {
          console.error("Authentication error:", error)
          return null
        }
      }
    })
  ],
}

// レート制限の実装例
async function rateLimit(identifier: string) {
  // Redis や メモリベースの実装
  // 例: 5分間に5回まで
  return { success: true } // 簡略化
}

// アカウントロック機能
async function incrementFailedAttempts(userId: string) {
  // 失敗回数を増やし、5回で30分ロック
}

async function resetFailedAttempts(userId: string) {
  // 失敗回数をリセット
}
```

### セッション管理のセキュリティ

#### セッションの適切な設定

```typescript
// auth.ts
export const authConfig = {
  session: {
    strategy: "jwt", // または "database"
    maxAge: 24 * 60 * 60, // 24時間（短めに設定）
    updateAge: 60 * 60, // 1時間ごとに更新
  },
  
  cookies: {
    sessionToken: {
      name: "__Secure-next-auth.session-token",
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: process.env.NODE_ENV === "production", // HTTPS必須
      },
    },
  },
  
  callbacks: {
    jwt({ token, user }) {
      // IPアドレスの検証（オプション）
      const currentIP = token.ip
      const requestIP = req?.ip
      
      if (currentIP && requestIP && currentIP !== requestIP) {
        // IPが変わった場合の処理
        console.warn("IP address changed for user:", token.sub)
      }
      
      if (user) {
        token.ip = requestIP
      }
      
      return token
    },
  },
}
```

### CSRF攻撃の防止

Auth.js v5では自動的にCSRF保護が有効になっているが、追加の設定も可能：

```typescript
// auth.ts
export const authConfig = {
  // CSRF保護を強化
  useSecureCookies: process.env.NODE_ENV === "production",
  
  callbacks: {
    // カスタムCSRF検証
    async redirect({ url, baseUrl }) {
      // 同一オリジンのみ許可
      if (url.startsWith("/")) return `${baseUrl}${url}`
      if (new URL(url).origin === baseUrl) return url
      return baseUrl
    },
  },
}
```

### ミドルウェアでの追加セキュリティ

```typescript
// middleware.ts
import { auth } from "@/auth"
import { NextResponse } from "next/server"

export default auth((req) => {
  const { nextUrl, auth } = req
  
  // 管理者ページの保護
  if (nextUrl.pathname.startsWith("/admin")) {
    if (!auth?.user || auth.user.role !== "admin") {
      return NextResponse.redirect(new URL("/unauthorized", nextUrl))
    }
  }
  
  // API ルートの保護
  if (nextUrl.pathname.startsWith("/api/protected")) {
    if (!auth) {
      return NextResponse.json(
        { error: "Unauthorized" }, 
        { status: 401 }
      )
    }
  }
  
  // セキュリティヘッダーの追加
  const response = NextResponse.next()
  response.headers.set("X-Frame-Options", "DENY")
  response.headers.set("X-Content-Type-Options", "nosniff")
  response.headers.set("Referrer-Policy", "strict-origin-when-cross-origin")
  
  return response
})

export const config = {
  matcher: [
    "/((?!api|_next/static|_next/image|favicon.ico).*)",
  ],
}
```

### 監査ログとモニタリング

```typescript
// lib/audit-log.ts
interface AuditEvent {
  userId?: string
  action: string
  resource: string
  ip: string
  userAgent: string
  timestamp: Date
}

export async function logAuditEvent(event: AuditEvent) {
  // データベースまたはログサービスに記録
  console.log("Audit:", JSON.stringify(event))
}

// auth.ts での使用例
export const authConfig = {
  callbacks: {
    async signIn({ user, account }) {
      await logAuditEvent({
        userId: user.id,
        action: "SIGN_IN",
        resource: "auth",
        ip: req.ip,
        userAgent: req.headers["user-agent"],
        timestamp: new Date(),
      })
      return true
    },
  },
}
```

## 実践的な認証実装例

実際のプロジェクトでAuth.jsを使用する際の実践的な例を、カスタムサインインページとServer Actionsを含めて解説する。

### カスタムサインインページの作成

Auth.jsのデフォルトページではなく、アプリのデザインに合わせたカスタムサインインページを作成しよう。

#### サインインページのコンポーネント

```typescript
// app/(auth)/signin/page.tsx
import { Suspense } from "react"
import { SignInForm } from "@/components/auth/signin-form"
import { Providers } from "@/components/auth/providers"

export default function SignInPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            アカウントにサインイン
          </h2>
        </div>
        
        <Suspense fallback={<div>読み込み中...</div>}>
          {/* OAuth プロバイダ */}
          <Providers />
          
          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300" />
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-gray-50 text-gray-500">または</span>
            </div>
          </div>
          
          {/* Credentials フォーム */}
          <SignInForm />
        </Suspense>
      </div>
    </div>
  )
}
```

#### OAuth プロバイダコンポーネント

```typescript
// components/auth/providers.tsx
"use client"

import { signIn } from "next-auth/react"
import { useState } from "react"
import { FaGoogle, FaGithub } from "react-icons/fa"

export function Providers() {
  const [isLoading, setIsLoading] = useState<string | null>(null)

  const handleSignIn = async (provider: string) => {
    setIsLoading(provider)
    try {
      await signIn(provider, { 
        callbackUrl: "/dashboard",
        redirect: true 
      })
    } catch (error) {
      console.error("Sign in error:", error)
    } finally {
      setIsLoading(null)
    }
  }

  return (
    <div className="space-y-3">
      <button
        onClick={() => handleSignIn("google")}
        disabled={isLoading !== null}
        className="w-full flex justify-center items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:opacity-50"
      >
        {isLoading === "google" ? (
          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-gray-900" />
        ) : (
          <>
            <FaGoogle className="w-4 h-4 mr-2 text-red-500" />
            Googleでサインイン
          </>
        )}
      </button>
      
      <button
        onClick={() => handleSignIn("github")}
        disabled={isLoading !== null}
        className="w-full flex justify-center items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:opacity-50"
      >
        {isLoading === "github" ? (
          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-gray-900" />
        ) : (
          <>
            <FaGithub className="w-4 h-4 mr-2" />
            GitHubでサインイン
          </>
        )}
      </button>
    </div>
  )
}
```

#### Credentials サインインフォーム

```typescript
// components/auth/signin-form.tsx
"use client"

import { useState } from "react"
import { signIn } from "next-auth/react"
import { useRouter, useSearchParams } from "next/navigation"

export function SignInForm() {
  const [email, setEmail] = useState("")
  const [password, setPassword] = useState("")
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState("")
  
  const router = useRouter()
  const searchParams = useSearchParams()
  const callbackUrl = searchParams.get("callbackUrl") || "/dashboard"

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setError("")

    try {
      const result = await signIn("credentials", {
        email,
        password,
        redirect: false,
      })

      if (result?.error) {
        setError("メールアドレスまたはパスワードが間違っています")
      } else {
        router.push(callbackUrl)
      }
    } catch (error) {
      setError("サインインに失敗しました")
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
      {error && (
        <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded">
          {error}
        </div>
      )}
      
      <div className="space-y-4">
        <div>
          <label htmlFor="email" className="block text-sm font-medium text-gray-700">
            メールアドレス
          </label>
          <input
            id="email"
            name="email"
            type="email"
            required
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500"
            placeholder="your@example.com"
          />
        </div>
        
        <div>
          <label htmlFor="password" className="block text-sm font-medium text-gray-700">
            パスワード
          </label>
          <input
            id="password"
            name="password"
            type="password"
            required
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          />
        </div>
      </div>

      <div>
        <button
          type="submit"
          disabled={isLoading}
          className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
        >
          {isLoading ? (
            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white" />
          ) : (
            "サインイン"
          )}
        </button>
      </div>
    </form>
  )
}
```

### Server Actions を使った認証処理

Next.js 14のServer Actionsを活用した認証処理の実装例：

```typescript
// app/(auth)/signin/actions.ts
"use server"

import { signIn } from "@/auth"
import { CredentialsSignin } from "next-auth"
import { redirect } from "next/navigation"
import { z } from "zod"

const signInSchema = z.object({
  email: z.string().email("有効なメールアドレスを入力してください"),
  password: z.string().min(6, "パスワードは6文字以上である必要があります"),
})

export async function signInAction(formData: FormData) {
  const rawData = {
    email: formData.get("email") as string,
    password: formData.get("password") as string,
  }

  // バリデーション
  const result = signInSchema.safeParse(rawData)
  if (!result.success) {
    return {
      error: result.error.errors[0].message,
    }
  }

  try {
    await signIn("credentials", {
      email: result.data.email,
      password: result.data.password,
      redirect: false,
    })
  } catch (error) {
    if (error instanceof CredentialsSignin) {
      return {
        error: "メールアドレスまたはパスワードが間違っています",
      }
    }
    return {
      error: "サインインに失敗しました",
    }
  }

  redirect("/dashboard")
}
```

#### Server Action を使用するフォーム

```typescript
// components/auth/signin-form-server-action.tsx
import { signInAction } from "@/app/(auth)/signin/actions"

export function SignInFormServerAction() {
  return (
    <form action={signInAction} className="mt-8 space-y-6">
      <div className="space-y-4">
        <div>
          <label htmlFor="email" className="block text-sm font-medium text-gray-700">
            メールアドレス
          </label>
          <input
            id="email"
            name="email"
            type="email"
            required
            className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500"
            placeholder="your@example.com"
          />
        </div>
        
        <div>
          <label htmlFor="password" className="block text-sm font-medium text-gray-700">
            パスワード
          </label>
          <input
            id="password"
            name="password"
            type="password"
            required
            className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          />
        </div>
      </div>

      <div>
        <button
          type="submit"
          className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
        >
          サインイン
        </button>
      </div>
    </form>
  )
}
```

### ロール ベースアクセス制御（RBAC）

```typescript
// lib/auth-utils.ts
import { auth } from "@/auth"
import { redirect } from "next/navigation"

export async function requireAuth() {
  const session = await auth()
  if (!session) {
    redirect("/signin")
  }
  return session
}

export async function requireRole(role: string) {
  const session = await requireAuth()
  if (session.user.role !== role) {
    redirect("/unauthorized")
  }
  return session
}

// 使用例：管理者ページ
// app/admin/page.tsx
import { requireRole } from "@/lib/auth-utils"

export default async function AdminPage() {
  await requireRole("admin")
  
  return (
    <div>
      <h1>管理者ページ</h1>
      <p>管理者のみアクセス可能です</p>
    </div>
  )
}
```

### エラーハンドリングとユーザー体験の向上

```typescript
// app/(auth)/error/page.tsx
import { Suspense } from "react"
import { ErrorDisplay } from "@/components/auth/error-display"

export default function AuthError() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full">
        <Suspense fallback={<div>読み込み中...</div>}>
          <ErrorDisplay />
        </Suspense>
      </div>
    </div>
  )
}

// components/auth/error-display.tsx
"use client"

import { useSearchParams } from "next/navigation"
import Link from "next/link"

const errorMessages = {
  Configuration: "サーバー設定エラーが発生しました。管理者にお問い合わせください。",
  AccessDenied: "アクセスが拒否されました。適切な権限がありません。",
  Verification: "認証に失敗しました。再度お試しください。",
  Default: "認証エラーが発生しました。再度お試しください。",
}

export function ErrorDisplay() {
  const searchParams = useSearchParams()
  const error = searchParams.get("error") as keyof typeof errorMessages
  
  const message = errorMessages[error] || errorMessages.Default

  return (
    <div className="bg-white p-8 rounded-lg shadow-md">
      <div className="text-center">
        <div className="text-red-500 text-6xl mb-4">⚠️</div>
        <h1 className="text-2xl font-bold text-gray-900 mb-4">
          認証エラー
        </h1>
        <p className="text-gray-600 mb-6">{message}</p>
        <Link
          href="/signin"
          className="inline-flex items-center px-4 py-2 border border-transparent text-base font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700"
        >
          サインインページに戻る
        </Link>
      </div>
    </div>
  )
}
```

## まとめ：Auth.js v5で構築する現代的な認証システム

この記事では、Auth.js (NextAuth v5) の基本概念から実践的な実装まで、包括的に解説した。

### 学んだ主要なポイント

#### 1. **Auth.js v5の改善点**
- 設定の一元化（`auth.ts`）
- API の統一（`auth()` 関数）
- 環境変数の統一（`AUTH_*` プレフィックス）
- TypeScript サポートの強化

#### 2. **セッション戦略の選択**
- **Database Strategy**: セキュリティ重視、即座の無効化可能
- **JWT Strategy**: パフォーマンス重視、スケーラブル

#### 3. **セキュリティのベストプラクティス**
- 適切な環境変数設定
- OAuth スコープの最小化
- Credentials 認証の強化（レート制限、アカウントロック）
- セッション管理の最適化

#### 4. **実践的な実装パターン**
- カスタムサインインページ
- Server Actions の活用
- ロールベースアクセス制御
- エラーハンドリング

### 次に学ぶべきこと

1. **高度なセキュリティ機能**
   - 二要素認証（2FA）の実装
   - WebAuthn/パスキーの導入
   - セッション固定攻撃の対策

2. **パフォーマンス最適化**
   - セッションキャッシュ戦略
   - データベース接続プールの最適化
   - CDN との連携

3. **監視とメンテナンス**
   - 認証ログの分析
   - セキュリティメトリクスの監視
   - 定期的なセキュリティ監査

4. **マイクロサービス連携**
   - JWT トークンの共有
   - サービス間認証
   - API ゲートウェイとの統合

### 実装時のチェックリスト

#### セットアップ
- [ ] `next-auth@beta` のインストール
- [ ] `auth.ts` の基本設定
- [ ] 環境変数の適切な設定（`AUTH_*`）
- [ ] API ルート（`[...nextauth]/route.ts`）の作成

#### セキュリティ
- [ ] `AUTH_SECRET` の生成と設定
- [ ] OAuth プロバイダの適切な設定
- [ ] ミドルウェアによるルート保護
- [ ] CSRF 保護の確認

#### 本番環境対応
- [ ] `AUTH_TRUST_HOST=true` の設定
- [ ] HTTPS の強制
- [ ] セキュリティヘッダーの設定
- [ ] 監査ログの実装

#### ユーザー体験
- [ ] カスタムサインインページの作成
- [ ] エラーハンドリングの実装
- [ ] ローディング状態の表示
- [ ] アクセシビリティの考慮

### 最終的な推奨事項

Auth.js v5 は、現代的なWeb アプリケーションにおいて強力で柔軟な認証ソリューションを提供する。以下の点を意識して実装することで、セキュアで使いやすい認証システムを構築できる：

1. **セキュリティファースト**: 常にセキュリティを最優先に考える
2. **ユーザー体験の重視**: 直感的で使いやすいインターフェースを提供
3. **適切な戦略選択**: プロジェクトの要件に応じてDatabase/JWT戦略を選択
4. **継続的な改善**: セキュリティ動向を追跡し、定期的にアップデート

Auth.js v5 を使用することで、認証の複雑さから解放され、アプリケーションのコア機能開発に集中できる。まずは小さなプロジェクトから始めて、徐々に高度な機能を追加していくことをお勧めする。
