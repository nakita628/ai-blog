---
date: 2025-08-14
title: Pydantic完全ガイド：Pythonで型安全なデータバリデーションを実現する
description: Pydanticライブラリを使ったPythonデータバリデーションの実践ガイド。BaseModelの基本から高度なバリデーション、FastAPIとの連携まで、Pythonで最も人気のあるデータ検証ライブラリの使い方を詳しく解説します。
tags:
  - python
  - pydantic
  - data-validation
  - type-hints
  - fastapi
  - json-schema
  - best-practices
  - api-development
prev:
  text: 'Effect完全ガイド：TypeScriptの次世代標準ライブラリで堅牢なアプリケーションを構築'
  link: '/posts/2025/08/12'
next:
  text: 'TypeScript標準メソッド完全ガイド：配列・文字列・オブジェクトの実践的な使い方'
  link: '/posts/2025/08/15'
---

# Pydantic完全ガイド：Pythonで型安全なデータバリデーションを実現する

Pythonでデータバリデーションを型安全かつ効率的に行いたいと思いませんか？本記事では、[Pydantic](https://docs.pydantic.dev/latest/)ライブラリを使ったデータ検証の実践手法を詳しく解説します。型ヒントを活用した直感的なバリデーションから、FastAPIとの連携まで、Pythonで最も人気のあるデータ検証ライブラリの魅力をご紹介します。

## Pydanticとは

Pydanticは、Pythonで最も広く使われているデータバリデーションライブラリです。型ヒントを活用してスキーマを定義し、高速で堅牢なデータ検証を実現します。Rustで書かれたコアエンジンにより、優れたパフォーマンスを提供しています。

### Pydanticの主要な特徴

- **型ヒントベース**: スキーマ定義とバリデーションが型アノテーションで制御される
- **高速**: Rustで書かれたコアエンジンによる優れたパフォーマンス
- **JSON Schema対応**: モデルからJSON Schemaを自動生成
- **厳密モードと緩和モード**: データ変換の柔軟性
- **豊富なエコシステム**: FastAPI、Django Ninja、SQLModelなどとの連携
- **実戦経験**: 月間3億6千万回以上のダウンロード、FAANG企業での採用

## 基本的な使用方法

### 1. インストール

```bash
pip install pydantic
```

### 2. 基本的なモデル定義

```python
from datetime import datetime
from pydantic import BaseModel, PositiveInt

class User(BaseModel):
    id: int
    name: str = 'John Doe'  # デフォルト値
    signup_ts: datetime | None  # オプショナル
    tastes: dict[str, PositiveInt]  # 正の整数のみ

# 外部データからモデルを作成
external_data = {
    'id': 123,
    'signup_ts': '2019-06-01 12:22',
    'tastes': {
        'wine': 9,
        b'cheese': 7,  # bytesは自動的に文字列に変換
        'cabbage': '1',  # 文字列は自動的に整数に変換
    },
}

user = User(**external_data)
print(user.id)  # 123
print(user.model_dump())
# {
#     'id': 123,
#     'name': 'John Doe',
#     'signup_ts': datetime.datetime(2019, 6, 1, 12, 22),
#     'tastes': {'wine': 9, 'cheese': 7, 'cabbage': 1},
# }
```

### 3. バリデーションエラーの処理

```python
from pydantic import ValidationError

try:
    User(**{'id': 'not an int', 'tastes': {}})
except ValidationError as e:
    print(e.errors())
    # [
    #     {
    #         'type': 'int_parsing',
    #         'loc': ('id',),
    #         'msg': 'Input should be a valid integer, unable to parse string as an integer',
    #         'input': 'not an int',
    #         'url': 'https://errors.pydantic.dev/2/v/int_parsing',
    #     },
    #     {
    #         'type': 'missing',
    #         'loc': ('signup_ts',),
    #         'msg': 'Field required',
    #         'input': {'id': 'not an int', 'tastes': {}},
    #         'url': 'https://errors.pydantic.dev/2/v/missing',
    #     },
    # ]
```

## 高度なバリデーション

### 1. カスタムバリデーター

```python
from pydantic import BaseModel, field_validator, model_validator
from typing import Any

class UserProfile(BaseModel):
    username: str
    email: str
    age: int
    password: str

    @field_validator('username')
    @classmethod
    def validate_username(cls, v: str) -> str:
        if len(v) < 3:
            raise ValueError('Username must be at least 3 characters')
        if not v.isalnum():
            raise ValueError('Username must be alphanumeric')
        return v.lower()

    @field_validator('email')
    @classmethod
    def validate_email(cls, v: str) -> str:
        if '@' not in v:
            raise ValueError('Invalid email format')
        return v.lower()

    @field_validator('age')
    @classmethod
    def validate_age(cls, v: int) -> int:
        if v < 0 or v > 150:
            raise ValueError('Age must be between 0 and 150')
        return v

    @model_validator(mode='after')
    def validate_password_strength(self) -> 'UserProfile':
        if len(self.password) < 8:
            raise ValueError('Password must be at least 8 characters')
        return self

# 使用例
try:
    user = UserProfile(
        username='john123',
        email='john@example.com',
        age=25,
        password='securepass123'
    )
    print(f"Valid user: {user.username}")
except ValidationError as e:
    print(f"Validation error: {e}")
```

### 2. 複雑なデータ構造

```python
from pydantic import BaseModel, Field
from typing import List, Optional, Union
from datetime import datetime

class Address(BaseModel):
    street: str
    city: str
    country: str
    postal_code: str

class OrderItem(BaseModel):
    product_id: int
    quantity: int = Field(gt=0, description="Quantity must be positive")
    price: float = Field(gt=0, description="Price must be positive")

class Order(BaseModel):
    order_id: str = Field(..., min_length=1, description="Order ID is required")
    customer_id: int
    items: List[OrderItem]
    shipping_address: Address
    billing_address: Optional[Address] = None
    order_date: datetime = Field(default_factory=datetime.now)
    total_amount: float = Field(..., gt=0)
    status: str = Field(default="pending", pattern="^(pending|processing|shipped|delivered|cancelled)$")

    @field_validator('total_amount')
    @classmethod
    def validate_total_amount(cls, v: float, info: Any) -> float:
        # アイテムの合計金額と一致するかチェック
        if 'items' in info.data:
            calculated_total = sum(item.price * item.quantity for item in info.data['items'])
            if abs(v - calculated_total) > 0.01:  # 浮動小数点の誤差を考慮
                raise ValueError(f'Total amount {v} does not match items total {calculated_total}')
        return v

# 使用例
order_data = {
    'order_id': 'ORD-12345',
    'customer_id': 1001,
    'items': [
        {'product_id': 1, 'quantity': 2, 'price': 29.99},
        {'product_id': 2, 'quantity': 1, 'price': 49.99}
    ],
    'shipping_address': {
        'street': '123 Main St',
        'city': 'Tokyo',
        'country': 'Japan',
        'postal_code': '100-0001'
    },
    'total_amount': 109.97
}

order = Order(**order_data)
print(f"Order validated: {order.order_id}")
```

## FastAPIとの連携

### 1. 基本的なAPIエンドポイント

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional

app = FastAPI()

class UserCreate(BaseModel):
    username: str
    email: str
    full_name: Optional[str] = None
    age: Optional[int] = None

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    full_name: Optional[str] = None
    age: Optional[int] = None
    is_active: bool = True

# インメモリストレージ（実際のプロジェクトではデータベースを使用）
users_db = []
user_id_counter = 1

@app.post("/users/", response_model=UserResponse)
async def create_user(user: UserCreate):
    global user_id_counter

    # ユーザー名の重複チェック
    if any(u['username'] == user.username for u in users_db):
        raise HTTPException(status_code=400, detail="Username already registered")

    # 新しいユーザーを作成
    new_user = UserResponse(
        id=user_id_counter,
        username=user.username,
        email=user.email,
        full_name=user.full_name,
        age=user.age
    )

    users_db.append(new_user.model_dump())
    user_id_counter += 1

    return new_user

@app.get("/users/", response_model=List[UserResponse])
async def get_users(skip: int = 0, limit: int = 100):
    return users_db[skip : skip + limit]

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    for user in users_db:
        if user['id'] == user_id:
            return user
    raise HTTPException(status_code=404, detail="User not found")
```

### 2. 高度なAPI設計

```python
from fastapi import FastAPI, Depends, HTTPException, status
from pydantic import BaseModel, EmailStr, Field
from typing import List, Optional
from datetime import datetime

app = FastAPI(title="User Management API")

class UserBase(BaseModel):
    username: str = Field(..., min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    email: EmailStr
    full_name: Optional[str] = Field(None, max_length=100)
    age: Optional[int] = Field(None, ge=0, le=150)

class UserCreate(UserBase):
    password: str = Field(..., min_length=8, max_length=100)

class UserUpdate(BaseModel):
    username: Optional[str] = Field(None, min_length=3, max_length=50)
    email: Optional[EmailStr] = None
    full_name: Optional[str] = Field(None, max_length=100)
    age: Optional[int] = Field(None, ge=0, le=150)

class UserInDB(UserBase):
    id: int
    created_at: datetime
    updated_at: datetime
    is_active: bool = True

    class Config:
        from_attributes = True

class UserResponse(UserBase):
    id: int
    created_at: datetime
    is_active: bool

# データベース操作のシミュレーション
class UserService:
    def __init__(self):
        self.users = {}
        self.counter = 1

    def create_user(self, user_data: UserCreate) -> UserInDB:
        # ユーザー名の重複チェック
        if any(u.username == user_data.username for u in self.users.values()):
            raise ValueError("Username already exists")

        now = datetime.now()
        user = UserInDB(
            id=self.counter,
            username=user_data.username,
            email=user_data.email,
            full_name=user_data.full_name,
            age=user_data.age,
            created_at=now,
            updated_at=now
        )

        self.users[user.id] = user
        self.counter += 1
        return user

    def get_user(self, user_id: int) -> Optional[UserInDB]:
        return self.users.get(user_id)

    def update_user(self, user_id: int, user_data: UserUpdate) -> Optional[UserInDB]:
        if user_id not in self.users:
            return None

        user = self.users[user_id]
        update_data = user_data.model_dump(exclude_unset=True)

        for field, value in update_data.items():
            setattr(user, field, value)

        user.updated_at = datetime.now()
        return user

user_service = UserService()

@app.post("/users/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(user: UserCreate):
    try:
        new_user = user_service.create_user(user)
        return UserResponse.model_validate(new_user)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    user = user_service.get_user(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return UserResponse.model_validate(user)

@app.put("/users/{user_id}", response_model=UserResponse)
async def update_user(user_id: int, user_data: UserUpdate):
    updated_user = user_service.update_user(user_id, user_data)
    if not updated_user:
        raise HTTPException(status_code=404, detail="User not found")
    return UserResponse.model_validate(updated_user)
```

## 設定管理

### 1. 環境変数からの設定読み込み

```python
from pydantic import BaseModel, Field
from pydantic_settings import BaseSettings
from typing import Optional

class DatabaseSettings(BaseModel):
    host: str = Field(default="localhost", description="Database host")
    port: int = Field(default=5432, ge=1, le=65535, description="Database port")
    username: str = Field(..., description="Database username")
    password: str = Field(..., description="Database password")
    database: str = Field(..., description="Database name")

class APISettings(BaseModel):
    title: str = Field(default="My API", description="API title")
    version: str = Field(default="1.0.0", description="API version")
    debug: bool = Field(default=False, description="Debug mode")
    secret_key: str = Field(..., min_length=32, description="Secret key for JWT")

class Settings(BaseSettings):
    # 環境変数から自動的に読み込み
    database: DatabaseSettings
    api: APISettings

    # カスタム環境変数名
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"
        env_nested_delimiter = "__"

# 使用例
settings = Settings(
    database__host="db.example.com",
    database__username="myuser",
    database__password="mypassword",
    database__database="myapp",
    api__secret_key="your-super-secret-key-here-32-chars-long"
)

print(f"Database: {settings.database.host}:{settings.database.port}")
print(f"API: {settings.api.title} v{settings.api.version}")
```

## パフォーマンスとベストプラクティス

### 1. モデルの最適化

```python
from pydantic import BaseModel, ConfigDict
from typing import Any

class OptimizedModel(BaseModel):
    # パフォーマンス最適化の設定
    model_config = ConfigDict(
        # 厳密モード（型変換を無効化）
        strict=True,
        # バリデーション後のデータをキャッシュ
        validate_assignment=True,
        # 余分なフィールドを無視
        extra='ignore',
        # JSONスキーマの生成を最適化
        json_schema_extra={
            "examples": [
                {
                    "name": "Example User",
                    "email": "user@example.com",
                    "age": 25
                }
            ]
        }
    )

    name: str
    email: str
    age: int

# 使用例
user = OptimizedModel(name="John", email="john@example.com", age=25)
print(user.model_dump_json())
```

### 2. バリデーションの効率化

```python
from pydantic import BaseModel, field_validator
from typing import Any, Dict

class Product(BaseModel):
    id: int
    name: str
    price: float
    category: str
    tags: list[str] = []

    @field_validator('price')
    @classmethod
    def validate_price(cls, v: float) -> float:
        if v <= 0:
            raise ValueError('Price must be positive')
        return round(v, 2)

    @field_validator('tags')
    @classmethod
    def validate_tags(cls, v: list[str]) -> list[str]:
        # 重複を除去し、小文字に統一
        return list(set(tag.lower().strip() for tag in v if tag.strip()))

# バッチ処理での使用
def process_products(products_data: list[Dict[str, Any]]) -> list[Product]:
    valid_products = []
    errors = []

    for i, data in enumerate(products_data):
        try:
            product = Product(**data)
            valid_products.append(product)
        except Exception as e:
            errors.append(f"Product {i}: {e}")

    if errors:
        print("Validation errors:", errors)

    return valid_products

# 使用例
products_data = [
    {"id": 1, "name": "Laptop", "price": 999.99, "category": "Electronics", "tags": ["computer", "tech", "COMPUTER"]},
    {"id": 2, "name": "Book", "price": 19.99, "category": "Books", "tags": ["education", "learning"]},
    {"id": 3, "name": "Invalid", "price": -10, "category": "Test", "tags": []}
]

valid_products = process_products(products_data)
for product in valid_products:
    print(f"{product.name}: ${product.price} - Tags: {product.tags}")
```

## まとめ

Pydanticは、Pythonでデータバリデーションを行うための最も強力で使いやすいライブラリです。型ヒントを活用した直感的なスキーマ定義、高速なバリデーション、豊富なエコシステムにより、堅牢なアプリケーション開発を支援します。

FastAPIとの連携により、型安全なAPI開発が可能になり、設定管理や複雑なデータ構造の処理も簡単に行えます。Pydanticの豊富な機能を活用して、より安全で保守性の高いPythonアプリケーションを構築してみてください。

[Pydantic公式ドキュメント](https://docs.pydantic.dev/latest/)で詳細な情報やサンプルを確認し、データバリデーションの新しい世界を体験してみましょう。
