---
date: 2025-08-11
title: neverthrow完全ガイド：TypeScriptで関数型エラーハンドリングを実践する
description: neverthrowライブラリを使った関数型エラーハンドリングの実践ガイド。Result型の基本から実用的なパターン、safeTryの活用まで、try/catchを使わない新しいエラー処理のアプローチを詳しく解説します。
tags:
  - typescript
  - neverthrow
  - error-handling
  - functional-programming
  - result-type
  - either-type
  - best-practices
prev:
  text: 'Elixirで始める機械学習：関数型言語の強みを活かしたAI開発'
  link: '/posts/2025/08/10'
next:
  text: 'Effect完全ガイド：TypeScriptの次世代標準ライブラリで堅牢なアプリケーションを構築'
  link: '/posts/2025/08/12'
---

# neverthrow完全ガイド：TypeScriptで関数型エラーハンドリングを実践する

TypeScriptでエラーハンドリングをより安全で読みやすくしたいと思いませんか？本記事では、neverthrowライブラリを使った関数型プログラミングアプローチのエラー処理を詳しく解説します。従来のtry/catchとは異なる、型安全で宣言的なエラーハンドリングの世界をご紹介します。

## neverthrowとは

neverthrowは、JavaScript/TypeScriptで関数型プログラミング由来の`Result`型や`Either`型を提供するライブラリです。処理の成功/失敗を型レベルで表現し、try/catchを使わずにエラーハンドリングを実現します。

### 基本的な概念

```typescript
// Result型の定義
type Result<T, E> = Ok<T, E> | Err<T, E>

// 成功を表すOk型
interface Ok<T, E> {
  isOk(): true
  isErr(): false
  value: T
}

// 失敗を表すErr型
interface Err<T, E> {
  isOk(): false
  isErr(): true
  error: E
}
```

## インストールとセットアップ

```bash
npm install neverthrow
npm install eslint-plugin-neverthrow
```

ESLintプラグインを導入することで、エラー処理がされていないResultに対して警告を出してくれます。

## 基本的な使用方法

### 1. 成功・失敗の作成

```typescript
import { ok, err, Result } from 'neverthrow'

// 成功値の作成
const successResult: Result<string, Error> = ok('処理成功')

// 失敗値の作成
const errorResult: Result<string, Error> = err(new Error('処理失敗'))

// 値の取り出し
if (successResult.isOk()) {
  console.log(successResult.value) // "処理成功"
}

if (errorResult.isErr()) {
  console.log(errorResult.error.message) // "処理失敗"
}
```

### 2. 値の変換（map）

```typescript
// 成功時の値のみを変換
const numberResult = ok('123')
  .map((value) => parseInt(value, 10))
  .map((value) => value * 2)

// 結果: Ok(246)

// 失敗時は変換されない
const errorResult = err(new Error('パース失敗')).map((value) => parseInt(value, 10))

// 結果: Err(Error("パース失敗"))
```

### 3. エラーの変換（mapErr）

```typescript
// 失敗時のエラーのみを変換
const customError = err(new Error('データベースエラー')).mapErr((error) => ({
  type: 'DATABASE_ERROR',
  message: error.message,
  timestamp: new Date(),
}))

// 結果: Err({ type: "DATABASE_ERROR", message: "データベースエラー", timestamp: ... })
```

### 4. チェーン処理（andThen）

```typescript
// Resultを返す関数をチェーン
const validateAndProcess = (input: string): Result<number, string> => {
  return ok(input)
    .andThen((value) => {
      if (value.length === 0) {
        return err('入力が空です')
      }
      return ok(value)
    })
    .andThen((value) => {
      const parsed = parseInt(value, 10)
      if (isNaN(parsed)) {
        return err('数値に変換できません')
      }
      return ok(parsed)
    })
    .andThen((value) => {
      if (value < 0) {
        return err('負の数は許可されません')
      }
      return ok(value * 2)
    })
}

// 使用例
const result1 = validateAndProcess('123') // Ok(246)
const result2 = validateAndProcess('') // Err("入力が空です")
const result3 = validateAndProcess('abc') // Err("数値に変換できません")
```

## 実践的な使用例

### 1. APIリクエストの処理

```typescript
import { ResultAsync, errAsync } from 'neverthrow'

interface User {
  id: number
  name: string
  email: string
}

interface ApiError {
  status: number
  message: string
}

// API呼び出しをResultAsyncでラップ
const fetchUser = (id: number): ResultAsync<User, ApiError> => {
  return ResultAsync.fromPromise(fetch(`/api/users/${id}`), () => ({
    status: 500,
    message: 'ネットワークエラー',
  })).andThen((response) => {
    if (!response.ok) {
      return errAsync({ status: response.status, message: 'APIエラー' })
    }
    return ResultAsync.fromPromise(response.json(), () => ({
      status: 500,
      message: 'JSONパースエラー',
    }))
  })
}

// 使用例
const handleUserRequest = async (userId: number) => {
  const result = await fetchUser(userId)

  result.match(
    (user) => {
      console.log(`ユーザー取得成功: ${user.name}`)
      return user
    },
    (error) => {
      console.error(`エラー: ${error.status} - ${error.message}`)
      return null
    },
  )
}
```

### 2. データベース操作

```typescript
import { ok, err, Result } from 'neverthrow'

interface DatabaseError {
  code: string
  message: string
}

interface User {
  id: number
  name: string
  email: string
}

// データベース操作をResultでラップ
const findUserById = async (id: number): Promise<Result<User, DatabaseError>> => {
  try {
    const user = await db.users.findUnique({ where: { id } })
    if (!user) {
      return err({ code: 'USER_NOT_FOUND', message: 'ユーザーが見つかりません' })
    }
    return ok(user)
  } catch (error) {
    return err({ code: 'DATABASE_ERROR', message: 'データベースエラー' })
  }
}

const createUser = async (userData: Omit<User, 'id'>): Promise<Result<User, DatabaseError>> => {
  try {
    const user = await db.users.create({ data: userData })
    return ok(user)
  } catch (error) {
    return err({ code: 'CREATE_ERROR', message: 'ユーザー作成に失敗しました' })
  }
}
```

### 3. safeTryを使った簡潔なエラーハンドリング

```typescript
import { safeTry, ok, err } from 'neverthrow'

// 従来の書き方（ボイラープレートが多い）
const processUserData = (userId: number): Result<User, string> => {
  const userResult = findUserById(userId)
  if (userResult.isErr()) {
    return err(`ユーザー取得失敗: ${userResult.error.message}`)
  }

  const validationResult = validateUser(userResult.value)
  if (validationResult.isErr()) {
    return err(`バリデーション失敗: ${validationResult.error}`)
  }

  const updateResult = updateUser(validationResult.value)
  if (updateResult.isErr()) {
    return err(`更新失敗: ${updateResult.error.message}`)
  }

  return ok(updateResult.value)
}

// safeTryを使った書き方（簡潔）
const processUserDataWithSafeTry = (userId: number): Result<User, string> => {
  return safeTry<User, string>(function* () {
    const user = yield* findUserById(userId)
      .mapErr((e) => `ユーザー取得失敗: ${e.message}`)
      .safeUnwrap()

    const validatedUser = yield* validateUser(user)
      .mapErr((e) => `バリデーション失敗: ${e}`)
      .safeUnwrap()

    const updatedUser = yield* updateUser(validatedUser)
      .mapErr((e) => `更新失敗: ${e.message}`)
      .safeUnwrap()

    return ok(updatedUser)
  })
}
```

## 非同期処理（ResultAsync）

```typescript
import { ResultAsync, okAsync, errAsync } from 'neverthrow'

// 非同期処理のチェーン
const asyncWorkflow = (input: string): ResultAsync<number, string> => {
  return okAsync(input)
    .andThen((value) =>
      ResultAsync.fromPromise(fetch(`/api/process/${value}`), () => 'ネットワークエラー'),
    )
    .andThen((response) => ResultAsync.fromPromise(response.json(), () => 'JSONパースエラー'))
    .andThen((data) => {
      if (data.success) {
        return okAsync(data.result)
      }
      return errAsync('処理失敗')
    })
}

// 並列処理
const parallelProcessing = async (ids: number[]): Promise<Result<number[], string>> => {
  const results = await Promise.all(ids.map((id) => fetchUser(id)))

  // 全て成功した場合のみOkを返す
  const allOk = results.every((result) => result.isOk())
  if (allOk) {
    return ok(results.map((result) => result.value))
  }

  // 一つでも失敗があれば最初のエラーを返す
  const firstError = results.find((result) => result.isErr())
  return err(firstError!.error)
}
```

## ベストプラクティス

### 1. エラー型の設計

```typescript
// 具体的で型安全なエラー型を定義
interface ValidationError {
  type: 'VALIDATION_ERROR'
  field: string
  message: string
}

interface DatabaseError {
  type: 'DATABASE_ERROR'
  code: string
  message: string
}

interface NetworkError {
  type: 'NETWORK_ERROR'
  status: number
  message: string
}

type AppError = ValidationError | DatabaseError | NetworkError
```

### 2. エラーの変換と統一

```typescript
// エラーを統一された形式に変換
const handleError = (error: AppError): string => {
  switch (error.type) {
    case 'VALIDATION_ERROR':
      return `バリデーションエラー: ${error.field} - ${error.message}`
    case 'DATABASE_ERROR':
      return `データベースエラー: ${error.code} - ${error.message}`
    case 'NETWORK_ERROR':
      return `ネットワークエラー: ${error.status} - ${error.message}`
  }
}
```

### 3. テストでの使用

```typescript
import { ok, err } from 'neverthrow'

describe('neverthrowのテスト', () => {
  it('成功ケースのテスト', () => {
    const result = ok('成功')
    expect(result.isOk()).toBe(true)
    expect(result.value).toBe('成功')
  })

  it('失敗ケースのテスト', () => {
    const result = err('失敗')
    expect(result.isErr()).toBe(true)
    expect(result.error).toBe('失敗')
  })

  it('チェーン処理のテスト', () => {
    const result = ok('123')
      .map((value) => parseInt(value, 10))
      .andThen((value) => (value > 0 ? ok(value) : err('負の数')))

    expect(result).toEqual(ok(123))
  })
})
```

## まとめ

neverthrowを使った関数型エラーハンドリングは、従来のtry/catchとは異なる、型安全で宣言的なアプローチを提供します。Result型による明示的な成功/失敗の表現、チェーン処理による読みやすいコード、safeTryによる簡潔なエラーハンドリングなど、多くのメリットがあります。

特にTypeScriptとの相性が良く、型システムを活用した安全なエラー処理が実現できます。実践的な使用例を参考に、プロジェクトにneverthrowを導入して、より堅牢で保守性の高いコードを書いてみてください。

関数型プログラミングの考え方を取り入れたエラーハンドリングで、バグの少ないアプリケーション開発を目指しましょう。
