---
date: 2025-08-11
title: neverthrow完全ガイド：TypeScriptで関数型エラーハンドリングを実践する
description: neverthrowライブラリを使った関数型エラーハンドリングの実践ガイド。Result型の基本から実用的なパターン、safeTryの活用まで、try/catchを使わない新しいエラー処理のアプローチを詳しく解説します。
tags:
    - typescript
    - neverthrow
    - error-handling
    - functional-programming
    - result-type
    - either-type
    - best-practices
prev:
    text: "Elixirで始める機械学習：関数型言語の強みを活かしたAI開発"
    link: "/posts/2025/08/10"
next:
    text: "Effect完全ガイド：TypeScriptの次世代標準ライブラリで堅牢なアプリケーションを構築"
    link: "/posts/2025/08/12"
---

# neverthrow完全ガイド：TypeScriptで関数型エラーハンドリングを実践する

TypeScriptでエラーハンドリングをより安全で読みやすくしたいと思いませんか？本記事では、neverthrowライブラリを使った関数型プログラミングアプローチのエラー処理を詳しく解説します。従来のtry/catchとは異なる、型安全で宣言的なエラーハンドリングの世界をご紹介します。

## neverthrowとは

neverthrowは、JavaScript/TypeScriptで関数型プログラミング由来の`Result`型や`Either`型を提供するライブラリです。処理の成功/失敗を型レベルで表現し、try/catchを使わずにエラーハンドリングを実現します。

### 基本的な概念

```typescript
// Result型の定義
type Result<T, E> = Ok<T, E> | Err<T, E>

// 成功を表すOk型
interface Ok<T, E> {
  isOk(): true
  isErr(): false
  value: T
}

// 失敗を表すErr型
interface Err<T, E> {
  isOk(): false
  isErr(): true
  error: E
}
```

## インストールとセットアップ

```bash
npm install neverthrow
npm install eslint-plugin-neverthrow
```

ESLintプラグインを導入することで、エラー処理がされていないResultに対して警告を出してくれます。

## 基本的な使用方法

### 1. 成功・失敗の作成

```typescript
import { ok, err, Result } from 'neverthrow'

// 成功値の作成
const successResult: Result<string, Error> = ok("処理成功")

// 失敗値の作成
const errorResult: Result<string, Error> = err(new Error("処理失敗"))

// 値の取り出し
if (successResult.isOk()) {
  console.log(successResult.value) // "処理成功"
}

if (errorResult.isErr()) {
  console.log(errorResult.error.message) // "処理失敗"
}
```

### 2. 値の変換（map）

```typescript
// 成功時の値のみを変換
const numberResult = ok("123")
  .map(value => parseInt(value, 10))
  .map(value => value * 2)

// 結果: Ok(246)

// 失敗時は変換されない
const errorResult = err(new Error("パース失敗"))
  .map(value => parseInt(value, 10))

// 結果: Err(Error("パース失敗"))
```

### 3. エラーの変換（mapErr）

```typescript
// 失敗時のエラーのみを変換
const customError = err(new Error("データベースエラー"))
  .mapErr(error => ({
    type: "DATABASE_ERROR",
    message: error.message,
    timestamp: new Date()
  }))

// 結果: Err({ type: "DATABASE_ERROR", message: "データベースエラー", timestamp: ... })
```

### 4. チェーン処理（andThen）

```typescript
// Resultを返す関数をチェーン
const validateAndProcess = (input: string): Result<number, string> => {
  return ok(input)
    .andThen(value => {
      if (value.length === 0) {
        return err("入力が空です")
      }
      return ok(value)
    })
    .andThen(value => {
      const parsed = parseInt(value, 10)
      if (isNaN(parsed)) {
        return err("数値に変換できません")
      }
      return ok(parsed)
    })
    .andThen(value => {
      if (value < 0) {
        return err("負の数は許可されません")
      }
      return ok(value * 2)
    })
}

// 使用例
const result1 = validateAndProcess("123") // Ok(246)
const result2 = validateAndProcess("")    // Err("入力が空です")
const result3 = validateAndProcess("abc") // Err("数値に変換できません")
```

## 実践的な使用例

### 1. APIリクエストの処理

```typescript
import { ResultAsync, errAsync } from 'neverthrow'

interface User {
  id: number
  name: string
  email: string
}

interface ApiError {
  status: number
  message: string
}

// API呼び出しをResultAsyncでラップ
const fetchUser = (id: number): ResultAsync<User, ApiError> => {
  return ResultAsync.fromPromise(
    fetch(`/api/users/${id}`),
    () => ({ status: 500, message: "ネットワークエラー" })
  )
  .andThen(response => {
    if (!response.ok) {
      return errAsync({ status: response.status, message: "APIエラー" })
    }
    return ResultAsync.fromPromise(
      response.json(),
      () => ({ status: 500, message: "JSONパースエラー" })
    )
  })
}

// 使用例
const handleUserRequest = async (userId: number) => {
  const result = await fetchUser(userId)
  
  result.match(
    user => {
      console.log(`ユーザー取得成功: ${user.name}`)
      return user
    },
    error => {
      console.error(`エラー: ${error.status} - ${error.message}`)
      return null
    }
  )
}
```

### 2. データベース操作

```typescript
import { ok, err, Result } from 'neverthrow'

interface DatabaseError {
  code: string
  message: string
}

interface User {
  id: number
  name: string
  email: string
}

// データベース操作をResultでラップ
const findUserById = async (id: number): Promise<Result<User, DatabaseError>> => {
  try {
    const user = await db.users.findUnique({ where: { id } })
    if (!user) {
      return err({ code: "USER_NOT_FOUND", message: "ユーザーが見つかりません" })
    }
    return ok(user)
  } catch (error) {
    return err({ code: "DATABASE_ERROR", message: "データベースエラー" })
  }
}

const createUser = async (userData: Omit<User, 'id'>): Promise<Result<User, DatabaseError>> => {
  try {
    const user = await db.users.create({ data: userData })
    return ok(user)
  } catch (error) {
    return err({ code: "CREATE_ERROR", message: "ユーザー作成に失敗しました" })
  }
}
```

### 3. safeTryを使った簡潔なエラーハンドリング

```typescript
import { safeTry, ok, err } from 'neverthrow'

// 従来の書き方（ボイラープレートが多い）
const processUserData = (userId: number): Result<User, string> => {
  const userResult = findUserById(userId)
  if (userResult.isErr()) {
    return err(`ユーザー取得失敗: ${userResult.error.message}`)
  }

  const validationResult = validateUser(userResult.value)
  if (validationResult.isErr()) {
    return err(`バリデーション失敗: ${validationResult.error}`)
  }

  const updateResult = updateUser(validationResult.value)
  if (updateResult.isErr()) {
    return err(`更新失敗: ${updateResult.error.message}`)
  }

  return ok(updateResult.value)
}

// safeTryを使った書き方（簡潔）
const processUserDataWithSafeTry = (userId: number): Result<User, string> => {
  return safeTry<User, string>(function* () {
    const user = yield* findUserById(userId)
      .mapErr(e => `ユーザー取得失敗: ${e.message}`)
      .safeUnwrap()
    
    const validatedUser = yield* validateUser(user)
      .mapErr(e => `バリデーション失敗: ${e}`)
      .safeUnwrap()
    
    const updatedUser = yield* updateUser(validatedUser)
      .mapErr(e => `更新失敗: ${e.message}`)
      .safeUnwrap()
    
    return ok(updatedUser)
  })
}
```

## 非同期処理（ResultAsync）

```typescript
import { ResultAsync, okAsync, errAsync } from 'neverthrow'

// 非同期処理のチェーン
const asyncWorkflow = (input: string): ResultAsync<number, string> => {
  return okAsync(input)
    .andThen(value => 
      ResultAsync.fromPromise(
        fetch(`/api/process/${value}`),
        () => "ネットワークエラー"
      )
    )
    .andThen(response => 
      ResultAsync.fromPromise(
        response.json(),
        () => "JSONパースエラー"
      )
    )
    .andThen(data => {
      if (data.success) {
        return okAsync(data.result)
      }
      return errAsync("処理失敗")
    })
}

// 並列処理
const parallelProcessing = async (ids: number[]): Promise<Result<number[], string>> => {
  const results = await Promise.all(
    ids.map(id => fetchUser(id))
  )
  
  // 全て成功した場合のみOkを返す
  const allOk = results.every(result => result.isOk())
  if (allOk) {
    return ok(results.map(result => result.value))
  }
  
  // 一つでも失敗があれば最初のエラーを返す
  const firstError = results.find(result => result.isErr())
  return err(firstError!.error)
}
```

## ベストプラクティス

### 1. エラー型の設計

```typescript
// 具体的で型安全なエラー型を定義
interface ValidationError {
  type: "VALIDATION_ERROR"
  field: string
  message: string
}

interface DatabaseError {
  type: "DATABASE_ERROR"
  code: string
  message: string
}

interface NetworkError {
  type: "NETWORK_ERROR"
  status: number
  message: string
}

type AppError = ValidationError | DatabaseError | NetworkError
```

### 2. エラーの変換と統一

```typescript
// エラーを統一された形式に変換
const handleError = (error: AppError): string => {
  switch (error.type) {
    case "VALIDATION_ERROR":
      return `バリデーションエラー: ${error.field} - ${error.message}`
    case "DATABASE_ERROR":
      return `データベースエラー: ${error.code} - ${error.message}`
    case "NETWORK_ERROR":
      return `ネットワークエラー: ${error.status} - ${error.message}`
  }
}
```

### 3. テストでの使用

```typescript
import { ok, err } from 'neverthrow'

describe('neverthrowのテスト', () => {
  it('成功ケースのテスト', () => {
    const result = ok("成功")
    expect(result.isOk()).toBe(true)
    expect(result.value).toBe("成功")
  })

  it('失敗ケースのテスト', () => {
    const result = err("失敗")
    expect(result.isErr()).toBe(true)
    expect(result.error).toBe("失敗")
  })

  it('チェーン処理のテスト', () => {
    const result = ok("123")
      .map(value => parseInt(value, 10))
      .andThen(value => value > 0 ? ok(value) : err("負の数"))
    
    expect(result).toEqual(ok(123))
  })
})
```

## まとめ

neverthrowを使った関数型エラーハンドリングは、従来のtry/catchとは異なる、型安全で宣言的なアプローチを提供します。Result型による明示的な成功/失敗の表現、チェーン処理による読みやすいコード、safeTryによる簡潔なエラーハンドリングなど、多くのメリットがあります。

特にTypeScriptとの相性が良く、型システムを活用した安全なエラー処理が実現できます。実践的な使用例を参考に、プロジェクトにneverthrowを導入して、より堅牢で保守性の高いコードを書いてみてください。

関数型プログラミングの考え方を取り入れたエラーハンドリングで、バグの少ないアプリケーション開発を目指しましょう。
