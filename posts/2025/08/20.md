---
date: 2025-08-20
title: TypeScriptで学ぶ関数型アルゴリズム：フィボナッチ数列から再帰・メモ化まで
description: TypeScriptを使った関数型プログラミングによるアルゴリズム実装を詳しく解説。フィボナッチ数列を題材に、純粋関数、再帰、メモ化、Result型を使ったエラーハンドリングまで、実践的な関数型アルゴリズムの実装方法を紹介します。
tags:
  - typescript
  - functional-programming
  - algorithms
  - fibonacci
  - recursion
  - memoization
  - neverthrow
  - pure-functions
prev:
  text: 'TypeScriptによる画像軽量化処理：Canvas APIとWeb Workersを使った実践的な最適化手法'
  link: '/posts/2025/08/19'
next: false
---

# TypeScriptで学ぶ関数型アルゴリズム：フィボナッチ数列から再帰・メモ化まで

アルゴリズムの実装は、プログラミングの基礎を学ぶ上で重要な要素です。本記事では、TypeScriptを使った関数型プログラミングによるアルゴリズム実装を詳しく解説します。フィボナッチ数列を題材に、純粋関数、再帰、メモ化、Result型を使ったエラーハンドリングまで、実践的な関数型アルゴリズムの実装方法をご紹介します。

## 関数型プログラミングとアルゴリズム

関数型プログラミングは、計算を数学的関数の評価として扱い、状態の変更やデータの可変性を避けるプログラミングパラダイムです。アルゴリズムの実装において、関数型プログラミングの原則を適用することで、以下のメリットが得られます：

- **予測可能性**: 同じ入力に対して常に同じ出力を返す
- **テスト容易性**: 副作用がないため、単体テストが簡単
- **並行性**: 状態を共有しないため、並行処理が安全
- **保守性**: コードの意図が明確で、バグが発生しにくい

### 関数型プログラミングの基本原則

1. **純粋関数**: 副作用を持たず、同じ入力に対して常に同じ出力を返す
2. **不変性**: データの変更ではなく、新しいデータの作成
3. **高階関数**: 関数を引数として受け取り、関数を返す
4. **関数合成**: 複数の関数を組み合わせて新しい関数を作成

## フィボナッチ数列の実装

### 基本的な再帰実装

まず、フィボナッチ数列の基本的な再帰実装から始めましょう。

```typescript
/**
 * フィボナッチ数列のn番目の数を計算する（基本再帰版）
 * @param n - 計算したい項の番号（0以上の整数）
 * @returns n番目のフィボナッチ数
 */
const fibonacci = (n: number): number => {
  if (n <= 0) return 0
  if (n === 1) return 1
  return fibonacci(n - 1) + fibonacci(n - 2)
}
```

この実装は理解しやすいですが、大きな値に対して非常に非効率です。計算量はO(2^n)となり、n=40程度でも実行時間が爆発的に増加します。

### 末尾再帰による最適化

関数型プログラミングでは、末尾再帰を使った最適化が一般的です。

```typescript
/**
 * フィボナッチ数列のn番目の数を計算する（末尾再帰版）
 * @param n - 計算したい項の番号（0以上の整数）
 * @returns n番目のフィボナッチ数
 */
const fibonacciTail = (n: number): number => {
  const fibonacciHelper = (n: number, a: number, b: number): number => {
    if (n <= 0) return a
    if (n === 1) return b
    return fibonacciHelper(n - 1, b, a + b)
  }

  return fibonacciHelper(n, 0, 1)
}
```

末尾再帰版では、計算量がO(n)に改善され、スタックオーバーフローのリスクも軽減されます。

### メモ化による最適化

メモ化は、計算結果をキャッシュして重複計算を避ける手法です。

```typescript
/**
 * メモ化されたフィボナッチ関数
 * @param n - 計算したい項の番号（0以上の整数）
 * @returns n番目のフィボナッチ数
 */
const fibonacciMemo = (() => {
  const memo = new Map<number, number>()

  return (n: number): number => {
    if (memo.has(n)) {
      return memo.get(n)!
    }

    if (n <= 0) return 0
    if (n === 1) return 1

    const result = fibonacciMemo(n - 1) + fibonacciMemo(n - 2)
    memo.set(n, result)
    return result
  }
})()
```

## Result型を使ったエラーハンドリング

関数型プログラミングでは、例外を投げる代わりにResult型を使ってエラーを表現します。

```typescript
import { Result, ok, err } from 'neverthrow'

type FibonacciError =
  | { readonly _tag: 'NegativeNumber'; readonly value: number }
  | { readonly _tag: 'Overflow'; readonly value: number }

/**
 * 安全なフィボナッチ計算関数
 * @param n - 計算したい項の番号
 * @returns Result型でラップされたフィボナッチ数
 */
const safeFibonacci = (n: number): Result<number, FibonacciError> => {
  // 負の数のチェック
  if (n < 0) {
    return err({ _tag: 'NegativeNumber', value: n })
  }

  // オーバーフローのチェック（JavaScriptの制限）
  if (n > 1476) {
    return err({ _tag: 'Overflow', value: n })
  }

  const fibonacciHelper = (n: number, a: number, b: number): number => {
    if (n <= 0) return a
    if (n === 1) return b
    return fibonacciHelper(n - 1, b, a + b)
  }

  return ok(fibonacciHelper(n, 0, 1))
}
```

### Result型の活用例

```typescript
// エラーハンドリングの例
const calculateFibonacci = (n: number): void => {
  const result = safeFibonacci(n)

  result
    .map((fib) => console.log(`フィボナッチ(${n}) = ${fib}`))
    .mapErr((error) => {
      switch (error._tag) {
        case 'NegativeNumber':
          console.error(`エラー: 負の数 ${error.value} はサポートされていません`)
          break
        case 'Overflow':
          console.error(`エラー: 数値 ${error.value} は大きすぎます`)
          break
      }
    })
}
```

## 高階関数を使ったアルゴリズム実装

### 関数合成による実装

関数型プログラミングでは、小さな関数を組み合わせて複雑な処理を実現します。

```typescript
/**
 * 関数合成のためのユーティリティ
 */
const compose =
  <T, U, V>(f: (x: U) => V, g: (x: T) => U) =>
  (x: T): V =>
    f(g(x))

/**
 * フィボナッチ数列の最初のn項を生成する関数
 */
const generateFibonacciSequence = (n: number): readonly number[] => {
  const range = (start: number, end: number): readonly number[] =>
    Array.from({ length: end - start }, (_, i) => start + i)

  const mapFibonacci = (numbers: readonly number[]): readonly number[] => numbers.map(fibonacciTail)

  return compose(mapFibonacci, (n: number) => range(0, n))(n)
}
```

### 遅延評価による実装

無限リストの概念を使って、必要な分だけ計算する実装も可能です。

```typescript
/**
 * 無限フィボナッチ数列のジェネレーター
 */
const fibonacciGenerator = function* (): Generator<number, never, unknown> {
  let [a, b] = [0, 1]

  while (true) {
    yield a
    ;[a, b] = [b, a + b]
  }
}

/**
 * フィボナッチ数列から最初のn項を取得
 */
const takeFibonacci = (n: number): readonly number[] => {
  const generator = fibonacciGenerator()
  return Array.from({ length: n }, () => generator.next().value)
}
```

## パフォーマンス比較とベンチマーク

各実装のパフォーマンスを比較してみましょう。

```typescript
/**
 * 実行時間を測定するユーティリティ
 */
const measureTime = <T>(fn: () => T): { readonly result: T; readonly time: number } => {
  const start = performance.now()
  const result = fn()
  const end = performance.now()
  return { result, time: end - start }
}

/**
 * 各実装のパフォーマンスを比較
 */
const benchmarkFibonacci = (n: number): void => {
  console.log(`フィボナッチ(${n})の計算時間比較:`)

  // 基本再帰版（小さい値のみ）
  if (n <= 30) {
    const { time } = measureTime(() => fibonacci(n))
    console.log(`基本再帰版: ${time.toFixed(2)}ms`)
  }

  // 末尾再帰版
  const { time: tailTime } = measureTime(() => fibonacciTail(n))
  console.log(`末尾再帰版: ${tailTime.toFixed(2)}ms`)

  // メモ化版
  const { time: memoTime } = measureTime(() => fibonacciMemo(n))
  console.log(`メモ化版: ${memoTime.toFixed(2)}ms`)
}
```

## 実践的な応用例

### フィボナッチ数列を使った問題解決

フィボナッチ数列は、様々な問題解決に応用できます。

```typescript
/**
 * 階段を登る問題（1段または2段ずつ登る）
 * これはフィボナッチ数列と同じ解になります
 */
const climbStairs = (n: number): number => {
  if (n <= 2) return n
  return climbStairs(n - 1) + climbStairs(n - 2)
}

/**
 * 動的計画法を使った最適化版
 */
const climbStairsDP = (n: number): number => {
  if (n <= 2) return n

  let [a, b] = [1, 2]
  for (let i = 3; i <= n; i++) {
    ;[a, b] = [b, a + b]
  }
  return b
}
```

### フィボナッチ数列の数学的性質

```typescript
/**
 * フィボナッチ数列の黄金比を計算
 */
const calculateGoldenRatio = (n: number): number => {
  const fib1 = fibonacciTail(n)
  const fib2 = fibonacciTail(n - 1)
  return fib1 / fib2
}

/**
 * フィボナッチ数列が素数かどうかを判定
 */
const isPrime = (n: number): boolean => {
  if (n < 2) return false
  if (n === 2) return true
  if (n % 2 === 0) return false

  for (let i = 3; i <= Math.sqrt(n); i += 2) {
    if (n % i === 0) return false
  }
  return true
}

/**
 * フィボナッチ素数を求める
 */
const findFibonacciPrimes = (limit: number): readonly number[] => {
  return generateFibonacciSequence(limit).filter(isPrime)
}
```

## まとめ

本記事では、TypeScriptを使った関数型プログラミングによるアルゴリズム実装について詳しく解説しました。フィボナッチ数列を題材に、以下の重要な概念を学びました：

### 学んだポイント

1. **純粋関数の重要性**: 副作用を持たない関数は、テストしやすく、予測可能です
2. **再帰の最適化**: 末尾再帰やメモ化により、パフォーマンスを大幅に改善できます
3. **エラーハンドリング**: Result型を使うことで、例外を使わずにエラーを安全に処理できます
4. **関数合成**: 小さな関数を組み合わせることで、複雑な処理を実現できます
5. **遅延評価**: 必要な分だけ計算することで、メモリ効率を改善できます

### 実践への応用

これらの概念は、フィボナッチ数列以外のアルゴリズムにも応用できます：

- **ソートアルゴリズム**: クイックソート、マージソートの関数型実装
- **探索アルゴリズム**: 二分探索、深さ優先探索、幅優先探索
- **動的計画法**: メモ化を活用した最適化問題の解決
- **グラフアルゴリズム**: 関数型プログラミングによるグラフ処理

関数型プログラミングの原則を理解し、適切なアルゴリズムを選択することで、保守性が高く、バグの少ないコードを書くことができます。TypeScriptの型システムと組み合わせることで、さらに安全で信頼性の高いアルゴリズム実装が可能になります。

いかがでしたか？関数型プログラミングによるアルゴリズム実装の魅力を感じていただけたでしょうか。次回は、より高度な関数型プログラミングのテクニックや、他のアルゴリズムへの応用例についても詳しく解説していきたいと思います。
